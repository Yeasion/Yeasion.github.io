<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏·浅</title>
  
  <subtitle>Sue Shallow</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://Yeasion.github.io/"/>
  <updated>2019-11-11T11:52:30.934Z</updated>
  <id>http://Yeasion.github.io/</id>
  
  <author>
    <name>Sue Shallow</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++介绍以及编译执行和调试</title>
    <link href="http://Yeasion.github.io/2019/11/11/C++%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95/"/>
    <id>http://Yeasion.github.io/2019/11/11/C++介绍以及编译执行和调试/</id>
    <published>2019-11-11T14:16:31.000Z</published>
    <updated>2019-11-11T11:52:30.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-介绍以及编译执行和调试"><a href="#C-介绍以及编译执行和调试" class="headerlink" title="C++介绍以及编译执行和调试"></a>C++介绍以及编译执行和调试</h1><h3 id="C-的介绍"><a href="#C-的介绍" class="headerlink" title="C++的介绍"></a>C++的介绍</h3><p>C++，实际上是另一种语言的衍生版本，它就是C，而这个语言在研发初期的名字叫做“<strong>带类的C</strong>”，那么很显然这个语言的一大特色就在于它具有class。C++是一种面向对象的程序设计语言，在基本所有的系统中都可以运行。</p><p>C的一大特点就是<strong>高性能</strong>，它的速度基本是所有高级语言中最快的，因此为了保证速度，C++语言都是编译型的。这也是它为什么可以成为算法竞赛的主流语言的原因。</p><h3 id="C-的编译和执行"><a href="#C-的编译和执行" class="headerlink" title="C++的编译和执行"></a>C++的编译和执行</h3><p>关于编译执行C++程序，由于国内的算法竞赛在NOIP（目前已经成为CSP）默认使用的IDE都是Dev-C++，因此笔者就权当读者们的电脑上已经配置好了相关程序。</p><p>接下来，在代码框内打出如下代码，按下F11便可以进行编译和执行了！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World !"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，在这里我们要为大家讲解的并不只是一个简单的F11而已。读者要清楚C++文件的编译依靠的是G++，是属于GNU的编译器，而在一般情况下G++编译文件有以下几步：</p><ol><li>预处理生成后缀名为.i的文件</li><li>转换为汇编语言.s</li><li>转换为目标代码.o</li><li>连接目标代码，生成可执行程序.exe</li></ol><p>那么接下来我们就尝试在命令行里面执行这些操作。</p><p>按下Win + R输入cmd即可进入命令指示符，然后我们通过cd命令进入保存好的代码源文件所在的文件夹。</p><p><img src="https://s2.ax1x.com/2019/11/06/MiVVL4.png" alt="EnterFolder"></p><p>然后我们输入以下指令</p><blockquote><p>> g++ code.cpp -o code.exe</p></blockquote><p><img src="https://s2.ax1x.com/2019/11/06/MiVtwd.png" alt="G++1"></p><p>注意，在这个地方如果我们的代码有错误，那么是会出现问题的。</p><p>比如我们的代码在最后去掉了return 0 的分号：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World !"</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么运行这个命令的时候就会出现以下情况：</p><p><img src="https://s2.ax1x.com/2019/11/06/MiVgTs.png" alt="G++2"></p><p>这时G++就提醒我们，在第6行出现了错误：没有加“;”。</p><p>然后在保证没有错误的情况下，我们执行以下命令就可以运行这个程序了。</p><blockquote><p>> code.exe</p></blockquote><p><img src="https://s2.ax1x.com/2019/11/06/MiZM7j.png" alt="G++4"></p><p>而如果我们不加-o code.exe的话那么给出的文件将是默认的a.exe，而运行这个a.exe也是可以得出正确的结果的。</p><p><img src="https://s2.ax1x.com/2019/11/06/Miep80.png" alt="G++5"></p><p>这个-o是什么意思呢，它可以让我们自定义输入文件名和输出文件名。当然并不是指的你的源代码的程序输入和输出，而是指的g++的输入和输出，对于上面的code.cpp来说，如果不加-o那么就相当于是输入了code.cpp文件，然后输出了a.exe文件，而如果我们加了-o就可以是g++输出code.cpp文件。</p><h3 id="源代码的调试"><a href="#源代码的调试" class="headerlink" title="源代码的调试"></a>源代码的调试</h3><p>对于调试，很多人都是直接使用的Dev-C++的内置调试，但是经常会出现错误，因此在命令行里面进行调试也是很不错的选择。</p><p>为了充分解释各种命令，我们写了一个较为复杂的程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> X, Y, Z ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5</span> ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Solve</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    Z = X * X + Y * Y ;</span><br><span class="line">    <span class="keyword">return</span> Z ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; X &gt;&gt; Y ;</span><br><span class="line">    X = X * <span class="number">2</span> ;</span><br><span class="line">    Y = Y / <span class="number">2</span> ;</span><br><span class="line">    Solve(X, Y) ;</span><br><span class="line">    Z = Z + <span class="number">1</span> ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Z &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想必大家也都能看懂这个程序，笔者不再解释。我们把它保存为code2.cpp</p><p>接下来我们在命令行里面输入如下指令：</p><blockquote><p>> g++ code2.cpp -g -o code2.exe</p></blockquote><p>可以发现这个指令比之前多了一个-g，它可以使我们的g++输出调试信息。</p><blockquote><p>> gdb code2.exe</p></blockquote><p>这样我们便可以调试这个程序了。</p><p><img src="https://s2.ax1x.com/2019/11/06/MinT81.png" alt="GDB"></p><p>接下来如果我们直接输入run指令，那么程序会直接执行到底，与不调试没有什么不同。</p><p><img src="https://s2.ax1x.com/2019/11/06/MiuZ5j.png" alt="GDB2"></p><p>因此和Dev-c++一样，我们一开始也要先设置断点。在这里你可以设置第几行，也可以直接写函数名称。而设置断点的指令叫做b</p><blockquote><p>(gdb) b main</p></blockquote><p><img src="https://s2.ax1x.com/2019/11/06/MiuvLT.png" alt="GDB3"></p><p>于是你发现现在程序直接执行到了main函数的第一行。按下n指令我们可以向后进行。</p><p><img src="https://s2.ax1x.com/2019/11/06/MiKpo4.png" alt="GDB5"></p><p>因为接下来我们要输入，所以输入完毕后程序才到了下一行。</p><p>直接回车是执行上一次的指令，那么我们直接回车程序便会向后执行。</p><p><img src="https://s2.ax1x.com/2019/11/06/MiKAQx.png" alt="GDB6"></p><p>可以发现现在执行到了要进入函数的这一行。先等一等，我们输入p后面跟变量名称可以查看现在的变量的数值。</p><p><img src="https://s2.ax1x.com/2019/11/06/MiKMYd.png" alt="GDB7"></p><p>没有什么问题我们就想继续进行了。但是这里不能直接n了，直接n我们会直接跳过了这个函数的执行部分，这个时候如果我们想进入函数，要输入s</p><p><img src="https://s2.ax1x.com/2019/11/06/MiKt0S.png" alt="GDB7"></p><p>成功进入了函数，但是现在我们遇到了一个循环结构，那么如果我们想时时刻刻查看Z的数值，不用每一次都p，我们只需要display Z 就可以将Z设为默认查看变量，每一次程序往下执行都会显示。</p><p><img src="https://s2.ax1x.com/2019/11/06/MiK6mT.png" alt="GDB8"></p><p>可以发现每一次继续执行都会显示出Z的大小。那么如果我们不需要查看Z了，我们需要undisplay 1，其中1是gdb给Z的编号。</p><p><img src="https://s2.ax1x.com/2019/11/06/MiKRk4.png" alt="GDB9"></p><p>此时GDB便不会再一直显示Z的大小了。</p><p>最后，输入q我们便可以推出gdb回到命令行了。</p><p>下面是一些GDB能够用到的基本操作，给大家列出来以方便使用</p><div class="table-container"><table><thead><tr><th>命令</th><th>命令缩写</th><th>作用</th></tr></thead><tbody><tr><td>list</td><td>l</td><td>显示当前行或指定行附近的多行代码</td></tr><tr><td>break</td><td>b</td><td>设置断点到指定行</td></tr><tr><td>info</td><td>i</td><td>描述程序当前状态</td></tr><tr><td>run</td><td>r</td><td>开始执行程序</td></tr><tr><td>display</td><td>disp</td><td>默认显示某个变量的数值</td></tr><tr><td>step</td><td>s</td><td>进入函数</td></tr><tr><td>next</td><td>n</td><td>继续执行</td></tr><tr><td>print</td><td>p</td><td>查看一次变量的当前数值</td></tr><tr><td>continue</td><td>c</td><td>运行到下一个断点</td></tr><tr><td>start</td><td>st</td><td>开始执行程序到main函数</td></tr><tr><td>kill</td><td>k</td><td>终止正在执行的程序</td></tr><tr><td>backtrace</td><td>bt</td><td>查看堆栈信息</td></tr><tr><td>watch</td><td></td><td>监视变量变化（在变量数值发生变化时停止继续执行）</td></tr><tr><td>set var name = value</td><td></td><td>改变变量name的值value</td></tr><tr><td>quit</td><td>q</td><td>退出GDB</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      关于C++的入门介绍以及命令行中的编译执行和调试。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://Yeasion.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>并行编程：进程与线程</title>
    <link href="http://Yeasion.github.io/2019/11/11/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://Yeasion.github.io/2019/11/11/并行编程：进程与线程/</id>
    <published>2019-11-11T01:49:34.000Z</published>
    <updated>2019-11-11T11:55:16.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><blockquote><p>进程就是<strong>一个执行中程序的实例</strong>。</p></blockquote><p>对于Python的编程以及程序，我们通常要经历很久的等待时间，而这种等待的原因分为两个：</p><ol><li><p>$I/O$限制</p><p>主要是由于I/O设备的处理速度跟不上CPU处理速度造成的等待。</p></li><li><p>$CPU$限制</p><p>在进行很大数据或者复杂程度比较高的运算的时候经常遇到的CPU速度的限制。</p></li></ol><p>而要解决这两种限制，我们必须要了解进程以及并发。</p><p>首先要知道，系统中所有的程序都运行在某一个进程的<strong>上下文</strong>当中。而上下文就是程序正确运行所需要的状态。可以包括程序的代码和数据、栈以及寄存器内容、$PC$、环境变量、打开文件描述符集合等等，你并不需要都知道这是什么东西，你只要知道这是<strong>程序正确运行的状态</strong>就可以了。</p><p>当你的程序在你的电脑上运行的时候，你会想当然地以为整个系统只有这个程序在运行，那是因为操作系统给你提供了一种<strong>假象</strong>，让你这么以为。那么我们也可以这么说：</p><blockquote><p>进程是操作系统对一个正在运行的程序的一种<strong>抽象</strong>。</p></blockquote><p>我们当然知道编译器的运行其实就相当于对shell说“运行这个程序”，那么这个时候我们的shell做了什么呢？此时，shell会创建一个新的进程，然后在这个进程的上下文当中运行你的文件，也就好像我们的程序占据了整个系统。</p><p>而这种假象大致可以分为两点：</p><ol><li><strong>独立逻辑控制流的假象</strong>：好像我们的程序在独占处理器？</li><li><strong>私有地址空间的假象</strong>：好像我们的程序在独占内存系统？</li></ol><p>下面我们一个个解释。</p><h3 id="逻辑控制流"><a href="#逻辑控制流" class="headerlink" title="逻辑控制流"></a>逻辑控制流</h3><p>不要被名字吓到，这个玩意其实相当简单。现在你的系统中有许多的程序在运行，但是我们不要忘了：</p><blockquote><p>在任何一个时刻，单处理器系统都只能处理一个进程的代码。</p></blockquote><p>于是我们有了一种<strong>流</strong>，表示进程运行的序列 ，也可以简称为<strong>逻辑流</strong>。</p><p><img src="https://s2.ax1x.com/2019/04/24/EVDLYd.png" alt="LCS"></p><p>​    上面的这个图可以很好的说明这个事了吧。首先$A$进程运行了一个<strong>时间片</strong>，然后操作系统内核进行了上下文切换，开始进行进程$B$，因为进程$B$只有一个时间片，所以直接进行完了，接着又是上下文切换到了进程$C$，运行完一个时间片之后切换完成了$A$，然后反过头来又进行完了$C$。</p><p>其实整个步骤的关键就在于<strong>进程是轮流使用控制器</strong>的，而逻辑控制流就是这么一个东西。</p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>关于上面的<strong>上下文切换</strong>我们先简单介绍一下，这个东西是操作系统转换执行进程的手段，是一种较高层次形式的一场控制流，主要由<strong>操作系统内核</strong>管理，步骤大致如下：</p><ol><li>保存当前进程的上下文</li><li>回复新进程的上下文</li><li>传递控制权</li></ol><p>其实一个进程并不一定能够从头到尾直接一条龙的执行完毕，在进程执行的时候，内核可以决定抢占这个进程，然后重新开始另外一个进程——当然它之前也被抢占过。而这种决策也叫作<strong>调度</strong>，由内核中的<strong>调度器</strong>执行。</p><p>而这个玩意的意义在哪里呢？因为我们使用系统的过程可能并不是一帆风顺的，往往当前的进程会由一些$unexpected$的事故导致<strong>阻塞</strong>，那么这时内核的调度器就可以选择休眠这个进程，进行别的进程。你也可以很简单的使用你的C++来实现这个休眠，一个sleep就可以了。下图展示了之前的举例的逻辑控制流的$A$到$B$的切换。</p><p><img src="https://s2.ax1x.com/2019/04/24/EVsQDf.png" alt="Change"></p><h3 id="私有地址空间"><a href="#私有地址空间" class="headerlink" title="私有地址空间"></a>私有地址空间</h3><blockquote><p>地址空间表示任何一个计算机实体所占用的内存大小。比如外设、文件、服务器或者一个网络计算机。地址空间包括物理空间以及虚拟空间。</p></blockquote><p>在一台地址为$n$位的机器上，地址空间表示$2^n$个可能地址的集合，而进程为每个程序提供<strong>私有地址空间</strong>。在计算机中，每一个设备以及进程都被分配了一个地址空间。</p><p>为什么说是私有呢？因为一般情况下一个空间中与某个地址相关联的内存字节是不能该被其他进程读写的。下面给出的是这个空间的通用结构：</p><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike72%2C5%2C5%2C72%2C24/sign=30465798d933c895b2739029b07a1895/242dd42a2834349b3c594e8ac9ea15ce36d3be65.jpg" alt="img"></p><p>关于地址空间的介绍不多说了，想要详细了解的请自行维基。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>这个玩意可以视作是一个“单位”，一个进程的单位。因为在现代的系统当中，每一个进程都是有多个称为<strong>线程</strong>的执行单元组成的，每一个线程都运行在进程的上下文当中，共享代码和全局数据。</p><p>一条线程指的是中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p><p>我们的Python支持的不仅仅是<strong>多进程</strong>，也支持<strong>多线程</strong>，其实这两个玩意的最终目的都是同时执行多个编程任务。在计算机科学当中，运行在操作系统中的每一个进程可以拥有多个线程，每一个进程都有自己独享的内存，也就是说这个进程里面的多个线程可以共享一块内存，但是多个进程之间就不行了，它们必须进行显式的通信。因此，可以认为多线程之间比多进程之间更容易共享数据，使得程序运行的更快，因此，由于网络服务器中对并行处理的需求，线程正在成为越来越重要的编程模型。</p><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>方才我们提到了逻辑控制流，而计算机系统中有非常多类型的逻辑流，其中就有一种叫做“<strong>并发流</strong>”。它的定义是：一个逻辑流的执行在时间上与另一个流重叠。但是不要混淆概念：是重叠，但并不代表是同时执行。就好像最开始举得例子：A与B是并发，但是B和C就不是，因为B和C并没有重叠部分。</p><p>多个流并发地执行的一般现象被称为<strong>并发</strong>。一个进程和其他进程轮流运行的概念称为<strong>多任务</strong>。</p><p>以上的内容当然十分简单，但是下面我们要做的是对进程、线程的代码方面的实际应用。</p><h2 id="进程池实现"><a href="#进程池实现" class="headerlink" title="进程池实现"></a>进程池实现</h2><p>这里我们的进程池的实现方法是多进程，大家必然不陌生这个东西。现在我们尝试创建两个进程，让每一个进程都输出一个”WORKING”，最后让主进程输出”WORKOUT!!!”结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing <span class="keyword">as</span> MP, time, os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PRINT</span><span class="params">(name, MSG)</span>:</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">print(<span class="string">"process %s %s says: %s"</span> % (name, str(os.getpid()), MSG))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">print(<span class="string">"process %s says: %s"</span> % (os.getpid(), <span class="string">"WORKING"</span>))</span><br><span class="line"></span><br><span class="line">task1 = MP.Process(target = PRINT, args = (<span class="string">"1"</span>, <span class="string">"WORKING"</span>))</span><br><span class="line">print(<span class="string">"Now processing!"</span>)</span><br><span class="line">task1.start()</span><br><span class="line"></span><br><span class="line">task2 = MP.Process(target = PRINT, args = (<span class="string">"1"</span>, <span class="string">"WORKING"</span>))</span><br><span class="line">print(<span class="string">"Now processing!"</span>)</span><br><span class="line">task2.start()</span><br><span class="line"></span><br><span class="line">task1.join()</span><br><span class="line">task2.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Process close'</span>)</span><br></pre></td></tr></table></figure><p>我们从上到下解释一下。首先我们目前用的多进程模块就叫做”multiprocessing”，其中有一个类叫做”Process”，我们可以用这个类完成一个进程对象的描述。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span></span><br></pre></td></tr></table></figure><p>这一段的意思我还是解释一下，如果你并非新手当然可以跳过。</p><p>我们知道Python的代码有两种使用方式，一种是直接运行，另一种就是import进另一份代码里面。也就是说一种是<strong>脚本执行</strong>，另一种是<strong>模块调用</strong>。而在上面这行代码下的代码只有在脚本执行的时候才会被执行。为什么呢？我们每一份代码（也称作<strong>模块</strong>）都有一个内置的变量$__name__$，当模块被直接执行的时候，$__name__$就等于文件名，而如果import到其他模块当中就等于那个模块的名称。而$__main__$一直等于自己模块的名称，因此只有脚本执行的时候才会有上述的语句为真。</p><p>然后我们看到对于task1和task2的定义是这样的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task1 = MP.Process(target = PRINT, args = (<span class="string">"1"</span>, <span class="string">"WORKING"</span>))</span><br></pre></td></tr></table></figure><p>其中target是执行函数的名字，args是函数需要的参数元组。</p><p>然后start方法启动进程，join方法实现进程同步，等待所有进程退出。</p><p>在上面的代码中我们看到每一个进程都是输出了一遍WORKING，而进程之间是不能够共享数据的。</p><p>下面介绍的东西叫做Pool，也是multiprocessing模块里面的内容，作用是预先构造进程池，然后每次使用进程的时候会在进程池里面申请一个进程。对于apply方法，可以理解为“进程排队执行”，每一个进程都是从头进行到尾，也就是只有一个时间片。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pool, Manager</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PRINT</span><span class="params">(MSG)</span>:</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">print(MSG, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">pool = Pool(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">pool.apply(func = PRINT, args = (str(i) + <span class="string">"said 'Hello'"</span>,))</span><br><span class="line">print(i, <span class="string">"Prepare OK"</span>)</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><p>close顾名思义，在调用它之后们不会有任何新的进程加入到pool。</p><p>另外还有一个apply_async模块支持回调。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pool, Manager</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PLUS</span><span class="params">(MSG)</span>:</span></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> MSG + <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PRINT</span><span class="params">(MSG)</span>:</span></span><br><span class="line">print(MSG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">pool = Pool(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">pool.apply_async(func = PLUS, args = (i,), callback = PRINT)</span><br><span class="line">print(i, <span class="string">"Prepare OK"</span>)</span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><p>以上这个程序会输出100 ~ 109的所有数。</p><h2 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h2><p>Python内部也提供了很好的模块叫做threading，我们可以用它来实现线程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Doit</span><span class="params">(MSG)</span>:</span></span><br><span class="line">PRINT(MSG)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PRINT</span><span class="params">(MSG)</span>:</span></span><br><span class="line">print(threading.current_thread(), <span class="string">"says:"</span>, MSG)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">PRINT(<span class="string">"I'm main"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">thread = threading.Thread(target = Doit, args = (<span class="string">"I'm child"</span>,))</span><br><span class="line">thread.start()</span><br></pre></td></tr></table></figure><p>threading.current_thread()是返回当前的Thread对象，对应于调用者的控制线程。start()也是启动线程活动。这里没有加close()、join()之类的函数是因为默认情况下程序就会等待线程全部执行完毕才停止的，但是也可以更改为后台线程，让主线程优先。</p><h3 id="实例分析：文章编写与上传"><a href="#实例分析：文章编写与上传" class="headerlink" title="实例分析：文章编写与上传"></a>实例分析：文章编写与上传</h3><p>假设你是一个网络文章工作者（我也不知道这个名称是怎么来的），被分配了两种任务：编写文章到本地以及将本地文章上传到云上。这都是很简单的工作以至于你一个人就可以完成，那么你的工作流程大致可以分为两种：</p><ol><li>每次编写完一篇文章都即时上传，然后删除本地的这篇文章。</li><li>先编写完所有的文章之后统一上传，然后删除所有的文章。</li></ol><p>这两种方法看起来好像没有很大的区别，但是第二种方法却要临时地占用更大的本地磁盘空间，相比之下就不如第一步来的优。</p><p>那么如果这个工作被分配了另外一个人呢？那么工作的分配可以是一个人负责编写文章，另一个人负责上传，这都需要一定的时间，那么为了工作的流畅性，就要考虑两个人速度的问题，因为如果编写文章的人的速度非常快，那么就有可能出现文章堆积的情况。要么在上传文章的人上传完它那篇文章之前一直闲着，要么就把它堆积下来，而总的来说处理的最终速度都是取决于最慢的那个人。</p><p>multiprocessing模块里面有一个queue类，也就是<strong>队列</strong>，想必大家肯定都不陌生，我也就不再解释。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing, time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(articles, queue)</span>:</span></span><br><span class="line"><span class="keyword">for</span> article <span class="keyword">in</span> articles:</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'Writing'</span>, article)</span><br><span class="line">queue.put(article)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updater</span><span class="params">(queue)</span>:</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">article = queue.get()</span><br><span class="line">print(<span class="string">'Updating'</span>, article)</span><br><span class="line">queue.task_done()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">Queue = multiprocessing.JoinableQueue()</span><br><span class="line">Updater = multiprocessing.Process(target = updater, args = (Queue,))</span><br><span class="line">Updater.daemon = <span class="keyword">True</span></span><br><span class="line">Updater.start()</span><br><span class="line"></span><br><span class="line">Articles = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>]</span><br><span class="line">writer(Articles, Queue)</span><br></pre></td></tr></table></figure><p>$queue.task_done()$：使用者使用此方法发出信号，表示queue.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常。</p><p>$queue.join()$：生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用queue.task_done（）方法为止。</p><p>$p.daemon=True$：设置为守护进程，在主线程停止时p也停止，但是不用担心，producer内调用q.join保证了consumer已经处理完队列中的所有元素</p>]]></content>
    
    <summary type="html">
    
      熟悉并发编程的人可能在初步的时候都有过一段比较痛苦的经历，就是完全搞不明白进程与线程的相关内容，在这里博主以尽量鲜活的语言进行详细介绍。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="python" scheme="http://Yeasion.github.io/tags/python/"/>
    
      <category term="并发" scheme="http://Yeasion.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Contest Nodeocder1100</title>
    <link href="http://Yeasion.github.io/2019/10/29/Contest%20Nowcoder1100/"/>
    <id>http://Yeasion.github.io/2019/10/29/Contest Nowcoder1100/</id>
    <published>2019-10-29T14:16:31.000Z</published>
    <updated>2019-11-11T11:52:39.602Z</updated>
    
    <content type="html"><![CDATA[<h3 id="仓鼠的石子游戏"><a href="#仓鼠的石子游戏" class="headerlink" title="仓鼠的石子游戏"></a>仓鼠的石子游戏</h3><blockquote><p>有$N$个石圈，每个石圈有$A[i]$个石头围成一圈，有两个人轮流对石子进行染色，相邻不能同色，首先不能操作的一方输，求先手必赢还是后手必赢。</p></blockquote><p>这个题叭，说是博弈论，但是比较好推。首先讨论只有一个石圈的情况。那么我们发现对于偶数个的话，我们类比“放盘子问题”，对于先手放的每一个石头，我们都放到过石圈中点的对称位置，那么先手一定先不能走。</p><p>再讨论奇数的时候，我们后手每一次都放到先手的相邻位置，那么我们依然必赢。也就是说对于一个石圈，无论是奇数还是偶数（1除外），先手都是必输的。</p><p>但是唯一的不同之处就在于1，1的时候先手是必赢的。</p><p>那么转而来看多个石圈，你会发现没有任何不同，你可能会认为对于一个圈$A[i]$，先手某一次不放$A[i]$而转战$A[j]$就会改变$A[i]$里面的先后手顺序。但是没有关系，我们后手只需要也转战$A[j]$就可以了。</p><p>这个时候我们会发现1仍然是个唯一的特例。所以我们手推几组样例就会发现奇数个1就是先手赢，而偶数个1就是后手赢。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int LL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS (Now &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS ((Now &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_Mid ((G[Now].L + G[Now].R) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> T, N, A[MAXN], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = Read() ; <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        N = Read() ; Ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">            A[i] = Read() ;</span><br><span class="line">            <span class="keyword">if</span> (A[i] == <span class="number">1</span>) Ans ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Ans &amp; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">"rabbit"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"hamster"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乃爱与城市拥挤程度"><a href="#乃爱与城市拥挤程度" class="headerlink" title="乃爱与城市拥挤程度"></a>乃爱与城市拥挤程度</h3><blockquote><p>给你一棵树，问你每个节点作为根的时候距离小于$K$的节点的个数以及这些节点动态权值的乘积。</p></blockquote><p>这是个换根DP。<br>首先对于第一问，我们设$Dp[i][j]$表示$i$点在$j$布以内的点数，那么转移的时候就转移到与自己联通的其他节点上，然后我们去除重复计算的j-2步向其他方向扩散的状态，就得到$Dp$方程：</p><script type="math/tex; mode=display">Dp[i][j] = Dp[S][j - 1] - Dp[i][j - 2] * (D[i] - 1)</script><p>（D表示度。）</p><p>对于第二问，我们考虑先随便找到一个根然后进行换根。我们先把随便找到的根进行Dp，然后储存起来。对于每一次换根，假设我们要从$X$转换到$Y$，那么对于$X$我们做一个自下而上的Dp，然后对于$Y$我们再做一个自上而下的Dp，然后合并一下就可以了。</p><p>（说白了还是瞎搞）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS (Now &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS ((Now &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_Mid ((G[Now].L + G[Now].R) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">15</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, H[MAXN], T, f[MAXN][MAXM], g[MAXN][MAXM] ;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> F[MAXN][MAXM], G[MAXN][MAXM], Ans[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Tot[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, nxt;</span><br><span class="line">    node(<span class="keyword">int</span> P = <span class="number">0</span>, <span class="keyword">int</span> Nxt = <span class="number">0</span>) &#123;</span><br><span class="line">        p = P;</span><br><span class="line">        nxt = Nxt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; Line[MAXN &lt;&lt; <span class="number">2</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>,  F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ?  -  <span class="number">1</span> : <span class="number">1</span>),  ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>),  ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X  *  F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">kasumi</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> base,  <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> res = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span>(K) &#123;</span><br><span class="line">        <span class="keyword">if</span>(K &amp; <span class="number">1</span>) res = (res  *  base)  %  mod;</span><br><span class="line">        K &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">        base = (base  *  base)  %  mod;</span><br><span class="line">    &#125;<span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> A = Read(),  B = Read() ;</span><br><span class="line">    Line[ ++  T] = node(B,  H[A]) ; H[A] = T ;</span><br><span class="line">    Line[ ++  T] = node(A,  H[B]) ; H[B] = T ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">predfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    f[now][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = H[now];i ; i = Line[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Line[i].p;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        predfs(v, now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= K; ++ j)</span><br><span class="line">            f[now][j]+=f[v][j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= K ; i ++ ) Tot[now]+=g[now][i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = H[now];i ; i = Line[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Line[i].p ;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span> ;</span><br><span class="line">        g[v][<span class="number">0</span>]=f[v][<span class="number">0</span>] ;</span><br><span class="line">        g[v][<span class="number">1</span>]=f[v][<span class="number">1</span>] + f[now][<span class="number">0</span>] ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= K; ++ j)</span><br><span class="line">            g[v][j]=f[v][j]+(g[now][j - <span class="number">1</span>] - f[v][j - <span class="number">2</span>]) ;</span><br><span class="line">        dfs(v, now) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= K; ++ i) F[now][i]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = H[now];i ; i = Line[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Line[i].p;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(v, now);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= K; ++ j)</span><br><span class="line">            F[now][j]=(F[now][j] * F[v][j - <span class="number">1</span>]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, t = <span class="number">1</span> ; i &lt;= K; ++ i) &#123;</span><br><span class="line">        t+=f[now][i];</span><br><span class="line">        F[now][i]=(F[now][i] * t) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    Ans[now]=G[now][K];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = H[now];i ; i = Line[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Line[i].p;</span><br><span class="line">        <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">        G[v][<span class="number">0</span>]=F[v][<span class="number">0</span>];</span><br><span class="line">        G[v][<span class="number">1</span>]=(((F[v][<span class="number">1</span>] * F[now][<span class="number">0</span>] % mod) * kasumi(f[v][<span class="number">1</span>], mod - <span class="number">2</span>)) % mod * g[v][<span class="number">1</span>]) % mod;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= K; ++ i)</span><br><span class="line">            G[v][i]=((((F[v][i] * kasumi(f[v][i], mod - <span class="number">2</span>) % mod * G[now][i - <span class="number">1</span>]) % mod * kasumi(g[now][i - <span class="number">1</span>], mod - <span class="number">2</span>)) % mod * kasumi(F[v][i - <span class="number">2</span>], mod - <span class="number">2</span>)) % mod * g[v][i]) % mod * (g[now][i - <span class="number">1</span>] - f[v][i - <span class="number">2</span>]) % mod;</span><br><span class="line">        dfs2(v, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; K = Read() ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; N ; ++ i) add();</span><br><span class="line">    predfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= K ; ++ i) g[<span class="number">1</span>][i]=f[<span class="number">1</span>][i];</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Tot[i]) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); dfs1(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= K; ++ j)</span><br><span class="line">        g[i][j]+=g[i][j - <span class="number">1</span>], f[i][j]+=f[i][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= K ; ++ i) G[<span class="number">1</span>][i]=F[<span class="number">1</span>][i];</span><br><span class="line">    dfs2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%lld "</span>, G[i][K]) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小w的魔术扑克"><a href="#小w的魔术扑克" class="headerlink" title="小w的魔术扑克"></a>小w的魔术扑克</h3><blockquote><p> $K$具有正反面的卡片，打出时只能选择一面，查询$Q$次，每次问是否能组成$L$到$R$的顺子。</p></blockquote><p>智障死了，这个题。<br>发现30pts特别好拿，时间不是很充足了就弄了个匈牙利匹配，然后用前缀和特判一下10分的正反相同的情况勉勉强强拿到了40分。考场上只写出来了这些。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS (Now &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS ((Now &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_Mid ((G[Now].L + G[Now].R) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, K, Q, Girl[MAXN], Use[MAXN], V[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Sum[MAXN], F = <span class="number">1</span>, H[MAXN], Tot ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> F, T, Next ;</span><br><span class="line">&#125;   E[MAXN &lt;&lt; <span class="number">1</span> * <span class="number">10</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F ; E[Tot].T = T ;</span><br><span class="line">    E[Tot].Next = H[F], H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = H[Now] ; i ; i = E[i].Next)</span><br><span class="line"><span class="keyword">if</span> (! Use[E[i].T])&#123;</span><br><span class="line">Use[E[i].T] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span>(! Girl[E[i].T] || Find(Girl[E[i].T]))&#123;</span><br><span class="line">Girl[E[i].T] = Now ;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    freopen(<span class="string">"ex.in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>) ;</span><br><span class="line">    freopen(<span class="string">"ex2.out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>) ;</span><br><span class="line">    N = Read() ; K = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> A = Read(), B = Read() ;</span><br><span class="line">        Add(A, i) ; Add(B, i) ;</span><br><span class="line">        <span class="keyword">if</span> (A != B) F = <span class="number">0</span> ;</span><br><span class="line">        V[A] = <span class="number">1</span> ; V[B] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (F == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">            <span class="keyword">if</span> (V[i]) Sum[i] = Sum[i - <span class="number">1</span>] + <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">else</span> Sum[i] = Sum[i - <span class="number">1</span>] ;</span><br><span class="line">        Q = Read() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Q ; i ++) &#123;</span><br><span class="line">            <span class="keyword">int</span> L = Read(), R = Read() ;</span><br><span class="line">            <span class="keyword">if</span> (Sum[R] - Sum[L - <span class="number">1</span>] == R - L + <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Q = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Q ; i++) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(Girl, <span class="number">0</span>, <span class="keyword">sizeof</span> (Girl)) ;</span><br><span class="line">        <span class="keyword">int</span> L = Read(), R = Read(), Ans = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L ; i &lt;= R ; i ++) &#123;</span><br><span class="line">            <span class="built_in">memset</span>(Use, <span class="number">0</span>, <span class="keyword">sizeof</span> (Use)) ;</span><br><span class="line">    Ans += Find(i) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Ans == R - L + <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"No\n"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后我们考虑正解。</p><p>如果能想到图论模型，这个题就解了一半了。对于每个面值，由于在一个查询中它最多需要一次。所以我们可以把每个面值都当成是一个节点，对于一张牌，我们都建一条连接它正反两面两个面值的边。建好模型以后，我们不难发现，如果对于一个大小为N的连通块有至少N条边，那么这个连通块一定能满足保证每个面值都能够被提供至少一次。只有一种连通块特殊，也就是当连通块的大小为N，并且它具有N-1条边时，无论怎么调整，都会漏掉一个面值无法打出，大小为N，具有N-1条边的连通块，那也就是树。</p><p>所以我们先找树，dfs并查集啥玩意都ok，总之找出所有的树就可以了。</p><p>然后我们想这个问题的反面：什么样的顺子是不能满足的，我们发现，如果你的顺子完全包含了一颗树，那这个顺子就由于上述的原因无法构造。问题来了？如何判断一个顺子是否完全包含树？</p><p>先求出每一颗树上节点编号的最小值与最大值，构造一个约束线段，约束线段的左端点为树上节点编号的最小值，右端点为树上节点编号的最大值。</p><p>接下来问题转化成了线段覆盖问题：</p><p>即：给定查询线段l,r，问你查询线段是否至少完整的覆盖了任意一个约束线段。如果存在则输出No，反之输出Yes。</p><p>这个就是个经典问题了，按照线段的右端点排序然后离线树状数组。对于每一个约束线段都将它的左端点赋成1，然后查询，查询区间和是否为0即可。</p><p>当然你也可以使用桶排序或者链式前向星处理查询，然后离线扫描线for过去维护下界。这样做是近似O(n)复杂度的算法，因为第一步使用了并查集，所以全局复杂度不是O(n)，而是O(nlogn)，只不过并查集常数太小了所以一般近似O(n)。</p><p>$T3$以上正解来自<a href="https://ac.nowcoder.com/discuss/329332?type=101&amp;order=0&amp;pos=1&amp;page=1" target="_blank" rel="noopener">官方题解</a>。</p>]]></content>
    
    <summary type="html">
    
      Nowcoder CSP-J提高组s赛前集训营
    
    </summary>
    
      <category term="专题集训与赛事" scheme="http://Yeasion.github.io/categories/%E4%B8%93%E9%A2%98%E9%9B%86%E8%AE%AD%E4%B8%8E%E8%B5%9B%E4%BA%8B/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="图论" scheme="http://Yeasion.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="线段树" scheme="http://Yeasion.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="博弈论" scheme="http://Yeasion.github.io/tags/%E5%8D%9A%E5%BC%88%E8%AE%BA/"/>
    
      <category term="离线" scheme="http://Yeasion.github.io/tags/%E7%A6%BB%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>[UVA1608]Non-Boring Sequences</title>
    <link href="http://Yeasion.github.io/2019/10/29/UVA1608-Non-Boring%20Sequences/"/>
    <id>http://Yeasion.github.io/2019/10/29/UVA1608-Non-Boring Sequences/</id>
    <published>2019-10-29T04:00:00.000Z</published>
    <updated>2019-11-13T00:00:32.034Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://uva.onlinejudge.org/external/16/p1608.pdf" target="_blank" rel="noopener">Link</a><br>首先我们要能有一个算法进行预处理使我们能够快速的确定一个数在任意区间$[L, R]$内是否只出现了一次。<br>难么我们考虑预处理出这个数的前一个出现的位置和后一个出现的位置P和S，于是在判断的时候我们只需要判断(P &lt; L &amp;&amp; S &gt; R)就可以了。<br>那么如何处理出两个数组？<br>我们用另一个数组$Last[A[i]]$表示$A[i]$最后一次出现的位置，于是就有</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">R[Last[A[i]]] = i, </span><br><span class="line">L[i] = Last[A[i]], </span><br><span class="line">Last[A[i]] = i ;</span><br></pre></td></tr></table></figure><p>于是我们就可以在$O(1)$的时间复杂度内完成上面说的那项事情了。<br>接下来我们进行分治，每次寻找出该区间内的某一个之出现过一次的值，找到即往左右分治即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> T, N, A[MAXN], L[MAXN], R[MAXN] ;</span><br><span class="line"><span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; Last ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Judge</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> LL = X, RR = Y ;</span><br><span class="line">    <span class="keyword">if</span> (X &gt;= Y) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = X ; i &lt;= Y ; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (L[LL] &lt; X &amp;&amp; R[LL] &gt; Y)</span><br><span class="line">                <span class="keyword">return</span> Judge(X, LL - <span class="number">1</span>) &amp;&amp; Judge(LL + <span class="number">1</span>, Y) ;</span><br><span class="line">            LL ++ ;</span><br><span class="line">        &#125;   <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (L[RR] &lt; X &amp;&amp; R[RR] &gt; Y)</span><br><span class="line">                <span class="keyword">return</span> Judge(X, RR - <span class="number">1</span>) &amp;&amp; Judge(RR + <span class="number">1</span>, Y) ;</span><br><span class="line">            RR -- ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T = Read() ; <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">        N = Read() ;</span><br><span class="line">        Last.clear() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">            L[i] = - <span class="number">1</span>, R[i] = INF ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) A[i] = Read() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">            R[Last[A[i]]] = i, </span><br><span class="line">            L[i] = Last[A[i]], </span><br><span class="line">            Last[A[i]] = i ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">            R[Last[A[i]]] = N + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (Judge(<span class="number">1</span>, N))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"non-boring"</span>) ;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">"boring"</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      如果一个序列的任意连续子序列都至少有一个元素唯一，则称这个序列“不无聊”，否则称这个序列“无聊”。给定$T$个序列，求是否“无聊”。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="UVA" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/UVA/"/>
    
    
      <category term="分治" scheme="http://Yeasion.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>Contest Nowcoder1106 Holiday Team20</title>
    <link href="http://Yeasion.github.io/2019/10/28/Contest%20Nowcoder1106%20Holiday%20Team20/"/>
    <id>http://Yeasion.github.io/2019/10/28/Contest Nowcoder1106 Holiday Team20/</id>
    <published>2019-10-28T03:03:00.000Z</published>
    <updated>2019-11-11T11:52:43.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Soda-Machine"><a href="#Soda-Machine" class="headerlink" title="Soda Machine"></a>Soda Machine</h3><blockquote><p>求一个数列上的一个点最多被多少个区间覆盖。<br>非常简单的一道题，直接差分+离散化就可以了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, L[MAXN], R[MAXN], A[MAXN], Tot, Sum[MAXN], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span> ; <span class="keyword">bool</span> F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        L[i] = Read() ; R[i] = Read() + <span class="number">1</span> ;</span><br><span class="line">        A[++ Tot] = L[i], A[++ Tot] = R[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(A + <span class="number">1</span>, A + Tot + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        L[i] = lower_bound(A + <span class="number">1</span>, A + Tot + <span class="number">1</span>, L[i]) - A ;</span><br><span class="line">        R[i] = lower_bound(A + <span class="number">1</span>, A + Tot + <span class="number">1</span>, R[i]) - A ;</span><br><span class="line">        Sum[L[i]] ++ ; Sum[R[i]] -- ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Tot ; i ++)</span><br><span class="line">        Sum[i] = Sum[i] + Sum[i - <span class="number">1</span>],</span><br><span class="line">        Ans = max(Ans, Sum[i]) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="细胞分裂"><a href="#细胞分裂" class="headerlink" title="细胞分裂"></a>细胞分裂</h3><blockquote><p> 要求最小的正整数$K$使得存在$i$满足$S_i ^ {K} | M_1 ^ {M_2}$</p></blockquote><p>直接质因数分解。<br>要想满足条件，那么显然$S_i$必须包含$M_1$的所有的质因数。<br>于是先判断这个事情。如果可以继续，那么设$F[A][B]$表示$A$的质因数中的$B$的数量，$M_1$的质因子$i$的出现的次数为$B_i$<br>那么$\frac {M_2 \times B_j}{F[S][j]} \leq K$，那么根据$K$和时间的单调性关系，可以得到<br>$K = max(k, \lceil \frac {M_2 \times B_j}{F[S][j]} \rceil)$<br>直接上代码了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M1, M2, S[MAXN], P[MAXN], T = <span class="number">2</span>, Ans = INF, A ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span> ; <span class="keyword">bool</span> F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; M1 = Read() ; M2 = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) S[i] = Read() ;</span><br><span class="line">    <span class="keyword">if</span> (M1 == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"0"</span>) ;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (M1 != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!(M1 % T)) M1 /= T, P[T] ++ ;</span><br><span class="line">        A = max(A, T) ;</span><br><span class="line">        P[T ++] *= M2 ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> K = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span> ; j &lt;= A ; j ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! P[j]) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">int</span> C = <span class="number">0</span> ;</span><br><span class="line">            <span class="keyword">while</span> (! (S[i] % j))</span><br><span class="line">                S[i] /= j, C ++ ;</span><br><span class="line">            <span class="keyword">if</span> (! C) &#123;</span><br><span class="line">                K = INF ;</span><br><span class="line">                <span class="keyword">break</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            K = max(K, (P[j] - <span class="number">1</span>) / C) ;</span><br><span class="line">        &#125;</span><br><span class="line">        Ans = min(Ans, K) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Ans == INF) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Making-Money"><a href="#Making-Money" class="headerlink" title="Making Money"></a>Making Money</h3><blockquote><p>FJ又经营起了古董生意，买卖一些像奶牛圣诞树上的装饰之类的小玩意。他知道他会将他能存储的N(1&lt;=N&lt;=100)件不同的奶牛古董每件都卖出。<br>而且如果他的钱足够多他可以买他想要的任意数量的古董（即他可以购买的古董数量没有限制）。他只有M(1&lt;=M&lt;=100,000)元钱来买古董，但他想要在他经商的第一年年末最大化他的利润（这有点难以解释）。<br>第i种古董采购需要花费Ci(1&lt;=Ci&lt;=100,000)元钱，每卖掉一件可以获得Ri(1&lt;=Ri&lt;=100,000)元钱(每卖一件的利润为Ri-Ci)。FJ可以以任意顺序卖出他的货物。他并不需要花光他所有的钱来购买古董。<br>FJ在他经商的第一年年末能得到的最大总利润（利润=初始钱数-总花费+总收入）是多少呢？输入数据保证这个数字不会超过1,000,000,000.<br>假设FJ只有3种古董而且开始时有M=17元钱。下面是三种古董的花费和收入。</p></blockquote><p>完全背包直接上就是了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, W[MAXN], V[MAXN], Dp[MAXN], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span> ; <span class="keyword">bool</span> F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; M = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        W[i] = Read(), V[i] = Read() ;</span><br><span class="line">        V[i] -= W[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = W[i] ; j &lt;= M ; j ++)</span><br><span class="line">        Dp[j] = max(Dp[j], Dp[j - W[i]] + V[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++)</span><br><span class="line">        Ans = max(Ans, Dp[i] - i + M) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="道路游戏"><a href="#道路游戏" class="headerlink" title="道路游戏"></a>道路游戏</h3><blockquote><p> 链接：<a href="https://ac.nowcoder.com/acm/contest/1106/D" target="_blank" rel="noopener">https://ac.nowcoder.com/acm/contest/1106/D</a><br>来源：牛客网</p><p>小新正在玩一个简单的电脑游戏。<br> 游戏中有一条环形马路，马路上有n个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这n  个机器人工厂编号为1~n，因为马路是环形的，所以第n个机器人工厂和第1 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这n段马路也编号为1~n，并规定第i段马路连接第i个机器人工厂和第i+1个机器人工厂（1≤i≤n-1），第n 段马路连接第n个机器人工厂和第1个机器人工厂。<br> 游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在i（1≤i≤ n）号机器人工厂购买了一个机器人，这个机器人会从i 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过i  号马路，到达i+1号机器人工厂（如果i=n，机器人会到达第1个机器人工厂），并将i号马路上的所有金币收集给小新。  游戏中，环形马路上不能同时存在2个或者2个以上的机器人，并且每个机器人最多能够在环形马路上行走p次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为1~p之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。<br> 以下是游戏的一些补充说明：<br> \1. 游戏从小新第一次购买机器人开始计时。<br> \2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。<br> \3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。<br> \4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。<br> \5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。<br> 现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过m 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。 </p></blockquote><p>这道题是真的难。优先队列优化动态规划。</p><p>状态表示就比较难想，你在真正比赛的时候不一定敢信这是一个一维的。设$Dp[i]$表示在时间$i$的时候的最优答案。</p><p>那么我们利用一下二维前缀和就大概可以写出来$Dp$的式子。</p><script type="math/tex; mode=display">Dp[i] = max(Dp[i], Dp[i - k] + Sum[i][j] - Sum[i - k][j - k] - Cost[j - k])</script><p>然后这个$Sum$表示的是时间和工厂这两维的前缀和。上面这相当于是一个$O(N^3)$的暴力$DP$，但是我们可以用优先队列进行优化。</p><p>首先把没有$k$的一项提出来，就变成：</p><script type="math/tex; mode=display">Dp[i] = max(Dp[i - k] - Sum[i - k][j - k] - Cost[j - k]) + Sum[i][j]</script><p>于是你就发现$max$里面全部都是$i - k,j - k$，因此你可以预处理一下一个$Rec[i][j]$表示$Dp[i] - Sum[i][j] - Cost[j]$，那么$Dp$方程就变成了</p><script type="math/tex; mode=display">Dp[i] = max(Rec[i][j]) + Sum[i][j]</script><p>那么如果我们能够简化对于$Rec[i][j]$的枚举，就可以做到$O(N^2)$，这就非常优秀，那么显然这个时候就可以使用优先队列来进行优化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, P, Cost[MAXN], Rec[MAXN][MAXN], Pre[MAXN][MAXN], T ;</span><br><span class="line"><span class="keyword">int</span> Money[MAXN][MAXM], Dp[MAXN], Ans = - INF, Sum[MAXN][MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> Data, Step ;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Node A) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Data &lt; A.Data ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; ;</span><br><span class="line"></span><br><span class="line">priority_queue &lt;Node&gt; Q[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Update</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> Id)</span> </span>&#123;</span><br><span class="line">Node X = Q[S].top() ;</span><br><span class="line"><span class="keyword">while</span> (Id - X.Step &gt;= P)</span><br><span class="line">Q[S].pop(), X = Q[S].top() ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; M = Read() ; P = Read() ;</span><br><span class="line"><span class="built_in">memset</span>(Dp, - <span class="number">127</span>, <span class="keyword">sizeof</span> (Dp)) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">Money[i % N][j] = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;  N ; i ++)</span><br><span class="line">Cost[i] = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;  N ; j ++)</span><br><span class="line">Sum[i][j] = Sum[i - <span class="number">1</span>][(j - <span class="number">1</span> + N) % N] + Money[j][i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;  N ; i ++)</span><br><span class="line">Pre[<span class="number">0</span>][(i - <span class="number">1</span> + N) % N] = i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;  N ; i ++) &#123;</span><br><span class="line">Rec[<span class="number">0</span>][i] = - Cost[i] ;</span><br><span class="line">Node X = &#123;- Cost[i], <span class="number">0</span>&#125; ;</span><br><span class="line">Q[Pre[<span class="number">0</span>][i]].push(X) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">T = - INF ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;  N ; j ++)</span><br><span class="line">Dp[i] = max(Dp[i], Rec[i - <span class="number">1</span>][(j - <span class="number">1</span> + N) % N] + Sum[i][j]),</span><br><span class="line">Ans = max(Ans, Dp[i]), T = max(T, Dp[i]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;  N ; j ++) &#123;</span><br><span class="line">Pre[i][j] = Pre[i - <span class="number">1</span>][(j - <span class="number">1</span> + N) % N] ;</span><br><span class="line">Node X = &#123;T - Sum[i][j] - Cost[j], i&#125; ;</span><br><span class="line">Q[Pre[i][j]].push(X) ;</span><br><span class="line">Update(Pre[i][j], i) ;</span><br><span class="line">Rec[i][j] = Q[Pre[i][j]].top().Data ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lake-Counting"><a href="#Lake-Counting" class="headerlink" title="Lake Counting"></a>Lake Counting</h3><blockquote><p>一个八联通的$N \times M$的方格图，$W$代表水池，$.$代表空地，常识确定一共有多少个水坑。</p></blockquote><p>直接搜索。（这都是些什么垃圾题啊。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS (Now &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS ((Now &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_Mid ((E[Now].L + E[Now].R) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">110</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">110</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, Ans ; <span class="keyword">char</span> Map[MAXN][MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Dx[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, - <span class="number">1</span>, <span class="number">1</span>, - <span class="number">1</span>, <span class="number">1</span>, - <span class="number">1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> Dy[<span class="number">9</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, - <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, - <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, - <span class="number">1</span>&#125; ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span> ; <span class="keyword">bool</span> F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dfs</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y)</span> </span>&#123;</span><br><span class="line">    Map[X][Y] = <span class="string">'.'</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">8</span> ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> Vx = X + Dx[i], Vy = Y + Dy[i] ;</span><br><span class="line">        <span class="keyword">if</span> (Vx &gt;= <span class="number">1</span> &amp;&amp; Vx &lt;= N &amp;&amp; Vy &gt;= <span class="number">1</span> &amp;&amp; Vy &lt;= M)</span><br><span class="line">        <span class="keyword">if</span> (Map[Vx][Vy] == <span class="string">'W'</span>)</span><br><span class="line">            Dfs(Vx, Vy) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; M = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Map[i][j] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= M ; j ++)</span><br><span class="line">        <span class="keyword">if</span> (Map[i][j] == <span class="string">'W'</span>)</span><br><span class="line">            Dfs(i, j), Ans ++ ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多项式输出"><a href="#多项式输出" class="headerlink" title="多项式输出"></a>多项式输出</h3><p>一元nn次多项式可用如下的表达式表示：</p><script type="math/tex; mode=display">F(x) = A_NX^N + A_{N - 1} X ^ {N - 1} + ... + A_1X + A_0</script><p>输入系数，输出这个式子。</p><p>哈，模拟好题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, A ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span> ; <span class="keyword">bool</span> F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">0</span> ; i --) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp; A) ;</span><br><span class="line">        <span class="keyword">if</span> (A) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != N &amp;&amp; A &gt; <span class="number">0</span>) </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"+"</span> ;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(A) &gt; <span class="number">1</span> || i == <span class="number">0</span>) </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; A ;</span><br><span class="line">            <span class="keyword">if</span> (A == <span class="number">-1</span> &amp;&amp; i) </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span> ;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>) </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"x^"</span> &lt;&lt; i ;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) </span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"x"</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Dinner-Time"><a href="#Dinner-Time" class="headerlink" title="Dinner Time"></a>Dinner Time</h3><blockquote><p>农民约翰的$N（1≤N≤1000）$奶牛(编号1..N)在保加利亚参加$IOI$。奶牛们喜欢保加利亚的太阳，并享受他们的假期。一切</p><p>似乎都很好。</p><p>这在晚餐时间发生了变化。餐厅很小，只有$M（1 &lt;= M = N）$个牛的座位（编号1 .. M）.每头奶牛开始在一个位置</p><p>$cx_i，cy_i（1000000 &lt;= cx_i≤1000000；1000000≤cy_i &lt;= 1000000）$；可以在$sx_j，sy_j$</p><p>$（1000000 &lt; = sx_j≤1000000；1000000≤sy_j &lt; = 1000000）$找到座位。</p><p>奶牛有一个非常有效的（虽然很原始）的方法来分配座位。只要一头母牛可以确定她会先坐到座位上，她会尽快地</p><p>赶到那里（所有的母牛都跑得一样快）。</p><p>农民约翰的奶牛跳过座位、桌子、其他的牛不成问题，所以他们可以在一条直线上跑。当多</p><p>个奶牛可以在同一时间达到一个座位，最老的牛（在输入数据中出现得早）将会得到座位。同样，当一头母牛可</p><p>以到达多个座位时，她也会选择最早在输入数据中出现的一个。</p><p>有些牛不能吃晚饭（没有座位），那些饥饿的奶牛集体计划偷农民约翰的食物。农夫约翰想要一个他应</p><p>该警惕的牛的名单。（在没有饥饿的奶牛的情况下，输出0）。你能帮他吗？</p></blockquote><p>语文好题。</p><p>直接枚举座位和牛，然后就直接让最近的牛做到这个座位上就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">5810925546507845</span> ;</span><br><span class="line">LL N, M, Range[MAXN], F = <span class="number">0</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MAP</span> &#123;</span></span><br><span class="line">LL X, Y ;</span><br><span class="line">&#125;C[MAXN], S[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">D</span><span class="params">(LL X1, LL Y1, LL X2, LL Y2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sqrt</span>((X1 - X2) * (X1 - X2) + (Y1 - Y2) * (Y1 - Y2)) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">C[i].X = Read(), C[i].Y = Read() ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= M ; i ++)</span><br><span class="line">S[i].X = Read(), S[i].Y = Read() ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">LL Min = INF, Now ; </span><br><span class="line"><span class="keyword">for</span> (LL j = <span class="number">1</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! Range[j]) &#123;</span><br><span class="line">LL Dist = D(S[i].X, S[i].Y, C[j].X, C[j].Y) ;</span><br><span class="line"><span class="keyword">if</span> (Dist &lt; Min) Min = Dist, Now = j ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Range[Now] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (! Range[i])</span><br><span class="line">F = <span class="number">1</span>, <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, i) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! F) <span class="built_in">printf</span>(<span class="string">"0"</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Counting-Beads"><a href="#Counting-Beads" class="headerlink" title="Counting Beads"></a>Counting Beads</h3><blockquote><p>给你一个序列，让你求出有多少个$A[j], A[i + 1]$满足01相间</p></blockquote><p>我透了这真是连普及都不到啊。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> Data[<span class="number">100</span>], Ans ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N ; <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Data[i] ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (Data[i] != Data[i - <span class="number">1</span>]) Ans ++ ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Barn-Allocation"><a href="#Barn-Allocation" class="headerlink" title="Barn Allocation"></a>Barn Allocation</h3><blockquote><p>大概就是给你一个序列和一堆序列，然后让你选择一些序列保证任意序列不相重，最大化序列数。</p></blockquote><p>这个题也算是比较经典的贪心了，直接排序右端点，然后从左往右能选就选就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1000010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, M, S[MAXN], T, Sum[MAXN], Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>)</span><br><span class="line">        F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">        X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair &lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; A[MAXN] ;</span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; M = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        S[i] = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++)</span><br><span class="line">        A[i].first = Read(), A[i].second = Read() ;</span><br><span class="line">    sort(A + <span class="number">1</span>, A + M + <span class="number">1</span>) ; A[M + <span class="number">1</span>].first = N + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (A[T + <span class="number">1</span>].first &lt;= i)</span><br><span class="line">            Q.push(A[++ T].second), Sum[A[T].second] ++ ;</span><br><span class="line">        <span class="keyword">while</span> (Q.size() &gt; S[i] + Ans)</span><br><span class="line">            Sum[Q.top()] --, Q.pop() ;</span><br><span class="line">        Ans += Sum[i] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      注：因为是团队赛，所以题并不都是自己写的。（本次是）
    
    </summary>
    
      <category term="专题集训与赛事" scheme="http://Yeasion.github.io/categories/%E4%B8%93%E9%A2%98%E9%9B%86%E8%AE%AD%E4%B8%8E%E8%B5%9B%E4%BA%8B/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心" scheme="http://Yeasion.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="模拟" scheme="http://Yeasion.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="搜索" scheme="http://Yeasion.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
      <category term="分数规划" scheme="http://Yeasion.github.io/tags/%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92/"/>
    
      <category term="离散化 - 数论" scheme="http://Yeasion.github.io/tags/%E7%A6%BB%E6%95%A3%E5%8C%96-%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Contest Nowcoder1126 Holiday Team19</title>
    <link href="http://Yeasion.github.io/2019/10/21/Contest%20Nowcoder1126%20Holiday%20Team19/"/>
    <id>http://Yeasion.github.io/2019/10/21/Contest Nowcoder1126 Holiday Team19/</id>
    <published>2019-10-21T15:55:00.000Z</published>
    <updated>2019-11-11T11:52:55.385Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/1126#question" target="_blank" rel="noopener">Link</a></p><h3 id="A-Visiting-Cows"><a href="#A-Visiting-Cows" class="headerlink" title="[A]Visiting Cows"></a>[A]Visiting Cows</h3><blockquote><p> After many weeks of hard work, Bessie is finally getting a vacation! After many weeks of hard work, Bessie is finally getting a vacation! numbered 1..N. The cows have set up quite an unusual road network with exactly N-1 roads connecting pairs of cows C1 and C2 (1 &lt;= C1 &lt;= N; 1 &lt;= C2 &lt;= N; C1 != C2) in such a way that there exists a unique path of roads between any two cows.<br> FJ wants Bessie to come back to the farm soon; thus, he has instructed Bessie that if two cows are directly connected by a road, she may not visit them both. Of course, Bessie would like her vacation to be as long as possible, so she would like to determine the maximum number of cows she can visit. </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qwq</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">&#125; e[<span class="number">2</span>*MAXN];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    e[++cnt].to=y;</span><br><span class="line">    e[cnt].nxt=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> dp[MAXN][<span class="number">3</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xuan_max=<span class="number">0</span>,bu_max=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x]; i; i=e[i].nxt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].to==fa)</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(e[i].to,x);</span><br><span class="line">        xuan_max+=dp[e[i].to][<span class="number">0</span>];</span><br><span class="line">        bu_max+=max(dp[e[i].to][<span class="number">0</span>],dp[e[i].to][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[x][<span class="number">0</span>]=bu_max;</span><br><span class="line">    dp[x][<span class="number">1</span>]=xuan_max+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;max(dp[<span class="number">1</span>][<span class="number">0</span>],dp[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="B-传球游戏"><a href="#B-传球游戏" class="headerlink" title="[B]传球游戏"></a>[B]传球游戏</h3><blockquote><p>上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。<br> 游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。<br> 聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。 </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 50</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,dp[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">dp[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=m;k++)&#123;</span><br><span class="line">dp[<span class="number">1</span>][k]=dp[<span class="number">2</span>][k<span class="number">-1</span>]+dp[n][k<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)</span><br><span class="line">dp[i][k]=dp[i<span class="number">-1</span>][k<span class="number">-1</span>]+dp[i+<span class="number">1</span>][k<span class="number">-1</span>];</span><br><span class="line">dp[n][k]=dp[n<span class="number">-1</span>][k<span class="number">-1</span>]+dp[<span class="number">1</span>][k<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,dp[<span class="number">1</span>][m]); <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C-Cow-Photographs"><a href="#C-Cow-Photographs" class="headerlink" title="[C]Cow Photographs"></a>[C]Cow Photographs</h3><blockquote><p> Farmer John wants to take a picture of his entire herd of N (1 &lt;= N &lt;= 100,000) cows conveniently numbered 1..N so he can show off to his friends.<br> On picture day, the cows run to form a single line in some arbitrary order with position i containing cow cic_ici​ (1 &lt;= cic_ici​ &lt;= N). Farmer John has his own ideas about how the cows should line up.<br> FJ thinks cow i may stand only to the left of cow i+1 (for all i, 1 &lt;= i &lt;= N-1) and that cow N may only stand to the left of Cow 1. Of course, no cow will stand to the left of the first (leftmost) cow in the line.<br> The cows are hungry for the promised post-photo dinner, so Farmer John wants to take the picture as quickly as possible. Cows are not great at following directions, so he will only choose a pair of adjacent cows and have them switch places once per minute. How quickly is Farmer John able to get them into some acceptable order? </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,a[MAXN],pos[MAXN],cnt,ans;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> tree[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;x;x-=lowbit(x))</span><br><span class="line">        ans+=tree[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;x&lt;=n;x+=lowbit(x))</span><br><span class="line">        tree[x]+=d;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;a[i]);</span><br><span class="line">        pos[a[i]]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cnt+=i<span class="number">-1</span>-query(a[i]);</span><br><span class="line">        update(a[i],<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ans=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        cnt+=n-pos[i]-pos[i]+<span class="number">1</span>;</span><br><span class="line">        ans=min(ans,cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="D-Chocolate-Milk"><a href="#D-Chocolate-Milk" class="headerlink" title="[D]Chocolate Milk"></a>[D]Chocolate Milk</h3><blockquote><p>Farmer John’s milk production and shipping system is an intricate one! He uses milking machines for his many cows to harvest the milk that then flows into pipes.<br> Each of these pipes connects a milking machine to a joint, where it might be joined by exactly one more pipe (the milk flowing through both pipes merges). The milk then flows through additional pipes (which all start and end at joints) until it reaches the long central pipe connecting to the distribution room.<br> The milk then goes through a reverse process of splitting at various joints until it is flows into milk tanks that are picked up and taken to market.<br> Farmer John notices that there is at most one way for milk to travel from one joint to any other joint. Furthermore, since Farmer John is an efficient man by nature, he has made sure that milk will flow through each and every pipe; in other words, no pipe is unneeded.<br> If we think of a milking machine, joint, or milk tank as a node, there are N (2 &lt;= N &lt;= 100,000) nodes in total (and N-1 pipes connecting them). The input describes each pipe as an ordered pair of nodes, AiA_iAi​ (1 &lt;= AiA_iAi​ &lt;= N) and BiB_iBi​ (1 &lt;= BiB_iBi​ &lt;= N; Ai&lt;BiA_i &lt; B_iAi​&lt;Bi​) indicating milk flows from node AiA_iAi​ to node BiB_iBi​. If there is no pipe coming in to AiA_iAi​, it is a milking machine. Likewise, if no pipe goes out from BiB_iBi​, it is a tank.<br> The demand of chocolate milk has skyrocketed in recent months, and Farmer John wants to install a chocolate inserter at one of the joints so he can create delicious chocolate milk for customers.<br> Being thrifty, Farmer John has only bought one chocolate inserter, so he wants to place it at a joint through which all the milk passes. He knows that such a joint exists.<br> Help Farmer John find all the possible places he can install the chocolate inserter. (Note that Farmer John cannot install the chocolate inserter at the same location as a milking machine.) </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100010</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM=<span class="number">400010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> Head[MAXN],num,du[MAXN],cnt1,f1[MAXN];</span><br><span class="line"><span class="keyword">int</span> _Head[MAXN],_num,_du[MAXN],cnt2,f2[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,nxt;</span><br><span class="line">&#125;e[MAXN],_e[MAXN];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++num].to=y;</span><br><span class="line">    e[num].nxt=Head[x];</span><br><span class="line">    Head[x]=num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _add(<span class="keyword">int</span> x,<span class="keyword">int</span> y)&#123;</span><br><span class="line">    _e[++_num].to=y;</span><br><span class="line">    _e[_num].nxt=_Head[x];</span><br><span class="line">    _Head[x]=_num;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f1[x]) <span class="keyword">return</span> f1[x];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(du[x]==<span class="number">0</span>) ++sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=Head[x];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=e[i].to;</span><br><span class="line">        sum+=dfs1(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f1[x]=sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f2[x]) <span class="keyword">return</span> f2[x];</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(_du[x]==<span class="number">0</span>) ++sum;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=_Head[x];i;i=_e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">int</span> to=_e[i].to;</span><br><span class="line">        sum+=dfs2(to);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2[x]=sum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;++i)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        add(x,y); ++du[x];</span><br><span class="line">        _add(y,x); ++_du[y];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(du[i]==<span class="number">0</span>) ++cnt1;</span><br><span class="line">        <span class="keyword">if</span>(_du[i]==<span class="number">0</span>) ++cnt2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!f1[i]) dfs1(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(!f2[i]) dfs2(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(_du[i]!=<span class="number">0</span>&amp;&amp;f1[i]==cnt1&amp;&amp;f2[i]==cnt2)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="E-Math-Practice"><a href="#E-Math-Practice" class="headerlink" title="[E]Math Practice"></a>[E]Math Practice</h3><blockquote><p>One lovely afternoon, Bessie’s friend Heidi was helping Bessie review for her upcoming math exam.<br> Heidi presents two integers A (0 &lt;= A &lt;= 45) and B (1 &lt;= B &lt;= 9) to Bessie who must respond with an integer E in the range 1..62. E is the smallest integer in that range that is strictly greater than A and also has B as the first digit of 2 raised to the E-th power. If there is no answer, Bessie responds with 0.<br> Help Bessie correctly answer all of Heidi’s questions by calculating her responses.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> E[<span class="number">64</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=read(),b=read();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a+<span class="number">1</span>;i&lt;=<span class="number">62</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(b==E[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="F-立体图"><a href="#F-立体图" class="headerlink" title="[F]立体图"></a>[F]立体图</h3><blockquote><p>小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。<br> 小渊有一块面积为m<em>n的矩形区域，上面有m</em>n个边长为1的格子，每个格子上堆了一些同样大小的吉姆（积木的长宽高都是1），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放： </p><p> <img src="https://uploadfiles.nowcoder.com/images/20180613/305281_1528886337112_F2918F36AC9E57AFEEB45A6795161B02" alt="img">  </p><p>  每个顶点用1个加号’+’表示，长用3个”-“表示，宽用1个”/”表示，高用两个”|”表示。字符’+’，‘-‘，’/’，‘|’的ASCII码分别为43，45，47，124。字符’.’（ASCII码46）需要作为背景输出，即立体图里的空白部分需要用’.’代替。立体图的画法如下面的规则：</p><p>  若两块积木左右相邻    若两块积木上下相邻    若两块积木前后相邻</p><p>   <img src="https://uploadfiles.nowcoder.com/images/20180613/305281_1528886511239_276D4B20C614C3CD7764BDAF632F5AD8" alt="img"> <img src="https://uploadfiles.nowcoder.com/images/20180613/305281_1528886537675_CDB4197053583A66449E58D04A7177D0" alt="img"> <img src="https://uploadfiles.nowcoder.com/images/20180613/305281_1528886565714_88F5BA4B8C94E50E474C24232E224C78" alt="img">   </p><p>  立体图中，定义位于第(m,1)的格子（即第m行第1列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">51</span>;</span><br><span class="line"><span class="keyword">int</span> data[maxn][maxn];</span><br><span class="line"><span class="keyword">char</span> m[maxn*<span class="number">5</span>][maxn*<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> f[maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> L=<span class="number">0</span>,W=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)</span><br><span class="line">        m[x][y+i]=<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=L;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">            <span class="built_in">putchar</span>(m[i][j]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printf("------------------------\n");</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">3</span>;i++)   clear(x+i,y,<span class="number">5</span>);</span><br><span class="line">    clear(x+<span class="number">4</span>,y+<span class="number">1</span>,<span class="number">5</span>);clear(x+<span class="number">5</span>,y+<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line">    m[x+<span class="number">2</span>][y+<span class="number">5</span>]=m[x+<span class="number">3</span>][y+<span class="number">5</span>]=<span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">        m[x][y+i]=m[x+<span class="number">3</span>][y+i]=m[x+<span class="number">5</span>][y+<span class="number">2</span>+i]=<span class="string">'-'</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>;i++)</span><br><span class="line">        m[x+i][y]=m[x+i][y+<span class="number">4</span>]=m[x+i+<span class="number">2</span>][y+<span class="number">6</span>]=<span class="string">'|'</span>;</span><br><span class="line">    m[x+<span class="number">4</span>][y+<span class="number">1</span>]=m[x+<span class="number">4</span>][y+<span class="number">5</span>]=m[x+<span class="number">1</span>][y+<span class="number">5</span>]=<span class="string">'/'</span>;</span><br><span class="line">    m[x][y]=m[x+<span class="number">3</span>][y]=m[x+<span class="number">5</span>][y+<span class="number">2</span>]=m[x+<span class="number">5</span>][y+<span class="number">6</span>]=m[x+<span class="number">3</span>][y+<span class="number">4</span>]=m[x+<span class="number">2</span>][y+<span class="number">6</span>]=m[x][y+<span class="number">4</span>]=<span class="string">'+'</span>;</span><br><span class="line">    W=max(W,y+<span class="number">6</span>);</span><br><span class="line">    L=max(L,x+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;maxn*<span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;maxn*<span class="number">5</span>;j++)</span><br><span class="line">            m[i][j]=<span class="string">'.'</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;f[i][j]);</span><br><span class="line">    <span class="keyword">bool</span> F=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(F)</span><br><span class="line">    &#123;</span><br><span class="line">        F=<span class="literal">false</span>;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)</span><br><span class="line">                <span class="keyword">if</span>(f[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> x=<span class="number">3</span>*cnt<span class="number">-4</span>+i*<span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">int</span> y=<span class="number">4</span>*j<span class="number">-5</span>+i*<span class="number">2</span>;</span><br><span class="line">                    f[i][j]--;</span><br><span class="line">                    <span class="keyword">if</span>(f[i][j]) F=<span class="literal">true</span>;</span><br><span class="line">                    insert(x,y);</span><br><span class="line">                    <span class="comment">//out();</span></span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    out();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="G-Candy"><a href="#G-Candy" class="headerlink" title="[G]Candy"></a>[G]Candy</h3><blockquote><p>Farmer John knows that Bessie loves to eat candy. FJ has N (1 &lt;= N &lt;= 40,000) candies that he wants to give Bessie over some number of days. Each day, Farmer John gives Bessie a choice of how many candies she chooses to eat that day by choosing the number from a master list FJ supplies that has Nopt (1 &lt;= Nopt &lt;= 50) different options, CiC_iCi (1 &lt;= CiC_iCi &lt;= N). She must take exactly CiC_iCi candies, no more, no less.<br> Farmer John has also disclosed F (1 &lt;= F &lt;= 50) of his favorite numbers, FNiFN_iFNi​ (1 &lt;= FNiFN_iFNi​ &lt;= N). Whenever the number of candies remaining at the end of the day precisely matches one of these favorite numbers, Bessie has the option to have him add exactly M (1 &lt;= M &lt;= 100) more candies to the candy supply. Bessie might get another option to add M candies several times if adding candies creates another favorite number. In the best circumstances, Bessie can obtain an infinite amount of candy!<br> When Bessie cannot choose some amount of candy to take (because there is not enough), and the number of candies remaining is not any of FJ’s favorite numbers, she cannot have any more candy.<br> Unfortunately, Bessie cannot think ahead as far as she’d like to, so she needs your help in order to eat as many candies as possible. </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::max;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">queue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">101000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ind[maxn],like[maxn];</span><br><span class="line"><span class="keyword">int</span> ate[maxn],f[maxn];</span><br><span class="line"><span class="keyword">int</span> g[maxn];</span><br><span class="line"><span class="keyword">int</span> n,nopt,fn,m;</span><br><span class="line"><span class="keyword">int</span> vis[maxn],instk[maxn];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">read</span>(<span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> c=getchar(); val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c=getchar();</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c))</span><br><span class="line">    &#123;</span><br><span class="line">        val=(val&lt;&lt;<span class="number">3</span>)+(val&lt;&lt;<span class="number">1</span>)+c-<span class="string">'0'</span>;</span><br><span class="line">        c=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[now]=instk[now]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nopt;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        nxt=now-ate[i];</span><br><span class="line">        <span class="keyword">if</span>(nxt&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(instk[nxt])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++ind[nxt];</span><br><span class="line">            <span class="keyword">if</span>(!vis[nxt]) dfs(nxt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(like[now]&amp;&amp;now!=n)</span><br><span class="line">    &#123;</span><br><span class="line">        nxt=now+m;</span><br><span class="line">        <span class="keyword">if</span>(instk[nxt])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++ind[nxt];</span><br><span class="line">            <span class="keyword">if</span>(!vis[nxt]) dfs(nxt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    instk[now]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// freopen("data.in","r",stdin);</span></span><br><span class="line">    read(n),read(nopt),read(fn),read(m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nopt;++i) read(ate[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=fn;++i) read(f[i]),like[f[i]]=<span class="number">1</span>;</span><br><span class="line">    dfs(n);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * for(int i=0;i&lt;=n+m;++i) if(vis[i])</span></span><br><span class="line"><span class="comment">     *     for(int j=1;j&lt;=nopt;++j) if(i-ate[j]&gt;=0&amp;&amp;vis[i-ate[j]])</span></span><br><span class="line"><span class="comment">     *         ++ind[i-ate[j]];</span></span><br><span class="line"><span class="comment">     * for(int i=1;i&lt;=fn;++i) if(vis[f[i]]&amp;&amp;vis[f[i]+m]&amp;&amp;f[i]!=n)</span></span><br><span class="line"><span class="comment">     *     ++ind[f[i]+m];</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    q.push(n); ind[n]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pas,nxt;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        pas=q.front(); q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nopt;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            nxt=pas-ate[i];</span><br><span class="line">            <span class="keyword">if</span>(nxt&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            g[nxt]=max(g[nxt],g[pas]+ate[i]);</span><br><span class="line">            --ind[nxt];</span><br><span class="line">            <span class="keyword">if</span>(!ind[nxt]) q.push(nxt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(like[pas]&amp;&amp;pas!=n)</span><br><span class="line">        &#123;</span><br><span class="line">            nxt=pas+m;</span><br><span class="line">            g[nxt]=max(g[nxt],g[pas]);</span><br><span class="line">            --ind[nxt];</span><br><span class="line">            <span class="keyword">if</span>(!ind[nxt]) q.push(nxt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+m;++i) ans=max(ans,g[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="H-Banner"><a href="#H-Banner" class="headerlink" title="[H]Banner"></a>[H]Banner</h3><blockquote><p>Bessie is returning from a long trip abroad, and Farmer John wants to erect a nice ‘Welcome Home’ banner in her pasture for her arrival. The banner will hang between two poles on a wire whose length is in the range L1..L2 (1 &lt;= L1 &lt;= L2; L1 &lt;= L2 &lt;= 1,500).<br> The pasture’s size is W x H (1 &lt;= W &lt;= 1,000; 1 &lt;= H &lt;= 1,000), and Farmer John has installed a post at every point with integer<br> coordinates. Of these (W + 1) * (H + 1) points, Farmer John must pick just two that will hold either end of the wire from which he will hang the banner.<br> FJ wants no interference with his banner as it hangs and requires that no post be directly under the tight wire he stretches between the two chosen posts.<br> Farmer John needs your help to figure out how many possible ways he can hang the banner. He knows the number is large and that a 32-bit integer might not be sufficient to compute the answer. </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> L1,L2,W,H,ans;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld%lld"</span>,&amp;W,&amp;H,&amp;L1,&amp;L2);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=W;++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=H;++j)&#123;</span><br><span class="line">            <span class="keyword">double</span> len=<span class="built_in">sqrt</span>(i*i+j*j);</span><br><span class="line">            <span class="keyword">if</span>(gcd(i,j)==<span class="number">1</span>&amp;&amp;L1&lt;=len&amp;&amp;len&lt;=L2)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>||j==<span class="number">0</span>) ans+=(W-i+<span class="number">1</span>)*(H-j+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> ans+=(W-i+<span class="number">1</span>)*(H-j+<span class="number">1</span>)*<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="I-Race-Results"><a href="#I-Race-Results" class="headerlink" title="[I]Race Results"></a>[I]Race Results</h3><blockquote><p>The herd has run its first marathon!  The N (1 &lt;= N &lt;= 5,000) times have been posted in the form of Hours (0 &lt;= Hours &lt;= 99), Minutes (0 &lt;= Minutes &lt;= 59), and Seconds (0 &lt;= Seconds &lt;= 59). Bessie must sort them (by Hours, Minutes, and Seconds) into ascending order, smallest times first. </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TIME</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> X, Y, Z ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CMP</span><span class="params">(TIME A, TIME B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (A.X == B.X) &#123;</span><br><span class="line"><span class="keyword">if</span> (A.Y == B.Y)</span><br><span class="line"><span class="keyword">return</span> A.Z &lt; B.Z ;</span><br><span class="line"><span class="keyword">return</span> A.Y &lt; B.Y ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> A.X &lt; B.X ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =  <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">E[i].X = Read() ;</span><br><span class="line">E[i].Y = Read() ; </span><br><span class="line">E[i].Z = Read() ;</span><br><span class="line">&#125;</span><br><span class="line">sort(E + <span class="number">1</span>, E + N + <span class="number">1</span>, CMP) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, E[i].X , E[i].Y , E[i].Z) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="J-Buying-Feed"><a href="#J-Buying-Feed" class="headerlink" title="[J]Buying Feed"></a>[J]Buying Feed</h3><blockquote><p> Farmer John needs to travel to town to pick up K (1 &lt;= K &lt;= 10,000) pounds of feed. Driving a mile with K pounds of feed costs FJ K<em>K cents; driving D miles with K pounds of feed in his truck costs FJ D</em>K*K cents.<br> FJ can purchase feed from any of N (1 &lt;= N &lt;= 500) stores (conveniently numbered 1..N) that sell feed. Each store is located on a segment of the X axis whose length is E (1 &lt;= E &lt;= 500) miles. Store i is at location XiX_iXi​ (0 &lt; XiX_iXi​ &lt; E) on the number line and can sell FJ as much as FiF_iFi​ (1 &lt;= FiF_iFi​ &lt;= 10,000) pounds of feed at a cost of CiC_iCi​ (1 &lt;= CiC_iCi​ &lt;= 10,000,000) cents per pound. Surprisingly, a given point on the X axis might have more than one store.<br> FJ starts driving at location 0 on this number line and can drive only in the positive direction, ultimately arriving at location E with at least K pounds of feed. He can stop at any of the feed stores along the way and buy any amount of feed up to the the store’s limit.<br> What is the minimum amount FJ must pay to buy and transport the K pounds of feed? FJ knows he can purchase enough feed. </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> n,E,K,dp[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,f,c;</span><br><span class="line">&#125; a[N];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Data p,Data q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p.x&lt;q.x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;K,&amp;E,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;a[i].x,&amp;a[i].f,&amp;a[i].c);</span><br><span class="line">    sort(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;sum+k&lt;=a[i].f;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            sum+=k;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=K;j&gt;=k;--j)</span><br><span class="line">                dp[j]=min(dp[j],dp[j-k]+a[i].c*k+(j*j-(j-k)*(j-k))*(E-a[i].x));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> k=a[i].f-sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=K;j&gt;=k;--j)</span><br><span class="line">            dp[j]=min(dp[j],dp[j-k]+a[i].c*k+(j*j-(j-k)*(j-k))*(E-a[i].x));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[K]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="K-排座椅"><a href="#K-排座椅" class="headerlink" title="[K]排座椅"></a>[K]排座椅</h3><blockquote><p>上课的时候总有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的D对同学上课时会交头接耳。同学们在教室中坐成了M行N列，坐在第i行第j列的同学的位置是（i，j），为了方便同学们进出，在教室中设置了K条横向的通道，L条纵向的通道。于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了两个会交头接耳的同学，那么他们就不会交头接耳了。<br>请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生对数最少</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>; </span><br><span class="line"><span class="keyword">int</span> m,n,k,l,d;<span class="comment">//变量名最好起与题目一致的 </span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">1005</span>],y[<span class="number">1005</span>];<span class="comment">//横纵坐标数组 </span></span><br><span class="line"><span class="keyword">int</span> c[<span class="number">1005</span>],o[<span class="number">1005</span>];<span class="comment">//桶排要用的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d%d"</span>,&amp;m,&amp;n,&amp;k,&amp;l,&amp;d); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=d;i++) &#123; </span><br><span class="line">        <span class="keyword">int</span> xi,yi,pi,qi; </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;xi,&amp;yi,&amp;pi,&amp;qi); </span><br><span class="line">        <span class="keyword">if</span>(xi==pi) </span><br><span class="line">            x[min(yi,qi)]++;<span class="comment">//表示隔开这两排的价值 </span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            y[min(xi,pi)]++; <span class="comment">//记得取min，即过道与前一个坐标保持一致 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;<span class="comment">//开始桶排 </span></span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">-1</span>;<span class="comment">//为了求出每次的最大值，需要每次扫一遍 </span></span><br><span class="line">        <span class="keyword">int</span> p; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(y[j]&gt;maxn)&#123; </span><br><span class="line">                maxn=y[j]; </span><br><span class="line">                p=j; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        y[p]=<span class="number">0</span>;<span class="comment">//求出max之后一定要记得清零！！否则无论排多少次都是一个答案 </span></span><br><span class="line">        c[p]++;<span class="comment">//桶排不解释 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=l;i++)&#123; </span><br><span class="line">        <span class="keyword">int</span> maxn=<span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">int</span> p; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123; </span><br><span class="line">            <span class="keyword">if</span>(x[j]&gt;maxn)&#123; </span><br><span class="line">                maxn=x[j]; </span><br><span class="line">                p=j; </span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        x[p]=<span class="number">0</span>; <span class="comment">//同上 </span></span><br><span class="line">        o[p]++; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1005</span>;i++)<span class="comment">//输出答案 </span></span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(c[i])<span class="comment">//表示需要隔开这行 </span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,i); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>); </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1005</span>;i++) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">if</span>(o[i]) </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>,i); <span class="comment">//同上 </span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="L-Daisy-Chains-in-the-Field"><a href="#L-Daisy-Chains-in-the-Field" class="headerlink" title="[L] Daisy Chains in the Field"></a>[L] Daisy Chains in the Field</h3><blockquote><p>Farmer John let his N (1 &lt;= N &lt;= 250) cows conveniently numbered 1..N play in the field. The cows decided to connect with each other using cow-ropes, creating M (1 &lt;= M &lt;= N*(N-1)/2) pairwise connections. Of course, no two cows had more than one rope directly connecting them. The input shows pairs of cows c1 and c2 that are connected (1 &lt;= c1 &lt;= N; 1 &lt;= c2 &lt;= N; c1 != c2).<br> FJ instructed the cows to be part of a chain which contained cow #1. Help FJ find any misbehaving cows by determining, in ascending order, the numbers of the cows not connected by one or more ropes to cow 1 (cow 1 is always connected to herself, of course). If there are no misbehaving cows, output 0. </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 255</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">qwq</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">int</span> nxt;</span><br><span class="line">&#125;e[MAXN*MAXN*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> head[MAXN],cnt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    e[++cnt].to=y;</span><br><span class="line">    e[cnt].nxt=head[x];</span><br><span class="line">    head[x]=cnt;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&lt;<span class="string">'0'</span>||ch&gt;<span class="string">'9'</span>)</span><br><span class="line">        ch=getchar();</span><br><span class="line">    <span class="keyword">while</span>(ch&gt;=<span class="string">'0'</span>&amp;&amp;ch&lt;=<span class="string">'9'</span>) &#123;</span><br><span class="line">        x=(x&lt;&lt;<span class="number">1</span>)+(x&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>);</span><br><span class="line">        ch=getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">    vis[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[x];i;i=e[i].nxt)&#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[e[i].to])</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        dfs(e[i].to,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=read(),m=read();</span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=read(),y=read();</span><br><span class="line">        add(x,y),add(y,x);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    dfs(<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">int</span> bb=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            bb=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span>(bb==<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"0"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      注：因为是团队赛，所以题并不都是自己写的。
    
    </summary>
    
      <category term="专题集训与赛事" scheme="http://Yeasion.github.io/categories/%E4%B8%93%E9%A2%98%E9%9B%86%E8%AE%AD%E4%B8%8E%E8%B5%9B%E4%BA%8B/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心" scheme="http://Yeasion.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="线段树" scheme="http://Yeasion.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Contest Nowcoder1115 Nowcoder Challenge33</title>
    <link href="http://Yeasion.github.io/2019/10/08/Contest%20Nowcoder1115%20Nowcoder%20Challenge33/"/>
    <id>http://Yeasion.github.io/2019/10/08/Contest Nowcoder1115 Nowcoder Challenge33/</id>
    <published>2019-10-08T14:00:00.000Z</published>
    <updated>2019-11-11T11:52:48.297Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/1115" target="_blank" rel="noopener">Link</a></p><p>牛客挑战赛1115，很有难度的一些题，当然，我指的部分。</p><h3 id="妖馨斋的五彩棒"><a href="#妖馨斋的五彩棒" class="headerlink" title="妖馨斋的五彩棒"></a>妖馨斋的五彩棒</h3><blockquote><p>给定三个正整数$A, B, C$。设$AA = \frac{AB}{C} + \frac{BC}{A} +\frac{AC}{B}$，$BB = A + B + C$。如果$AA &gt; BB$输出$YES$，否则输出$NO$。</p></blockquote><p>这道题我看到的时候直接笑喷了。。。又要有不少人想各种诡异的算法。实际上虽然数据范围很大，但是对于$python$来说直接暴力模拟是没有任何问题的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = input().split() ;</span><br><span class="line">A = float(n[<span class="number">0</span>])</span><br><span class="line">B = float(n[<span class="number">1</span>])</span><br><span class="line">C = float(n[<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">AA = (A * B) / C + (B * C) / A + (A * C) / B</span><br><span class="line">BB = A + B + C </span><br><span class="line"><span class="keyword">if</span> AA &gt; BB:</span><br><span class="line">    print(<span class="string">"YES"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"NO"</span>)</span><br></pre></td></tr></table></figure><h3 id="鸽天的放鸽序列"><a href="#鸽天的放鸽序列" class="headerlink" title="鸽天的放鸽序列"></a>鸽天的放鸽序列</h3><blockquote><p>给定一个$N，K$，定义一个长为$N$的$01$序列${A_i}$，其权值为$\sum_{i = 1}^{N}((\sum_{j = 1}^iA_j)~mod~2)$，求有多少个$01$序列满足有$K$个1，并且权值最大。</p></blockquote><p>这个题是要好好研究一下这个式子的。</p><p>发现里面的$\sum_{j = 1}^iA_j$指的是前缀和，因为是$01$序列，因此我们可以抽象成前缀中$1$的个数，但是他后面$mod$了一个$2$，因此我们知道了，对于每一个前缀，如果含有的$1$的个数为$1$那么贡献就为$1$否则贡献为$0$。</p><p>因此我们尝试去推一下构造这个$01$序列的规律。首先我们发现如果放$0$那么是可以产生和前一位相同的贡献的，因此如果前面的$1$的个数为偶数，那么这个时候我们放$0$必然是不优的，因此直接舍弃这个转移方式。当然，如果前面是$0$个$1$的话也是一样的，同样是会浪费掉这个$0$。</p><p>因此我们尝试去构造一个$Dp$转移，设$Dp[i][j]$表示构造到了前$i$个数，并且含有$j$个$1$的满足要求的序列有多少个。那么我们有这样的转移：</p><script type="math/tex; mode=display">Dp[i][j] = Dp[i - 1][j]+Dp[i - 1][j - 1]~(j ~mod~ 2 == 1)</script><script type="math/tex; mode=display">Dp[i][j] = Dp[i - 1][j - 1]~(j~mod~2 == 0)</script><p>嗯，他看起来很好理解那我就不多说了，当然你也可以选择滚动数组，但是你会发现即使这样他也会超时，因此就考虑将所有的这些玩意组合起来看最后的结果。</p><p>你会发现最后的结果相当于是在$k$个$1$里面茶语$n - k$个$0$，并且这些$0$能插入的位置必须满足前缀和为奇数。因此我们一共有$\lfloor \frac{k}{2} \rfloor$可以插入，因此直接组合数即可。当然不要忘了求$Inv$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">1000100</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">1000100</span> ;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Mod = <span class="number">1e9</span> + <span class="number">7</span> ;</span><br><span class="line">LL N, K, A[MAXN], Ans, Fac[MAXN], Inv[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span> ; <span class="keyword">bool</span> F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">quickMod</span><span class="params">(LL a,LL b)</span> </span>&#123;</span><br><span class="line">LL ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b&amp;<span class="number">1</span>)</span><br><span class="line">ans = ans * a % Mod;</span><br><span class="line">a = a*a % Mod;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getFac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Fac[<span class="number">0</span>] = Inv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">1000010</span> ; i++) &#123;</span><br><span class="line">Fac[i] = Fac[i<span class="number">-1</span>] * i % Mod;</span><br><span class="line">Inv[i] = quickMod(Fac[i],Mod<span class="number">-2</span>); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">getC</span><span class="params">(LL n,LL m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Fac[n] * Inv[n-m] % Mod * Inv[m] % Mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; K = Read() ;</span><br><span class="line"><span class="keyword">if</span> (K == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"1"</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">getFac() ;</span><br><span class="line">N = N - <span class="number">2</span> + K % <span class="number">2</span> ;</span><br><span class="line">K = (K - <span class="number">1</span>) / <span class="number">2</span> ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, getC(N - K, K)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      牛客挑战赛33
    
    </summary>
    
      <category term="专题集训与赛事" scheme="http://Yeasion.github.io/categories/%E4%B8%93%E9%A2%98%E9%9B%86%E8%AE%AD%E4%B8%8E%E8%B5%9B%E4%BA%8B/"/>
    
    
      <category term="python" scheme="http://Yeasion.github.io/tags/python/"/>
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="组合数学" scheme="http://Yeasion.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>2019十一集训贪心专题选讲</title>
    <link href="http://Yeasion.github.io/2019/10/02/2019%E5%8D%81%E4%B8%80%E9%9B%86%E8%AE%AD%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98%E9%80%89%E8%AE%B2/"/>
    <id>http://Yeasion.github.io/2019/10/02/2019十一集训贪心专题选讲/</id>
    <published>2019-10-02T10:41:20.000Z</published>
    <updated>2019-11-11T11:52:27.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="New-Year-Snowmen"><a href="#New-Year-Snowmen" class="headerlink" title="New Year Snowmen"></a>New Year Snowmen</h3><blockquote><p> 要堆起一个雪人，需要三个不同大小的雪球。</p><p> 现在有$n$个给定大小的雪球，问最多能堆起多少个雪人，并输出方案。($n \leq 10 ^ 5$)</p></blockquote><p><a href="https://codeforces.com/problemset/problem/140/C" target="_blank" rel="noopener">Codeforces 140C</a></p><p>好像这个结论比较难证，但是很容易想出来。就是说我们每次取出目前数量最多的雪球种类，这样能取出来的雪人的个数一定是最多的。至于证明，还是留给读者慢慢想吧。。。</p><p>因此做法很一目了然了，基本上就是记录每一种雪球的种类数，然后用优先队列维护一下就可以了，虽然做法很简单，但是有一些细节仍然需要注意，建议大家尝试动手写一写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, Tot = <span class="number">1</span>, Ans ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> R, ID ;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (Node B) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> R &lt; B.R ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;E[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> X[<span class="number">4</span>] ;</span><br><span class="line">&#125;G[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">E[i].R = Read(), E[i].ID = i ;</span><br><span class="line">sort(E + <span class="number">1</span>, E + N + <span class="number">1</span>) ;</span><br><span class="line">E[<span class="number">0</span>].R = - INF ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= N + <span class="number">1</span> ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (E[i].R != E[i - <span class="number">1</span>].R) &#123;</span><br><span class="line">Node Now ;</span><br><span class="line">Now.ID = E[i - <span class="number">1</span>].R, Now.R = Tot ;</span><br><span class="line">Q.push(Now) ; Tot = <span class="number">1</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span> Tot ++ ;</span><br><span class="line">&#125;</span><br><span class="line">Node NOW ; NOW = Q.top() ; <span class="keyword">int</span> Cnt = <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (Q.size() &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">Node Now[<span class="number">4</span>] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; i ++) &#123;</span><br><span class="line">Now[i] = Q.top() ; Q.pop() ;</span><br><span class="line">Now[i].R -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; i ++)</span><br><span class="line"><span class="keyword">if</span> (Now[i].R) Q.push(Now[i]), Cnt ++ ;</span><br><span class="line">Ans ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">3</span> ; i ++)</span><br><span class="line">G[Ans].X[i] = Now[i].ID ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Ans ; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> L = min(G[i].X[<span class="number">1</span>], min(G[i].X[<span class="number">2</span>], G[i].X[<span class="number">3</span>])),</span><br><span class="line">    R = max(G[i].X[<span class="number">1</span>], max(G[i].X[<span class="number">2</span>], G[i].X[<span class="number">3</span>])) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, R) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">3</span> ; j ++)</span><br><span class="line"><span class="keyword">if</span> (G[i].X[j] &lt; R &amp;&amp; G[i].X[j] &gt; L) <span class="built_in">printf</span>(<span class="string">"%d "</span>, G[i].X[j]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, L) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Discounts"><a href="#Discounts" class="headerlink" title="Discounts"></a>Discounts</h3><blockquote><p> 超市打折，如果购物车里有至少一个凳子，则可半价购买购物车里最便宜的一个物品。</p><p> 现在你要购买$n$个物品，其中一些是凳子。你有$K$个购物车，求一个最优的购买方案，使得花费的价格最少。</p><p>$k \leq n \leq 10 ^ 5$</p></blockquote><p><a href="https://codeforces.com/problemset/problem/161/B" target="_blank" rel="noopener">Codeforces 161B</a></p><p>贪心策略：对于所有的凳子，最好的情况是独占一个购物车。因此最好的决断是对于所有的凳子，使其尽量独占一个购物车，如果不能使所有的凳子独占一个购物车（K - 1 &lt; 凳子数），则将所有的凳子按降序排序之后从前往后填充，然后将剩下的凳子和非凳子的物品都放到最后一个购物车当中。</p><p>策略非常简单，但是写起来很麻烦，需要分类讨论$K - 1$和凳子数的关系，很是烦人，建议大家写一写，很能锻炼码力的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, K, C_T, O_T ;</span><br><span class="line"><span class="keyword">double</span> Ans ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> C, T, ID ;</span><br><span class="line">&#125;E[MAXN], Chair[MAXN], Othe[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CMP</span><span class="params">(NODE A, NODE B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> A.C &gt; B.C ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; K = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">E[i].C = Read(), E[i].T = Read(), E[i].ID = i ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">if</span> (E[i].T == <span class="number">1</span>) Chair[++ C_T] = E[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">if</span> (E[i].T == <span class="number">2</span>) Othe[++ O_T] = E[i] ;</span><br><span class="line">sort(Chair + <span class="number">1</span>, Chair + C_T + <span class="number">1</span>, CMP) ;</span><br><span class="line"><span class="keyword">if</span> (C_T &gt; K - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K - <span class="number">1</span> ; i ++)</span><br><span class="line">Ans += (<span class="keyword">double</span>) Chair[i].C / <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">int</span> Min = INF ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= O_T ; i ++)</span><br><span class="line">Ans += Othe[i].C, Min = min(Min, Othe[i].C) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K ; i &lt;= C_T ; i ++)</span><br><span class="line">Ans += Chair[i].C, Min = min(Min, Chair[i].C) ;</span><br><span class="line">Ans -= (<span class="keyword">double</span>) Min / <span class="number">2</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (C_T &lt;= K - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= C_T ; i ++)</span><br><span class="line">Ans += (<span class="keyword">double</span>) Chair[i].C / <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= O_T ; i ++)</span><br><span class="line">Ans += Othe[i].C ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.1lf\n"</span>, Ans) ;</span><br><span class="line"><span class="keyword">if</span> (C_T &gt;= K - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K - <span class="number">1</span> ; i ++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1 "</span> &lt;&lt; Chair[i].ID &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; O_T + C_T - K + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K ; i &lt;= C_T ; i ++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Chair[i].ID &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= O_T ; i ++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Othe[i].ID &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (C_T &lt; K - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= C_T ; i ++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1 "</span> &lt;&lt; Chair[i].ID &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= K - C_T - <span class="number">1</span> ; i ++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"1 "</span> &lt;&lt; Othe[i].ID &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; O_T - K + C_T + <span class="number">1</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = K - C_T ; i &lt;= O_T ; i ++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Othe[i].ID &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="叠罗汉"><a href="#叠罗汉" class="headerlink" title="叠罗汉"></a>叠罗汉</h3><blockquote><p> 有$n$个罗汉，每个罗汉有重量$w$和力量$s$。</p><p> 定义一个罗汉的危险值为他上面所有物品的重量之和减去他的力量。</p><p> 安排一个顺序使得危险值最大的罗汉的危险值最小。</p><p>$n≤10^5$</p></blockquote><p>首先，我们可以发现对于两个罗汉$i$和$j$，他们之间的上下顺序对于下方所造成的的贡献是完全无关的，因此我们可以将整个问题拆分成一个个两罗汉的小问题逐一解决。假设这两个罗汉上方的罗汉一共重量G。</p><p>那么考虑这两个罗汉，如果是$i$在上面的话，那么他们两个造成的危险值是：</p><script type="math/tex; mode=display">Data_i = G - s_i</script><script type="math/tex; mode=display">Data_j = G +w_i - s_j</script><p>如果是$j$在上面的话，造成的危险值是：</p><script type="math/tex; mode=display">Data_i = G +w_j - s_i</script><script type="math/tex; mode=display">Data_j = G - s_j</script><p>讨论这两种情况可以发现当$w_i + s_i$比较小的时候造成的危险值最大的罗汉危险值最小，于是$w_i + s_i$比较小的罗汉放到上面比较优。所以最优解就是按照$w_i +s_i$排一下序就可以了。</p><h3 id="建筑抢修"><a href="#建筑抢修" class="headerlink" title="建筑抢修"></a>建筑抢修</h3><blockquote><p> 基地里有 $N$ 个建筑设施受到了严重的损伤，但只有 一个修理工人。</p><p> 修复一个建筑都需要 T1 的时间，工人一次只能修一个。如果某个建筑在T2时间之内没有修理完毕 ，这个建筑就报废了。</p><p> 你的任务是制订一个合理的维修顺序，以抢修尽可能多的建筑。</p><script type="math/tex; mode=display">N ≤ 150000</script></blockquote><p><a href="https://www.luogu.org/problem/P4053" target="_blank" rel="noopener">JSOI2007</a></p><p>开始我是估摸着能找出来一个确定的枚举顺序，$sort$一下$O(N)$就处理完了。但是我把$T1$和$T2$反复折腾还是没有找出一个正确的顺序，因为我总是能够找出反例，一般这个时候这种类型的贪心就只有一种路可走了：按一定顺序先进行排序，然后在枚举过程中根据另一变量对当前枚举顺序做出修改。</p><p>这个地方一眼的枚举方式就是按照$T2$从小到大枚举，然后我们根据$T1$在此基础上对当前枚举顺序做一下调整。</p><p>假设当前使用了的总时间为$Tot$，如果$Tot + T1 &lt;= T2$，那么我们直接维修当前i就可以。</p><p>而如果建筑i不能在$T1$时间内修复，我们转而在之前已经修理过的所有建筑中选出$T1$最大的j号点来，如果$T1_j &gt; T2_i$那么我们更改决策，放弃$j$而修$i$。</p><p>这种决策为何是正确的就在于如果第$i$号建筑的出现时间不足，由于我们是按照$T2$进行排序，因此前面的节点最多修复了$i - 1$，那么我们就尽量选择$T1$总和较小的$i - 1$个建筑，给后面的决策留出更加充足的时间。因此，这个决策没有劣处。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line">LL Tot, Ans ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HOUSE</span> &#123;</span></span><br><span class="line">LL T1, T2 ;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (HOUSE B) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> T2 &lt; B.T2 ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;E[MAXN] ;</span><br><span class="line">priority_queue &lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; Q ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line">LL N = Read() ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++) </span><br><span class="line">E[i].T1 = Read(), E[i].T2 = Read() ;</span><br><span class="line">sort(E + <span class="number">1</span>, E + N + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">if</span> (E[i].T1 + Tot &lt;= E[i].T2)</span><br><span class="line">Tot += E[i].T1, Q.push(E[i].T1), Ans ++ ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Q.top() &gt; E[i].T1 &amp;&amp; Tot - Q.top() + E[i].T1 &lt;= E[i].T2)</span><br><span class="line">Tot -= Q.top() - E[i].T1, Q.pop(), Q.push(E[i].T1) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>, Ans) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删数问题"><a href="#删数问题" class="headerlink" title="删数问题"></a>删数问题</h3><blockquote><p> 给定一个高精度的大正整数S（S最长可达240位），你需要去掉其中任意N位数字。剩下的数字按原次序组成一个新的正整数S’。</p><p>对给定的NS，寻找一种方案使得剩下的数字组成的新数S’最小。</p></blockquote><p><a href="https://www.luogu.org/problem/P1106" target="_blank" rel="noopener">LuoguP1106</a></p><p>这个题的话，不管花多长时间，我感觉最后所有人应该还是都想得出来的。所以我在这里就直接下结论了。</p><p>我们都知道贪心是可以由局部最优解推出全局最优解的，于是我们只要保证每一步都是最优的，那么最终答案也是最优的，因此我们每一次都选择使当前数字序列最大的方式进行删数。从高位到低位遍历，如果各位数字递增，那么删除最后一个数字，否则删除第一个递减区间的第一个数字。重复N次就可以了。（实际上就是删除第一个极大值啦。。。</p><p>而如何简化一下程序呢？题目要求我们删数，我们不妨设为选数，按照上方的思想，我们可以每次直接选取整个序列中最小的并且位数最高的一个数，然后将他的左边部分全部删去，然后对于左边的序列我们再次进行同样的操作就可以保证结果最优。至于如何证明这个情况，我建议大家从“答案这个数列的各个位数”方面入手分析。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">300</span> ;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="built_in">string</span> N ; <span class="keyword">int</span> L, K, Data[MAXN], Last, Cnt, Min, T = <span class="number">1</span>, F ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; K ; L = N.length() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= L ; i ++) Data[i] = N[i - <span class="number">1</span>] - <span class="string">'0'</span> ;</span><br><span class="line">Last = L - K ;</span><br><span class="line"><span class="keyword">while</span> (Cnt &lt; Last) &#123;</span><br><span class="line">Min = T ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = T ; i &lt;= K + T ; i ++)</span><br><span class="line"><span class="keyword">if</span> (Data[Min] &gt; Data[i]) Min = i ;</span><br><span class="line"><span class="keyword">if</span> (Data[Min]) F = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (F) <span class="built_in">cout</span> &lt;&lt; Data[Min] ;</span><br><span class="line">K -= Min - T, T = Min + <span class="number">1</span>, Cnt ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! F) <span class="built_in">puts</span>(<span class="string">"0"</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="取数游戏"><a href="#取数游戏" class="headerlink" title="取数游戏"></a>取数游戏</h3><blockquote><p>给出n个正整数，你需要把它们连接成一排，组成一个最大的多位整数。</p><p>例如：n=3时，3个整数13、312、343，连成的最大整数为34331213。</p><p>又如：n=4时，4个整数7、13、4、246，连成的最大整数为7424613。</p><p>$ n≤10^5$</p></blockquote><p>没错这是一道很水的题。只需要从高位向低位判断就可以了。</p><p>个屁。这样说起来好像是很容易但是仔细想一想怎么写你就会发现自己陷入一个很智障的无底洞。</p><p>我们考虑重新定义字符串的大小关系，对于两个字符串A, B如果$A后面接B$比$B后面接A$大，那么我们才定义$A &gt;B$，（12， 121）</p><p>然后我们对于所有的数都进行一次这样的比较，直接按照这样的法则sort就可以了。</p><h3 id="兔子与樱花"><a href="#兔子与樱花" class="headerlink" title="兔子与樱花"></a>兔子与樱花</h3><p><a href="https://www.luogu.org/problem/P4107" target="_blank" rel="noopener">HEOI2015</a></p>]]></content>
    
    <summary type="html">
    
      讲题人是THU的王之栋，相当的神仙.
    
    </summary>
    
      <category term="专题集训与赛事" scheme="http://Yeasion.github.io/categories/%E4%B8%93%E9%A2%98%E9%9B%86%E8%AE%AD%E4%B8%8E%E8%B5%9B%E4%BA%8B/"/>
    
    
      <category term="贪心" scheme="http://Yeasion.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>2019十一集训二分与倍增专题</title>
    <link href="http://Yeasion.github.io/2019/10/02/2019%E5%8D%81%E4%B8%80%E9%9B%86%E8%AE%AD%E4%BA%8C%E5%88%86%E4%B8%8E%E5%80%8D%E5%A2%9E%E4%B8%93%E9%A2%98/"/>
    <id>http://Yeasion.github.io/2019/10/02/2019十一集训二分与倍增专题/</id>
    <published>2019-10-02T10:41:19.000Z</published>
    <updated>2019-11-11T11:52:24.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第K大区间"><a href="#第K大区间" class="headerlink" title="第K大区间"></a>第K大区间</h3><blockquote><p> 定义一个区间的值为其众数出现的次数。现给出一个数列a[1…n]，求将所有区间的值排序后，第K大的值为多少。区间大小为1的不计。$1≤n≤10^5$</p></blockquote><p>我们首先可以发现这个玩意是有一个单调性的，就是对于一个区间$[L, R]$，如果将它向右扩展，那么这个区间的价值（也就是众数）一定是不降的。那么满足单调性我们显然可以二分，直接二分出一个答案$Ans$表示第K大值，病假设一个函数$F(X)$表示价值大于等于$X$的区间个数。则题目转化为$F(Ans) \geq K$的基础上最大化$Ans$。二分这个$X$,$F(X) \geq K$那么范围缩小到$[X, R]$，反之就缩小到$[L, X - 1]$。</p><p>基本的思路有了，接下来就剩一个求$F(X)$了。关于这个东西有一个叫做$two ~pointers$的算法可以很好地解决，简而言之就是维护两个指针$l, r$和一个表示$i$出现了几次的桶$T[i]$，从左向右扫就可以维护价值大于等于$X$的区间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">    T[A[l - <span class="number">1</span>]] -- ;</span><br><span class="line">    <span class="keyword">while</span>(T[A[r]] &lt; X) r ++ ;</span><br><span class="line">    F += N - r +<span class="number">1</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度$O(NlogN)$</p><h3 id="聪明的质检员"><a href="#聪明的质检员" class="headerlink" title="聪明的质检员"></a>聪明的质检员</h3><blockquote><p> 小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 n 个矿石，从 1 到 n 逐一编号，每个矿石都有自己的重量 $w_i$  以及价值$v_i$ 。</p><p> 检验矿产的流程是：</p><p>1.给定 $m$ 个区间$[L_i，R_i]$；</p><p>2.选出一个参数 $W$；</p><p>3.对于一个区间 $[L_i，R_i ]$，计算矿石在这个区间上的检验值 $y$ ：</p><script type="math/tex; mode=display">y_{i}=\left(\sum_{j} 1\right) \times\left(\sum_{j} v_{j}\right), j \in\left[L_{i j}, R_{i}\right] 且 w_{j} \geq W</script><p>也就是 $w$ 大于等于 $W$ 的个数和乘以价值和。</p><p> 这批矿产的检验结果 $Y=∑_{i=1}^ny_i$ </p><p> 上头给了个标准值$S$，他希望你帮他调整参数 $W$ 的值，使 $|S-Y|$ 最小。</p></blockquote><p><a href="https://www.luogu.org/problem/P1314" target="_blank" rel="noopener">Noip2011</a></p><p>这个显然是要求我们二分$W$，但是如果你真的直接去二分$W$然后一个一个地计算检验的话，时间复杂度是$O(NMLogN)$显然是会炸掉的。</p><p>首先考虑单调性，我们发现当$W$变大的时候，$y$显然是会变小的，因为符合条件的矿石变少了嘛。所以$Y$也显然会跟着变小，那么$S - Y$就会变大。而至于加上绝对值，就需要分类讨论一下了。</p><p>不管这个，因为Y可以被表示成一个关于W的函数，我们设这个函数位$F(W)$，那么因为其单调不升，所以我们就可以将问题转化为求$|F(W) - S|$的最小值。而这个$F(W)$我们显然不能直接按照给的式子进行计算，我们统计对于已经确定的$W$，有贡献的$A[i]$个数的前缀和$Sum0$和$A[i]$的前缀和$Sum1$。然后计算就变成：</p><script type="math/tex; mode=display">y_i = (Sum0_{R_i} - Sum0_{L_i - 1}) * (Sum1_{R_i} - Sum1_{L_i - 1})</script><p>就变成了$O(N)$的啦，配合上二分就可以$O(NlogN)$解决啦。</p><p>数比较大，记得开$long~long$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x3f3f3f3f3f3f3f3f</span> ;</span><br><span class="line">LL N, M, S, W[MAXN], V[MAXN], Sum0[MAXN], Sum1[MAXN], Max = - INF, Min = INF, Ans = INF ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SQU</span> &#123;</span></span><br><span class="line">LL L, R ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; M = Read() ; S = Read() ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">W[i] = Read(), V[i] = Read(),</span><br><span class="line">Max = max(Max, W[i]), Min = min(Min, W[i]) ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= M ; i ++)</span><br><span class="line">E[i].L = Read(), E[i].R = Read() ;</span><br><span class="line">LL L = Min - <span class="number">1</span>, R = Max + <span class="number">2</span>, WW ;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">WW = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">Sum0[i] = Sum1[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (W[i] &gt;= WW)</span><br><span class="line">Sum0[i] = Sum0[i - <span class="number">1</span>] + <span class="number">1</span>, </span><br><span class="line">Sum1[i] = Sum1[i - <span class="number">1</span>] + V[i] ;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">Sum0[i] = Sum0[i - <span class="number">1</span>], </span><br><span class="line">Sum1[i] = Sum1[i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line">LL Y = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= M ; i ++)</span><br><span class="line">Y += (Sum0[E[i].R] - Sum0[E[i].L - <span class="number">1</span>]) * </span><br><span class="line"> (Sum1[E[i].R] - Sum1[E[i].L - <span class="number">1</span>]) ;</span><br><span class="line"><span class="keyword">if</span> (Y &gt; S) L = WW + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> R = WW - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(Y - S) &lt; Ans) Ans = <span class="built_in">abs</span>(Y - S) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="跳石头"><a href="#跳石头" class="headerlink" title="跳石头"></a>跳石头</h3><blockquote><p> 一年一度的“跳石头”比赛又要开始了！</p><p> 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块距离为 L 的岩石作为比赛起点和终点。在起点和终点之间，有 N 块岩石(不含起点和终点的岩石)。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p><p> 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石(不能移走起点和终点的岩石)。</p><p> $0≤M≤N≤50000, 1≤L≤10^9$。</p></blockquote><p><a href="https://www.luogu.org/problem/P2678" target="_blank" rel="noopener">Noip2015</a></p><p>额，这时间上就是一个很纯的二分，考虑单调性，显而易见地发现移走的石头越多，那么最短跳跃的最大值就越大，额，起码不会减就是了。然后就直接枚举最短跳跃的最大值，然后从头开始判断，记录最少要移走的石头的个数与M比较一下看看是否合法就可以了。</p><p>怎么算这个最少要移走的石头的个数其实可以人类智慧法，你发现如果枚举到一个$i$与$i - 1$的距离，它是小于我们二分的值$Mid$的，那么我们把这块石头移走就可以了。这样的答案一定是最优的，好像可以用反证法来证明，但是我觉得直觉就足以告诉你最优解了，这也是为什么目前普遍认为这道题的水平并不是很高的原因。</p><p>至于怎么操作叫移去这个石头，你可以记录一下上一个石头的下标嘛。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> Len, N, M, D[MAXN], Cnt = <span class="number">0</span>, Ans ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Len = Read() ; N = Read() ; M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) D[i] = Read() ;</span><br><span class="line"><span class="keyword">int</span> L = <span class="number">0</span>, R = Len ;</span><br><span class="line"><span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line"><span class="keyword">int</span> Mid = (L + R) &gt;&gt; <span class="number">1</span>, Pas = <span class="number">0</span> ; Cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (D[i] - D[Pas] &lt; Mid)</span><br><span class="line">Cnt ++ ;</span><br><span class="line"><span class="keyword">else</span> Pas = i ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (Cnt &gt; M) R = Mid - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> L = Mid + <span class="number">1</span>, Ans = Mid ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="借教室"><a href="#借教室" class="headerlink" title="借教室"></a>借教室</h3><blockquote><p> 我们需要处理$n$天的借教室信息，其中第 i 天学校有$ r_i  $个教室可供租借。</p><p> 共有$m$份订单，每份订单用三个正整数描述，分别为$d_j,s_j,t_j，$表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。 </p><p> 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。</p><p> 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 </p><p> $1≤n,m≤10^6, 0≤r_i,d_j≤10^9,1≤s_j≤t_j≤n$。</p></blockquote><p><a href="https://www.luogu.org/problem/P1083" target="_blank" rel="noopener">Noip2012</a></p><p>首先依然是考虑单调性，很容易发现，第$i$天肯定比$i + 1$天更容易满足需求，并且如果$i$天满足不了，那么接下来也不可能满足。单调性已有，那么考虑二分。</p><p>如何验证前 i 天是否满足条件？ 由于天数已经固定了，需求也就固定了。问题转化为，有很多次离线区间加，最后要求判断每一个元素是否小于$ d $。离线区间加我们可以差分后使用前缀和的技巧来解决：设数组$s[1..n]$，对于所有区间$[l,r]$整体$+c$的操作，我们令$s[l]+=c,s[r+1]-=c$这样做完之后，我们枚举位置$i=1~n$,同时设变量add。每当访问到一个位置$i$，$add+=s[i]，a[i]+=add$。这样就解决了区间加的问题。  </p><p>复杂度：$O((n+m)  log⁡m)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1000010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf 0x7fffffff</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="function">LL <span class="title">Read</span><span class="params">()</span></span>&#123;</span><br><span class="line">LL X = <span class="number">0</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span>(ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span>(ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>)</span><br><span class="line">X = (X &lt;&lt; <span class="number">1</span>) + (X &lt;&lt; <span class="number">3</span>) + (ch ^ <span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X ;</span><br><span class="line">&#125;</span><br><span class="line">LL Before[MAXN] ;</span><br><span class="line">LL N, M, Room[MAXN] ;</span><br><span class="line">LL Rest[MAXN + <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Make</span>&#123;</span></span><br><span class="line">LL Data, L, R ;</span><br><span class="line">&#125;Edge[MAXN] ;</span><br><span class="line">LL L, R, Mid;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Search</span><span class="params">(LL Now)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= Now; i ++)&#123;</span><br><span class="line">Rest[Edge[i].L] += Edge[i].Data ;</span><br><span class="line">Rest[Edge[i].R + <span class="number">1</span>] -= Edge[i].Data ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N ; i ++)&#123;</span><br><span class="line">Room[i] = Rest[i] + Room[i - <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">if</span>(Room[i] &gt; Before[i])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">N = Read(), M = Read() ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i ++)</span><br><span class="line">Before[i] = Read() ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">Edge[i].Data = Read() ;</span><br><span class="line">Edge[i].L = Read() ;</span><br><span class="line">Edge[i].R = Read() ;</span><br><span class="line">&#125;</span><br><span class="line">L = <span class="number">0</span>; R = M + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line"><span class="built_in">memset</span>(Rest, <span class="number">0</span>, <span class="keyword">sizeof</span>(Rest)) ;</span><br><span class="line"><span class="built_in">memset</span>(Room, <span class="number">0</span>, <span class="keyword">sizeof</span>(Room)) ;</span><br><span class="line">Mid = (L + R) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">int</span> Num = Search(Mid) ;</span><br><span class="line"><span class="keyword">if</span>(! Num) R = Mid ;</span><br><span class="line"><span class="keyword">else</span> L = Mid + <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">0</span> &lt; L &amp;&amp; L &lt;= M) <span class="built_in">printf</span>(<span class="string">"-1\n%d"</span>, L) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"0"</span>) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种做法是有可能被卡的，因此还可以用一些数据结构进行优化，但是已经超出了本题的范围，在这里不再探究。</p><h3 id="妮厨的愤怒"><a href="#妮厨的愤怒" class="headerlink" title="妮厨的愤怒"></a>妮厨的愤怒</h3><blockquote><p> 对于一个字符串$S[1…n]$，询问$q$次，每次询问$[l,r]$内最长的回文串。</p><p>$1≤n ,q≤10^5，0≤l≤r&lt;n$ ，只包含小写拉丁字母</p></blockquote>]]></content>
    
    <summary type="html">
    
      定义以及板子版的upper_bound和lower_bound就不再重复了，没啥意思。
    
    </summary>
    
      <category term="专题集训与赛事" scheme="http://Yeasion.github.io/categories/%E4%B8%93%E9%A2%98%E9%9B%86%E8%AE%AD%E4%B8%8E%E8%B5%9B%E4%BA%8B/"/>
    
    
      <category term="二分" scheme="http://Yeasion.github.io/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="倍增" scheme="http://Yeasion.github.io/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>[ZJOI2005]午餐</title>
    <link href="http://Yeasion.github.io/2019/10/01/ZJOI2005-%E5%8D%88%E9%A4%90/"/>
    <id>http://Yeasion.github.io/2019/10/01/ZJOI2005-午餐/</id>
    <published>2019-10-01T11:28:12.000Z</published>
    <updated>2019-11-11T11:54:50.138Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P2577" target="_blank" rel="noopener">Link</a><br>两个窗口不是很好想，那么首先我们需要确定一个窗口内的打饭顺序。<br>考虑对于一个窗口的所有人，假设这些人不变，那么不管这个窗口的人的排列是怎么样的，其打饭的时间永远都是所有排队的人的打饭时间的和，那么，但是我们仍然需要考虑所有人打完饭之后仍然会有人在吃饭的问题，于是考虑将吃饭时间长的人排在前面。如何解释想必不用我说了，这种东西稍微想一想应该是可以明白的。<br>那么首先的算法确定为一个贪心的排序处理，按照吃饭时间从大到小排序。<br>之后我们要考虑的就是谁在1号窗口，谁在二号窗口，这个DP数组应该还是比较好想的，一般来说首先想到的的就是一个三位数的数组$F[i][j][k]$,表示前i个人，j个人在1号窗口，k个人在2号窗口吃完饭的最早时间。<br>而显然我们可以看到k = i - j，于是我们省下来一维。<br>然后怎么转移呢，首先可以考虑维护一个打饭时间前缀和Sum[]，对于第i个人，只有两种方案可以转移，就是1号窗口和2号窗口，分别是这样的：</p><script type="math/tex; mode=display">Dp[i][j] = min(Dp[i][j], max(Dp[i - 1][j - E[i].X], j + E[i].Y)) ;</script><p>这个玩意是什么意思呢？<br>就是说，我们在这个转移之中需要考虑第i个人和第i - 1个人的打饭和吃饭时间。<br>目前，第i - 1个人刚刚打完饭去吃饭，然后第i个人来打饭，打完饭之后吃饭，然后这两个人的回合结束，那么结束时间以谁为准呢？<br>当然是时间长的那个，那么我们那就比较第i - 1个人的吃饭时间，和第i个人的打饭时间+吃饭时间，取最优。<br>对于上面那个式子，$Dp[i][j] = Dp[i - 1][j - E[i].X]$时就是说i - 1赢过了i，那么就没有任何影响，但是当$Dp[i][j] = j + E[i].Y$的时候代表i赢过了i - 1，于是需要相应的变换。<br>然后我们如上就等到第二号窗口的状态转移方程：</p><script type="math/tex; mode=display">Dp[i][j] = min(Dp[i][j], max(Dp[i - 1][j], Sum[i] - j + E[i].Y)) ;</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">210</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">210</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">int</span> N, Tot1, Tot2, Sum[MAXN], Dp[MAXN][MAXN * MAXM], Ans = INF ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> X, Y ;</span><br><span class="line">&#125;E[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">CMP</span><span class="params">(Person A, Person B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> A.Y &gt; B.Y ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) E[i].X = Read(), E[i].Y = Read() ;</span><br><span class="line">sort(E + <span class="number">1</span> , E + N + <span class="number">1</span>, CMP) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">Sum[i] = Sum[i - <span class="number">1</span>] + E[i].X ;</span><br><span class="line"><span class="built_in">memset</span>(Dp, <span class="number">127</span>, <span class="keyword">sizeof</span>(Dp)) ;</span><br><span class="line">Dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= Sum[i] ; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (j &gt;= E[i].X) Dp[i][j] = min(Dp[i][j], max(Dp[i - <span class="number">1</span>][j - E[i].X], j + E[i].Y)) ;</span><br><span class="line">Dp[i][j] = min(Dp[i][j], max(Dp[i - <span class="number">1</span>][j], Sum[i] - j + E[i].Y)) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= Sum[N] ; i ++)</span><br><span class="line">Ans = min(Ans, Dp[N][i]) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      目前有N个人在两个窗口打饭，而每个人的打饭时间和吃饭时间不一样，一个人在打饭的时候在她后面的人都需要等待。请求出一个最快的方案使所有人打完饭并且全部吃完。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="贪心" scheme="http://Yeasion.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>[Uva12169]Disgruntled Judge</title>
    <link href="http://Yeasion.github.io/2019/10/01/Uva12169-Disgruntled-Judge/"/>
    <id>http://Yeasion.github.io/2019/10/01/Uva12169-Disgruntled-Judge/</id>
    <published>2019-10-01T11:01:17.000Z</published>
    <updated>2019-11-11T11:54:40.536Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://uva.onlinejudge.org/external/121/p12169.pdf" target="_blank" rel="noopener">Link</a></p><p>这个题没有那么麻烦，实际上来说是有一些奇怪的，因为在你听完之后你会感到这个题真的是非常非常的简单。<br>怎么说呢，由上面那个递推公式：</p><script type="math/tex; mode=display">X_i = (A \times x_(i - 1) + B) ~ mod ~ 10001</script><p>那么一定有<br>$X_2 = (A \times X_1 + B) ~ mod ~ 10001$<br>$X_3 = (A \times X_2 + B) ~ mod ~ 10001$<br>那么显然我们可以把这两个式子合起来，也就是：</p><script type="math/tex; mode=display">X_3 = (A \times ((A \times X_1 + B) ~ mod ~ 10001) _ B) ~ mod ~ 10001</script><p>化简一下：</p><script type="math/tex; mode=display">B = \frac{X_3 - A ^ 2 X_1}{A + 1}</script><p>那么假设我们知道了A，因为我们一定知道$X_1$, $X_3$，就可以根据上面这个式子直接知道B，那么转而来看A的数据范围，只有1000，也就是说假设我只是简单地枚举A时间也是够的。<br>于是我们枚举A然后推出B，然后就可以在$O(TA)$的时间复杂度内取得可行解。<br>当然在处理的时候我们仍然需要考虑到逆元。<br>至于如何判断该解可行，你只需要奇偶一起推，当你推出来的奇数序号的数和输入有悖时，这个A就是不可行的咯。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">10010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Mod = <span class="number">10001</span> ;</span><br><span class="line">LL T, B, X[MAXN], F = <span class="number">1</span>, Y[MAXN], Inv[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Exgcd</span><span class="params">(LL A, LL B, LL &amp; X, LL &amp; Y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! B) &#123; X = <span class="number">1</span>, Y = <span class="number">0</span> ; <span class="keyword">return</span> A ; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">LL Ans = Exgcd(B, A % B, X, Y) ;</span><br><span class="line">LL Tmp = X ; X = Y ; Y = Tmp - (A / B) * Y ;</span><br><span class="line"><span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Init</span><span class="params">(LL A)</span> </span>&#123;</span><br><span class="line">    LL X, Y ;</span><br><span class="line">    LL Tmp = Exgcd(A, Mod, X, Y) ;</span><br><span class="line">    X /= Tmp ; X = (X % Mod + Mod) % Mod ;</span><br><span class="line">    <span class="keyword">return</span> X ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">T = Read() ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= <span class="number">10001</span> ; i ++) Inv[i] = Init(i) ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= <span class="number">2</span> * T ; i += <span class="number">2</span>) X[i] = Read() ;</span><br><span class="line">Y[<span class="number">1</span>] = X[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">for</span> (LL A = <span class="number">0</span> ; A &lt;= <span class="number">10001</span> ; A ++) &#123;</span><br><span class="line">F = <span class="number">1</span> ;</span><br><span class="line">        B = ((X[<span class="number">3</span>] - A * A *X[<span class="number">1</span>]) % Mod + Mod) % Mod ;</span><br><span class="line">        B = B * Inv[A + <span class="number">1</span>] % Mod ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">2</span> ; i &lt;= <span class="number">2</span> * T ; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">Y[i] = (A * Y[i - <span class="number">1</span>] + B) % <span class="number">10001</span> ;</span><br><span class="line"><span class="keyword">if</span> (Y[i] != X[i]) &#123;</span><br><span class="line">F = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">break</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span></span><br><span class="line">Y[i] = (A * Y[i - <span class="number">1</span>] + B) % <span class="number">10001</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (F == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">2</span> ; i &lt;= <span class="number">2</span> * T ; i += <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Y[i]) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      给出递推公式为 $$ X_i = (A \times x_{i - 1} + B) ~ mod ~ 10001 $$的序号数为奇数的序列(T)，求出一个符合条件的A, B，并且求出其序号数为偶数的序列(T)，输出这个序列。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Uva" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/Uva/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://Yeasion.github.io/2019/09/27/Contest%20Nowcoder1090%20-%20TG%20Months%2012/"/>
    <id>http://Yeasion.github.io/2019/09/27/Contest Nowcoder1090 - TG Months 12/</id>
    <published>2019-09-27T13:30:00.000Z</published>
    <updated>2019-11-11T11:52:34.355Z</updated>
    
    <content type="html"><![CDATA[<h3 id="T1-小w的进制转换"><a href="#T1-小w的进制转换" class="headerlink" title="T1 小w的进制转换"></a>T1 <a href="https://ac.nowcoder.com/acm/contest/1090/A" target="_blank" rel="noopener">小w的进制转换</a></h3><blockquote><p>小$w$在将一个$10$进制数转换为二进制数的时候，不小心将“$0$”和“$1$”搞混了，也就是说本来该输出$1$的时候他输出了$0$，本来该输出0的时候他又输出了$1$。而他在输出答案的时候，又将输出的左右顺序搞混了。举个例子：小$w$将$6$转换为二进制，本来$6$的二进制表示为$110$，但是小$w$转换成了$001$，输出时又倒了过来变成$100$。现在假设评测姬中的评测数据是$1,2,3,4,5,6…n$也就是从$1$到$n$，问小$w$能$AC$其中的多少组测试案例？  </p></blockquote><p>这个东西是一个很纯的进制题，题目大意就是计数合法的串，满足各位异或1之后调转整个序列使得与原序列相同。也就是让你求“反对称01串”的个数。显然奇数长度的串是不会合法的，那么考虑偶数长度的串，推一推样例可以发现第$N$个符合长度的串就是$N$的二进制接上$N$的反对称串，熟悉位运算的话实际上就是一个模拟题，思维难度不大，就是看你能不能掌握位运算了。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Half (Len &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">110</span> ;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line">LL T, N, A[MAXN], Len, Old, Ans ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">T = Read() ; <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">N = Read() ; Old = N ; Len = <span class="number">0</span>, Ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (Old)  &#123;</span><br><span class="line">LL X = Old % <span class="number">2</span> ;</span><br><span class="line"><span class="keyword">if</span> (X == <span class="number">1</span>) A[++ Len] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> A[++ Len] = <span class="number">0</span> ;</span><br><span class="line">Old &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Half ; i ++)</span><br><span class="line">swap(A[i], A[Len - i + <span class="number">1</span>]) ;</span><br><span class="line"><span class="keyword">if</span> (Len &amp; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Half ; i ++)</span><br><span class="line">Ans += <span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= (Half - <span class="number">1</span>) ; i ++)</span><br><span class="line">Ans += <span class="number">1</span> &lt;&lt; i - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span> ; i &lt;= Half ; i ++)</span><br><span class="line"><span class="keyword">if</span> (A[i]) Ans += <span class="number">1</span> &lt;&lt; (Half - i) ;</span><br><span class="line">Old = <span class="number">0</span> ; LL Old2 = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Half ; i ++)</span><br><span class="line">Old = (Old &lt;&lt; <span class="number">1</span>) + A[i] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Half ; i &gt;= <span class="number">1</span> ; i --)</span><br><span class="line">Old2 = (Old2 &lt;&lt; <span class="number">1</span>) - A[i] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> ((Old &lt;&lt; Half) + Old2 &lt;= N)</span><br><span class="line">Ans ++ ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T2-小doge的快乐阳光跑"><a href="#T2-小doge的快乐阳光跑" class="headerlink" title="T2 小doge的快乐阳光跑"></a>T2 <a href="https://ac.nowcoder.com/acm/contest/1090/B" target="_blank" rel="noopener">小doge的快乐阳光跑</a></h3><blockquote><p>每次开始阳光跑，会在n个点里随机生成好多点位，并且需要按照点位顺序跑. </p><p><strong>当且仅当，阳光跑随机生成的点位序列（注意顺序）是你跑步序列的一个子序列时，你完成阳光跑。</strong>  </p><p>某一个序列的子序列指的是，保留该序列的顺序并删除一些元素或者不进行删除后的结果。 </p><p>小$doge$是一个乐于助人的好孩子，他常常帮助别人跑步。  </p><p>这天，小$doge$想要完成自己的阳光跑并且顺便帮助小$w$一起完成即一个人完成两人的任务，并且两个人的任务是独立的，小$doge$有$a$个点位，小$w$有$b$个点位。小$doge$想要最效率的跑法，所以他想知道他最少要跑多远。小$doge$可以选择任何一个点出发。  </p><p>对于阳光跑的要求，我们如下定义：有$n$个有顺序的点位$a_1到a_n$，想要完成阳光跑，必须按照顺序依次经过每个点位，并且在到达前一个点位后到达下一个点位才有效。</p></blockquote><p>搬过来的题解里面的题意简化：<strong>给一张图，求一个权值和路径最小的移动序列，使得移动序列包含两个给定的子序列。</strong>（早这样说多好</p><p>这题很显然你应该求一个最短路，想用$Floyed$的大可不必了，数据范围对于$A$和$B$来说只有$100$，所以我们可以直接对于每一个$A$和$B$中的点为起点跑一遍$SPFA$，时间上是没有问题的。现在有了$D[i][j]$之后我们就可以进行$Dp$了，设$Dp[i][j][0/1]$，表示当前完成了$A$的第$i$位和$B$的第$j$位，然后$0$为停留在$A$路径上，$1$为停留在$B$路径上。转移方程还是需要推一推的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dp[i][j][<span class="number">0</span>] = min(Dp[i][j][<span class="number">0</span>], Dp[i - <span class="number">1</span>][j][<span class="number">0</span>] + D[La[i - <span class="number">1</span>]][La[i]]) ;</span><br><span class="line">Dp[i][j][<span class="number">0</span>] = min(Dp[i][j][<span class="number">0</span>], Dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + D[Lb[j]][La[i]]) ;</span><br><span class="line">Dp[i][j][<span class="number">1</span>] = min(Dp[i][j][<span class="number">1</span>], Dp[i][j - <span class="number">1</span>][<span class="number">1</span>] + D[Lb[j - <span class="number">1</span>]][Lb[j]]) ;</span><br><span class="line">Dp[i][j][<span class="number">1</span>] = min(Dp[i][j][<span class="number">1</span>], Dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + D[La[i]][Lb[j]]) ;</span><br></pre></td></tr></table></figure><p>看起来非常的整齐（嗯</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">1010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">10010</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXA = <span class="number">110</span> ;</span><br><span class="line"><span class="keyword">const</span> LL INF = <span class="number">0x7fffffff</span> ;</span><br><span class="line">LL N, M, H[MAXN], Tot, A, B, Dp[MAXA][MAXN][<span class="number">2</span>] ;</span><br><span class="line">LL La[MAXN], Lb[MAXN], D[MAXN][MAXN], Ans = <span class="number">0</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">LL F, T, L, Next ;</span><br><span class="line">&#125;E[MAXM &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">bool</span> Vis[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(LL F, LL T, LL L)</span> </span>&#123;</span><br><span class="line">E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ;</span><br><span class="line">E[Tot].Next = H[F] ; H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa</span><span class="params">(LL F)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;LL&gt; Q ;</span><br><span class="line"><span class="built_in">memset</span>(Vis, <span class="number">0</span>, <span class="keyword">sizeof</span> (Vis)) ;</span><br><span class="line">D[F][F] = <span class="number">0</span> ; Vis[F] = <span class="number">1</span> ; Q.push(F) ;</span><br><span class="line"><span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">LL Now = Q.front() ; Q.pop() ; Vis[Now] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = H[Now] ; i ; i = E[i].Next)</span><br><span class="line"><span class="keyword">if</span> (D[F][E[i].T] &gt; D[F][Now] + E[i].L) &#123;</span><br><span class="line">D[F][E[i].T] = D[F][Now] + E[i].L ;</span><br><span class="line"><span class="keyword">if</span> (! Vis[E[i].T])</span><br><span class="line">Q.push(E[i].T), Vis[E[i].T] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">LL X = Read(), Y = Read(), Z = Read() ;</span><br><span class="line">Add(X, Y, Z) ; Add(Y, X, Z) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(D, <span class="number">127</span>, <span class="keyword">sizeof</span> (D)) ;</span><br><span class="line">A = Read() ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= A ; i ++)  La[i] = Read(), Spfa(La[i]) ;</span><br><span class="line">B = Read() ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= B ; i ++)  Lb[i] = Read(), Spfa(Lb[i]) ;</span><br><span class="line"><span class="built_in">memset</span>(Dp, <span class="number">127</span>, <span class="keyword">sizeof</span> (Dp)) ;</span><br><span class="line">Dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = Dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++) D[<span class="number">0</span>][i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= A ; i ++)</span><br><span class="line">Dp[i][<span class="number">0</span>][<span class="number">0</span>] = Dp[i - <span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] + D[La[i - <span class="number">1</span>]][La[i]] ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= B ; i ++)</span><br><span class="line">Dp[<span class="number">0</span>][i][<span class="number">1</span>] = Dp[<span class="number">0</span>][i - <span class="number">1</span>][<span class="number">1</span>] + D[Lb[i - <span class="number">1</span>]][Lb[i]] ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= A ; i ++)</span><br><span class="line"><span class="keyword">for</span> (LL j = <span class="number">1</span> ; j &lt;= B ; j ++) &#123;</span><br><span class="line">Dp[i][j][<span class="number">0</span>] = min(Dp[i][j][<span class="number">0</span>], Dp[i - <span class="number">1</span>][j][<span class="number">0</span>] + D[La[i - <span class="number">1</span>]][La[i]]) ;</span><br><span class="line">Dp[i][j][<span class="number">0</span>] = min(Dp[i][j][<span class="number">0</span>], Dp[i - <span class="number">1</span>][j][<span class="number">1</span>] + D[Lb[j]][La[i]]) ;</span><br><span class="line">Dp[i][j][<span class="number">1</span>] = min(Dp[i][j][<span class="number">1</span>], Dp[i][j - <span class="number">1</span>][<span class="number">1</span>] + D[Lb[j - <span class="number">1</span>]][Lb[j]]) ;</span><br><span class="line">Dp[i][j][<span class="number">1</span>] = min(Dp[i][j][<span class="number">1</span>], Dp[i][j - <span class="number">1</span>][<span class="number">0</span>] + D[La[i]][Lb[j]]) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, min(Dp[A][B][<span class="number">0</span>], Dp[A][B][<span class="number">1</span>])) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T3-区间异或和异或区间最大值异或区间最小值"><a href="#T3-区间异或和异或区间最大值异或区间最小值" class="headerlink" title="T3 区间异或和异或区间最大值异或区间最小值"></a>T3 <a href="https://ac.nowcoder.com/acm/contest/1090/C" target="_blank" rel="noopener">区间异或和异或区间最大值异或区间最小值</a></h3><blockquote><p>小$w$学会了$RMQ$算法，他现在可以求出一个给定数组某一段子区间的最大值，最小值。在这之前，他也学会了前缀和，并且他知道前缀和可以扩展到位运算求出区间异或和。 现在你给了他一个长度大小为$n$的数组，为了考察小$w$写$RMQ$以及前缀异或和的正确性，你要求他求出该数组的某一个子区间，记该子区间的异或和为$xorsum$，记该子区间的最大值为$max$，记该子区间的最小值为$min$，你要求使得$xorsum⊕max⊕min$最大。其中$⊕$为位运算异或操作。</p></blockquote><p>看起来就是一道很毒瘤的数据结构题，（从题目名字就看得出来好嘛</p><p>先考虑考虑部分分吧。首先我们得知道一个原理$A⊕B⊕B =A$，相当于一个数两次异或另一个数答案是不变的。那么对于答案所求就是去掉最大值和最小值之后的区间异或和。对于区间最大值和区间最小值我们可以使用$RMQ$进行维护，对于$Sumxor$我们可以使用前缀和进行维护，于是对于确定区间的求值就只$O(1)$的，我们枚举区间的左右端点，时间复杂度就是$O(N^2)$的。</p><p>但是出题人十分毒瘤，导致$O(N^2)$只能过$30\%$的点，这就有些不良心了。。</p><p>接下来想正解，发现这个序列实际上是可以用分治瞎搞进行维护的，对于该区间取中点$Mid$，然后考虑从左端点在$Mid$左侧，右端点在$Mid$右侧的所有子区间，它们有一个共性就是一定是由一个从$Mid$开始往左延伸的区间和从$Mid$开始往右延伸的区间拼接得到的（意会），对于这两个区间我们需要找到一个支持快速插入以及查询的数据结构来进行维护从$Mid$向左延伸的区间的贡献，之后再遍历往右的区间。</p><p>这样我们就处理完了所有左端点在$Mid$左侧，右端点在$Mid$右侧的子区间，那么之后直接递归计算$[L, Mid]和[Mid +1, R]$就可以了。</p><p>回想这个数据结构，我们发现字典树可以较好地解决这个问题，我们只需要将异或和放入字典树中，然后分类讨论：</p><ol><li>左侧区间提供最大值最小值</li><li>右侧区间提供最大值最小值</li><li>左侧区间提供最大值，右侧区间提供最小值</li><li>左侧区间提供最小值，右侧区间提供最大值</li></ol><p>并且，由于显而易见的是随着区间延伸最大值单调不减，最小值单调不升，所以我们枚举极值的时候有一个双单调性，因此可以考虑尺取法，之中对于以上四种情况分类讨论即可。</p><p>思维难度颇大，鄙人在考场上大致也只能想出来$O(N^2)$暴力做法。（没准还可以水一水特殊数据点？</p>]]></content>
    
    <summary type="html">
    
      牛客OI月赛12-提高组
    
    </summary>
    
      <category term="专题集训与赛事" scheme="http://Yeasion.github.io/categories/%E4%B8%93%E9%A2%98%E9%9B%86%E8%AE%AD%E4%B8%8E%E8%B5%9B%E4%BA%8B/"/>
    
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="进制" scheme="http://Yeasion.github.io/tags/%E8%BF%9B%E5%88%B6/"/>
    
      <category term="字典树" scheme="http://Yeasion.github.io/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>USACO18FEB-Making the Grade</title>
    <link href="http://Yeasion.github.io/2019/07/22/USACO08FEB-Making%20the%20Grade/"/>
    <id>http://Yeasion.github.io/2019/07/22/USACO08FEB-Making the Grade/</id>
    <published>2019-07-22T02:32:00.000Z</published>
    <updated>2019-11-11T11:54:28.522Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P2893" target="_blank" rel="noopener">Link</a><br>大概就是给你一段序列，然后让你对一些数做出一些调整，最后使得这个序列单调不升或者单调不减。显然是一个动态规划问题，而较为显然的是对于每一个数，要么不修改，要么就是修改成原来序列中的某一个数的值。<br>至于为什么，大家可以手推几组数据，或者说来看一下一个错误的贪心法。对于每一个数我们将它修改成相邻两个数中的差值最小的一个，然后就可以保证单调性。但是这样显然是不对的，因为它具有单调性，自己改变之后后面一个数修改的情况有可能也会发生改变。但是我们依然可以知道：数的修改一定存在于当前序列的数中这一点是没错的。<br>因此首先我们进行排序，那么原序列$A$最终肯定要变成这个排完序之后的序列$B$，于是我们就有了$DP$的思路。<br>设$Dp[i][j]$表示第$i$个数修改成$j$的最小花费，然后就有</p><script type="math/tex; mode=display">Dp[i][j] = min(Dp[i - 1][k] + abs(A[i] - B[j])) ;</script><p>加个单调队列就可以$O(N^2)$过了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">2010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">2010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1e9</span> ;</span><br><span class="line"><span class="keyword">int</span> N, Tall[MAXN], Old[MAXN], Dp[MAXN][MAXN], Q[MAXN], Ans = INF, T ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) </span><br><span class="line">        Tall[i] = Read(), Old[i] = Tall[i] ;</span><br><span class="line">    sort(Old + <span class="number">1</span>, Old + N + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) &#123;</span><br><span class="line">        T = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= N ; j ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (T &amp;&amp; Dp[i - <span class="number">1</span>][j] &lt; Dp[i - <span class="number">1</span>][Q[T]]) T -- ;</span><br><span class="line">            Q[++ T] = j ;</span><br><span class="line">            Dp[i][j] = Dp[i - <span class="number">1</span>][Q[<span class="number">1</span>]] + <span class="built_in">abs</span>(Tall[i] - Old[j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Ans = min(Ans, Dp[N][i]) ;</span><br><span class="line">    <span class="built_in">memset</span>(Dp, <span class="number">0</span>, <span class="keyword">sizeof</span> (Dp)) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)&#123;</span><br><span class="line">        T = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = N ; j &gt;= <span class="number">1</span> ; j --) &#123;</span><br><span class="line">            <span class="keyword">while</span> (T &amp;&amp; Dp[i - <span class="number">1</span>][j] &lt; Dp[i - <span class="number">1</span>][Q[T]]) T -- ;</span><br><span class="line">            Q[++ T] = j ;</span><br><span class="line">            Dp[i][j] = Dp[i - <span class="number">1</span>][Q[<span class="number">1</span>]] + <span class="built_in">abs</span>(Tall[i] - Old[j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) Ans = min(Ans, Dp[N][i]) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, Ans) ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      农夫约翰想改造一条路，原来的路的每一段海拔是$A_i$，修理后是$B_i$，花费$|A_i – B_i|$。我们要求修好的路是单调不升或者单调不降的。求最小花费。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="USACO" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/USACO/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>[USACO05DEC]布局</title>
    <link href="http://Yeasion.github.io/2019/05/26/USACO05DEC-%E5%B8%83%E5%B1%80/"/>
    <id>http://Yeasion.github.io/2019/05/26/USACO05DEC-布局/</id>
    <published>2019-05-26T08:34:50.000Z</published>
    <updated>2019-11-11T11:54:25.580Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P4878" target="_blank" rel="noopener">Link</a></p><p>又是一道差分约束新系统的裸题，直接上最短路就可以。<br>对于两个点之间的距离小于某个数，直接$Add(X, Y, Z)$就行。<br>对于两个点之间的距离大于等于某个数，直接$Add(Y, X, - Z)$就行。<br>但是这个题确实是有坑点的，就是这个图是有可能不连通的，因此你必须还得做一次判断，看这个图是否连通。<br>很简单，就是取一个新的节点0，然后把他和所有的节点连起来$Add(0, i, 0)$，然后$Spfa(0)$一次就可以了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">100010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">100000000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, ML, MD, Tot, H[MAXN], Num[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> F, T, L, Next ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T, <span class="keyword">int</span> L)</span> </span>&#123;</span><br><span class="line">E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ;</span><br><span class="line">E[Tot].Next = H[F] ; H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LS (Now &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RS ((Now &lt;&lt; 1) | 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Mid ((L + R) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E_Mid ((E[Now].L + E[Now].R) &gt;&gt; 1)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TREE</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> L, R, Sum, Tag ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Push_Up</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D[MAXN] ; <span class="keyword">bool</span> V[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa</span><span class="params">(<span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) D[i] = Inf, V[i] = <span class="literal">false</span>, Num[i] = <span class="number">0</span> ;</span><br><span class="line">D[S] = <span class="number">0</span> ; V[S] = <span class="literal">true</span> ; <span class="built_in">queue</span> &lt;<span class="keyword">int</span>&gt; Q ; Q.push(S) ;</span><br><span class="line"><span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> Now = Q.front () ; V[Now] = <span class="literal">false</span> ; Q.pop() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = H[Now] ; i ; i = E[i].Next)</span><br><span class="line"><span class="keyword">if</span> (D[E[i].T] &gt; D[Now] + E[i].L) &#123;</span><br><span class="line">D[E[i].T] = D[Now] + E[i].L ;</span><br><span class="line">Num[E[i].T] = Num[Now] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (Num[E[i].T] &gt;= N) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-1"</span>) ; <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (! V[E[i].T])</span><br><span class="line">V[E[i].T] = <span class="literal">true</span>, Q.push(E[i].T) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++) </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; E[i].F &lt;&lt; <span class="string">" "</span> &lt;&lt; E[i].T &lt;&lt; <span class="string">" "</span> &lt;&lt; E[i].Next &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">N = Read() ; ML = Read() ; MD = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">Add(<span class="number">0</span>, i, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= ML ; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> A = Read(), B = Read(), C = Read() ;</span><br><span class="line">Add(A, B, C) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= MD ; i ++) &#123;</span><br><span class="line"><span class="keyword">int</span> A = Read(), B = Read(), C = Read() ;</span><br><span class="line">Add(B, A, - C) ;</span><br><span class="line">&#125;</span><br><span class="line">Spfa(<span class="number">0</span>) ; Spfa(<span class="number">1</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (D[N] == Inf) <span class="built_in">printf</span>(<span class="string">"-2"</span>) ;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, D[N]) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      现在有$N$个点，有$M$个要求，如两个点之间的距离不能大于某个数或者两个点之间的距离不能小于某一个数之类的，问在满足所有条件下的$1$号与$N$号点的距离的最大值为多少。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="USACO" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/USACO/"/>
    
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="差分约束系统" scheme="http://Yeasion.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>[SCOI2011]糖果</title>
    <link href="http://Yeasion.github.io/2019/05/26/SCOI2011-%E7%B3%96%E6%9E%9C/"/>
    <id>http://Yeasion.github.io/2019/05/26/SCOI2011-糖果/</id>
    <published>2019-05-26T03:06:47.000Z</published>
    <updated>2019-11-11T11:53:56.769Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3275" target="_blank" rel="noopener">Link</a><br>一道非常好的差分约束系统的板子题，正好可以借此回顾一下差分约束的有关内容。<br>假设我们现在有N个方程，<br>$X_1 - X_2 \leq 0$<br>$X_1 - X_5 \leq 1$<br>$X_2 - X_5 \leq 1$<br>$X_3 - X_1 \leq 5$<br>$X_4 - X_1 \leq 4$<br>$X_4 - X_3 \leq - 1$<br>$X_5 - X_3 \leq - 3$<br>$X_5 - X_4 \leq - 3$<br>这样第一个方程组，我们当然可以解不等式组，但是如果我们要求电脑计算的话就需要一些方法，比如说<strong>最短路</strong><br>对于这道题来说，我们对于每一种情况。</p><ol><li>Add(X, Y, 0), Add(Y, X, 0) ;</li><li>Add(X, Y, 1) ;</li><li>Add(Y, X, 0) ;</li><li>Add(Y, X, 1) ;</li><li>Add(X, Y, 0) ;<br>并且还要特判一下当$Type = 2$ 或 $4$ 的时候，如果$X == Y$那么久一定是没有解的。<br>然后直接跑SPFA就是了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ; </span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">1000100</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">1000100</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inf = <span class="number">1000000000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LL N, M, H[MAXN], Tot, D[MAXN], INQ[MAXN], F, Num[MAXN] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">LL F, T, L, Next ;</span><br><span class="line">&#125;E[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(LL F, LL T, LL L)</span> </span>&#123;</span><br><span class="line">E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ;</span><br><span class="line">E[Tot].Next = H[F] ; H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Spfa</span><span class="params">(LL S)</span> </span>&#123;</span><br><span class="line"><span class="built_in">queue</span> &lt;LL&gt; Q ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> LL i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">D[i] = <span class="number">0</span>, INQ[i] = <span class="number">0</span>, Num[i] = <span class="number">0</span> ;</span><br><span class="line">Q.push(S) ; D[S] = <span class="number">0</span> , INQ[S] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">LL Now = Q.front() ; Q.pop() ; INQ[Now] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (Num[Now] == N - <span class="number">1</span>) <span class="keyword">return</span> - <span class="number">1</span> ; Num[Now] ++ ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> LL i = H[Now] ; i ; i = E[i].Next)</span><br><span class="line"><span class="keyword">if</span> (D[E[i].T] &lt; D[Now] + E[i].L) &#123;</span><br><span class="line">D[E[i].T] = D[Now] + E[i].L ;</span><br><span class="line"><span class="keyword">if</span> (! INQ[E[i].T])</span><br><span class="line">Q.push(E[i].T), INQ[E[i].T] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">long</span> <span class="keyword">long</span> Ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N ; i ++) Ans += D[i] ;</span><br><span class="line"><span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//freopen("testdata.in", "r", stdin) ;</span></span><br><span class="line">N = Read() ;  M = Read() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> LL i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">LL Type = Read(), X = Read(), Y = Read() ; </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Type == <span class="number">1</span>) Add(X, Y, <span class="number">0</span>), Add(Y, X, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (Type == <span class="number">2</span>) Add(X, Y, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (Type == <span class="number">3</span>) Add(Y, X, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">if</span> (Type == <span class="number">4</span>) Add(Y, X, <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (Type == <span class="number">5</span>) Add(X, Y, <span class="number">0</span>) ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (Type == <span class="number">2</span> || Type == <span class="number">4</span>)</span><br><span class="line"><span class="keyword">if</span> (X == Y)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"-1"</span>), <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> LL i = N ; i &gt;= <span class="number">1</span> ; i --)</span><br><span class="line">Add(<span class="number">0</span>, i, <span class="number">1</span>) ;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Spfa(<span class="number">0</span>)) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      幼儿园里面有$N$个小朋友分配糖果，现在有$K$个要求，求出满足所有要求的所需的最小的糖果数。如果不能满足所有小朋友的需求，输出-1。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="差分约束系统" scheme="http://Yeasion.github.io/tags/%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>矩阵树定理及其应用（未完成）</title>
    <link href="http://Yeasion.github.io/2019/04/04/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
    <id>http://Yeasion.github.io/2019/04/04/矩阵树定理及其应用/</id>
    <published>2019-04-04T11:25:59.000Z</published>
    <updated>2019-11-11T11:55:39.259Z</updated>
    
    <content type="html"><![CDATA[<p>这个东西首次出现在周冬的国家集训队论文里面，解决的问题叫做生成树计数问题。<br>顾名思义，就是让你求一张无向图中生成树的个数。<br>首先我们要知道三个概念。</p><ol><li>邻接矩阵A<br>这个东西不用我说了吧，就是对于每一条边$Edge_{ij}$，矩阵的$i$行$j$列和$j$行$i$列设为1，其他设为0。</li><li>度数矩阵D<br>啥意思呢，就是将每一个点的度数，其中对于每一个不相等的$i,j$有$D[i][j] = 0$</li><li>基尔霍夫矩阵C<br>$C = D - A$</li></ol><p>而Matrix-Tree定理就是说这个无向图的生成树个数就等于基尔霍夫矩阵的任意一个$N - 1$阶主子式的行列式的绝对值。</p>]]></content>
    
    <summary type="html">
    
      矩阵树定理，用以解决一个图上的生成树的个数，出自周冬的国家队论文。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="矩阵树定理" scheme="http://Yeasion.github.io/tags/%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86/"/>
    
      <category term="最小生成树" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>卢卡斯定理与扩展卢卡斯定理</title>
    <link href="http://Yeasion.github.io/2019/04/04/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"/>
    <id>http://Yeasion.github.io/2019/04/04/卢卡斯定理与扩展卢卡斯定理/</id>
    <published>2019-04-04T09:48:15.000Z</published>
    <updated>2020-01-24T10:42:57.453Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>卢卡斯定理要解决的问题很简单：</p><script type="math/tex; mode=display">C_n^m ~mod~ p</script><p>如果$p$规定为质数，那么就用卢卡斯定理解决，否则就是扩展卢卡斯定理。<br>洛谷上两个模板题都有 <a href="https://www.luogu.org/problemnew/show/P3807" target="_blank" rel="noopener">Lucas</a> <a href="https://www.luogu.org/problemnew/show/P4720" target="_blank" rel="noopener">ExLucas</a></p><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><p>如果你不知道前置的知识的话，最好还是去系统学习一下。</p><h4 id="1-乘法逆元"><a href="#1-乘法逆元" class="headerlink" title="1. 乘法逆元"></a>1. 乘法逆元</h4><blockquote><p>若$Ax \equiv 1 (mod~p)$且$A$与$p$互质，则称$A$的$mod~p$意义下的乘法逆元为$X$</p></blockquote><p>关于求逆元：<br>因为$(a,p) = 1$<br>所以$a^{p-1} \equiv 1 (mod~p)$<br>所以$a \times a ^{p - 2} \equiv 1 (mod~p)$<br>所以$m!(n - m)!$的逆元为$(m!(n - m)!) ^{p - 2}$<br>直接快速幂就可以了。</p><h4 id="2-扩展欧几里得"><a href="#2-扩展欧几里得" class="headerlink" title="2.扩展欧几里得"></a>2.扩展欧几里得</h4><blockquote><p>扩展欧几里得用来在求得$gcd(a,b)$的同时，找出整数$x,y$使其满足$ax + by = gcd(a,b)$</p></blockquote><h4 id="3-费马小定理"><a href="#3-费马小定理" class="headerlink" title="3.费马小定理"></a>3.费马小定理</h4><blockquote><p>$a^(p-1) \equiv 1 (mod~p)$。</p></blockquote><h4 id="4-中国剩余定理"><a href="#4-中国剩余定理" class="headerlink" title="4.中国剩余定理"></a>4.中国剩余定理</h4><p>还请移步博客<a href="https://yeasion.github.io/2019/02/15/%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86ExCrt/">欧几里得与扩展中国剩余定理Excrt</a></p><h3 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h3><p>证明过程：<br>首先根据组合数的只是我们可以很显然推出</p><script type="math/tex; mode=display">C_p^i \equiv \frac pi C_{p-1}^{i-1} \equiv 0 (mod~p)</script><p>然后根据二项式定理得出：</p><script type="math/tex; mode=display">(1 + x)^p \equiv \sum_{i=0}^p C_p^0 X^i \equiv C_p^o1^pX^0 + C^p_p1^0X^p \equiv 1 + x^p (mod~p)</script><p>然后我们继续从二项式定理推出：</p><script type="math/tex; mode=display">C^b_a \equiv \prod_{i = 0}^p0 C_{a_ip^i}^{b_ip^i} (mod~p)</script><p>上式也就是所谓的卢卡斯定理，这玩意的用处就在于下面这个递推式：</p><script type="math/tex; mode=display">Lucas(n,m,p) = CC_{m \% p}^{n \% p} \times Lucas(\frac np, \frac mp, p</script><p>其中$Lucas(x,0,p) = 1$且$CC_m^n = (C_m^n)^(p-2) ~mod ~p$<br>实际上就是一个费马小定理和乘法逆元。<br>根据这个东西就可以很快地求出来上面的问题了。<br>如果你看不大懂，那就只需要记结论。。。。</p><script type="math/tex; mode=display">C_m^n ~mod~ p = (C_{m / p}^{n / p} ~mod~p) \times (C^{n ~mod~ p}_{m ~mod~ p} ~mod~p)~mod~p</script><p>然后直接递归调用$C_{m~mod~p}^{n~mod~p} ~mod~p$就可以了。<br>对于$C_m^n$的除法取模就需要用到逆元了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span> ;</span><br><span class="line">LL N, M, P, X[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line"><span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">QuickPow</span><span class="params">(LL A, LL B)</span> </span>&#123;</span><br><span class="line">LL Ans = <span class="number">1</span> ;<span class="keyword">if</span> (! B) <span class="keyword">return</span> <span class="number">1</span> % P ;</span><br><span class="line"><span class="keyword">while</span> (B) &#123;</span><br><span class="line"><span class="keyword">if</span> (B &amp; <span class="number">1</span>) Ans = Ans * A % P ;</span><br><span class="line">A = A * A % P, B &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">&#125;<span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span><span class="params">(LL A, LL B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (B &gt; A) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">return</span> (X[A] * QuickPow(X[B], P - <span class="number">2</span>)) % P * QuickPow(X[A - B], P - <span class="number">2</span>) % P ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Lucas</span><span class="params">(LL A, LL B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (! B) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> (C(A % P, B % P) * Lucas(A / P, B / P)) % P ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> T = Read() ; <span class="keyword">while</span> (T --) &#123;</span><br><span class="line">N = Read(), M = Read(), P = Read() ;</span><br><span class="line">X[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= P ; i ++) </span><br><span class="line">X[i] = (X[i - <span class="number">1</span>] * i) % P ;</span><br><span class="line">LL Ans = Lucas(N + M, N) ; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;<span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩展卢卡斯定理"><a href="#扩展卢卡斯定理" class="headerlink" title="扩展卢卡斯定理"></a>扩展卢卡斯定理</h3><p>令$P = \prod p_i^{c_i}$<br>假设我们知道$C_n^m ~mod~p_i^{c_i}$就可以直接上$Crt$，但是我们并不知道。（泪目<br>怎么求呢？<br>对于$C^n_m = \frac{n!}{(n-m)!m!}$<br>我们可以阶乘的变换。<br>假设我们现在要求$19! % 3$<br>我们将$1 \times…\times 19$中所有$3$的倍数拿出来合并。<br>那么我们就得到$\lfloor \frac{19}{3} \rfloor$个满足项，然后除以$3$之后，就得到$\lfloor \frac{19}{3} \rfloor !$,这一部分不好算，我们直接递归下去。<br>然后对于其他的项，可以看出来他们具有小于$3^k$的循环节这种东西，就可以暴力。<br>然后时间复杂度就很可观了。</p>]]></content>
    
    <summary type="html">
    
      $$C_n^m ~mod~ p$$ 对于上述的式子，卢卡斯定理($Lucas$)用以解决$p$为质数的情况，而扩展卢卡斯定理$ExLucas$则用以解决$p$为任何数的形式。时间复杂度取决于$p$的大小，在$p$比较小的时候可以使用卢卡斯定理解决组合数快速求值问题。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数论" scheme="http://Yeasion.github.io/tags/%E6%95%B0%E8%AE%BA/"/>
    
      <category term="Lucas" scheme="http://Yeasion.github.io/tags/Lucas/"/>
    
      <category term="ExLucas" scheme="http://Yeasion.github.io/tags/ExLucas/"/>
    
      <category term="扩展欧几里得" scheme="http://Yeasion.github.io/tags/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    
  </entry>
  
  <entry>
    <title>TSP-旅行商问题</title>
    <link href="http://Yeasion.github.io/2019/03/19/TSP-%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98/"/>
    <id>http://Yeasion.github.io/2019/03/19/TSP-旅行商问题/</id>
    <published>2019-03-19T09:38:39.000Z</published>
    <updated>2019-11-11T11:54:21.545Z</updated>
    
    <content type="html"><![CDATA[<p>$TSP$是一个“组合优化问题”，同时也是数学领域中一个较为著名的$NPC$问题。</p><blockquote><p>现在的算法都没有办法在确定型机器上在多项式时间内求出最优解，但是有办法在多项式时间内求出一个较优解。</p></blockquote><p>可以发现这个问题并不是真正意义上的$NPC$，而是属于一个$NP-Hard$，因此可以求出较优解。<br>这个问题的实质就是求一个带权无向图中，找一个权值最小的哈密尔顿回路，在给出的节点数目非常小的情况下，我们可以考虑状压$DP$。<br>当然，我们知道没有什么算法是暴力搜索解决不了的，在没有十分优的解决方案的时候没我们自然想到枚举全排列。<br>但是这显然白搭，因为$O(N!)$的时间复杂度即使点数很小也是很难接受的。<br>于是考虑压缩状态。对于一种方案，我们用一个$N$位的二进制数表示，其中$1$表示第$i$个点被经过，若是$0$则是没有经过。<br>我们设$Dp[i][j]$表示路径状态为$i$，当前处于$j$节点的最短路径。<br>假设我们现在有一个$Dp[i][j]$，那么我们可以枚举一个点$k$，因为当前的$j$是刚刚经过，因此上一个状态一定没有经过$j$这个点。因此在上一个时刻的点的状态的第$j$位就一定是$0$，状态就是$i \times (1 &lt;&lt; k)$。<br>并且从$k$走到$j$需要$L[i][j]$（也就是两点之间的最短路），于是我们取遍所有的$k$取最小值即可。<br>得出递推关系式：</p><script type="math/tex; mode=display">Dp[i][j] = min(Dp[i][j], Dp[i * (1 << j)][k] + L[k][j])</script><p>目标的状态显然是$Dp[(1 &lt;&lt; N) - 1][N - 1]$（因为起点是$0$）。</p><p>以上需要用到不少的位运算，如果不是很懂的还请去学学为好。<br>下面给出的是$1 \leq N \leq 20$的数据，$L[i][j]$是两个点之间的距离。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">21</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">21</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, Dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][MAXN], L[MAXN][MAXN], Ans = <span class="number">10000000</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Min</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B)</span> </span>&#123;<span class="keyword">return</span> (A &lt; B) ? A : B ;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ;</span><br><span class="line">    <span class="built_in">memset</span>(Dp, <span class="number">127</span>, <span class="keyword">sizeof</span>(Dp)) ;</span><br><span class="line">    Dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; j ++)</span><br><span class="line">        L[i][j] = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; (<span class="number">1</span> &lt;&lt; N) ; i += <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; N ; j ++)</span><br><span class="line">        <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; N ; k ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == k || !((i &gt;&gt; k) &amp; <span class="number">1</span>)) <span class="keyword">continue</span> ;</span><br><span class="line">            Dp[i][j] = Min(Dp[i][j], Dp[i ^ (<span class="number">1</span> &lt;&lt; j)][k] + L[k][j]) ;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; N ; i ++)</span><br><span class="line">        Ans = Min(Ans, Dp[(<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span>][i] + L[i][<span class="number">0</span>]) ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Ans) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      $TSP$问题，即旅行商问题，可以被证明具有$NPC$计算复杂度。假设有一个旅行的商人要拜访$N$个城市，他必须选择要走的路径，其限制是每个城市只能拜访一次，并且最后要回到原点。要求最小路径长度和。
    
    </summary>
    
      <category term="算法" scheme="http://Yeasion.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://Yeasion.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="状态压缩" scheme="http://Yeasion.github.io/tags/%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9/"/>
    
      <category term="NPC问题" scheme="http://Yeasion.github.io/tags/NPC%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>[SCOI2010]生成字符串</title>
    <link href="http://Yeasion.github.io/2019/03/17/SCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://Yeasion.github.io/2019/03/17/SCOI2010-生成字符串/</id>
    <published>2019-03-17T01:22:08.000Z</published>
    <updated>2019-11-11T11:53:53.914Z</updated>
    
    <content type="html"><![CDATA[<p>这题首先就得有一个画坐标系的想法，这很智障，我一开始也没有想出来。<br>我们设$X = Num[1] + Num[0]$, $Y = Num[1] - Num[0]$<br>也就是将1的个数加上0的个数设为X横坐标，把其和设为纵坐标。<br>稍微画一下图，如果我们从原点开始向右上方走(y = x)，那么就是$X + 1, Y + 1$，表示我们选择了1,，如果朝右下角走$y = - x$那么就是$X + 1, Y - 1$，表示我们选择了0。<br>很显然最后的方案数就是从原点走到$(N + M),(N - M)$节点。<br>因为无论如何$X$都是加一，所以步数一定是$N + M$步，而我们要选出$M$次向下走，方案数就是$C^{N +M} _M$。<br>当然，这是没有考虑限制情况。题目要求$1$的个数不能超过$0$的个数。发现也就是不能超过$y = - 1$这条直线。而经过直线的方案数就是$C^{N +M} _{M - 1}$<br>然后最后的答案就是</p><script type="math/tex; mode=display">C^{N +M} _M - C^{N +M} _{M - 1}</script><p>这种东西直接预处理前缀积然后逆元一下就好了…<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> LL MAXN = <span class="number">1000010</span> &lt;&lt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">const</span> LL MAXM = <span class="number">1000010</span> &lt;&lt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"><span class="keyword">const</span> LL Mod = <span class="number">20100403</span> ;</span><br><span class="line"></span><br><span class="line">LL N, M, Fac[MAXN], Inv[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LL X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">QUCIK_POW</span><span class="params">(LL X, LL Y)</span> </span>&#123;</span><br><span class="line">    LL Ans = <span class="number">1</span> ; <span class="keyword">while</span> (Y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Y &amp; <span class="number">1</span>) Ans = Ans * X % Mod ;</span><br><span class="line">        X = X * X % Mod ; Y &gt;&gt;= <span class="number">1</span> ;</span><br><span class="line">    &#125;   <span class="keyword">return</span> Ans ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">C</span><span class="params">(LL X, LL Y)</span> </span>&#123;</span><br><span class="line">    LL U = Fac[X] * Inv[Y] % Mod ;</span><br><span class="line">    <span class="keyword">return</span> U * Inv[X - Y] % Mod ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; M = Read() ; Fac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">1</span> ; i &lt;= N + M ; i ++)</span><br><span class="line">        Fac[i] = Fac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line">    Inv[N + M] = QUCIK_POW(Fac[N + M], Mod - <span class="number">2</span>) ;   </span><br><span class="line">    <span class="keyword">for</span> (LL i = N + M - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i --)</span><br><span class="line">        Inv[i] = Inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>) % Mod ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, (C(N + M, M) - C(N + M, M - <span class="number">1</span>) + Mod) % Mod) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      生成一个由$N$个$1$和$M$个$0$组成的字符串，要求任意前缀的$1$的个数不能少于$0$的个数。求满足该条件的字符串的个数。
    
    </summary>
    
      <category term="题解" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="各省省选" scheme="http://Yeasion.github.io/categories/%E9%A2%98%E8%A7%A3/%E5%90%84%E7%9C%81%E7%9C%81%E9%80%89/"/>
    
    
      <category term="组合数学" scheme="http://Yeasion.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"/>
    
      <category term="字符串" scheme="http://Yeasion.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
      <category term="逆元" scheme="http://Yeasion.github.io/tags/%E9%80%86%E5%85%83/"/>
    
  </entry>
  
  <entry>
    <title>[USACO15JAN]草鉴定</title>
    <link href="http://Yeasion.github.io/2019/03/12/USACO15JAN-%E8%8D%89%E9%89%B4%E5%AE%9A/"/>
    <id>http://Yeasion.github.io/2019/03/12/USACO15JAN-草鉴定/</id>
    <published>2019-03-12T09:15:29.000Z</published>
    <updated>2019-11-11T11:54:35.915Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problemnew/show/P3119" target="_blank" rel="noopener">Link</a><br>一道及其智障的题目，关键在于博主调这个智障题调了基本一天…<br>其实不是很难想，我们先缩一下点，把新图建出来，当然是因为要保证图无环，要不然下面就没法做了。<br>这里实际上要建两个新图，一个正着的，还有一个反图。<br>干什么用的呢？主要就是因为题目要求回到原点，这个玩意怎么实现的问题。<br>首先这个路经肯定是一个圈，然后我们就可以找一下这个圈的一个“转折节点”，实际上就是枚举一个中间节点$X$，然后吧路经分为$1 -&gt; X$和$X -&gt; 1$两个链，这就需要我们建一个反图来进行实现。<br>因为题目要求经过的点最多，因此我们就跑两个最长路。<br>第一个最长路记录正图的$1 - &gt; Point_i$节点为$D[i]$。<br>第二个最长路记录反图的$Point_i - &gt; 1$节点为$D2[i]$。（实际上也是从1节点出发）<br>然后对于这个逆行的边我们如下处理：<br>首先在$Tarjan$的时候进行一个记录$C[i]$表示$SCCi$号节点里面包含的原图的点数。<br>那么$C[B[i]]$就是表示原图$i$号节点所属的$SCC$节点包含的原图的点数。<br>对于逆行的边我们直接枚举<br>答案就是$min(Ans, D[V[j].F] + D2[V[j].T] + C[B[1]])$（V为反图）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1010000</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXM = <span class="number">200010</span> ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf = <span class="number">0x7fffffff</span> ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, B[MAXN], Low[MAXN], Dfn[MAXN &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EDGE</span> &#123;</span> <span class="keyword">int</span> F, T, Next ;&#125; E[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GDGE</span> &#123;</span> <span class="keyword">int</span> F, T, Next ;&#125; G[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VDGE</span> &#123;</span> <span class="keyword">int</span> F, T, Next ;&#125; V[MAXM &lt;&lt; <span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">int</span> Ken, Top, S[MAXN], Cnt, C[MAXN],Ans ;</span><br><span class="line"><span class="keyword">bool</span> Insta[MAXN] ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; Point[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span>, F = <span class="number">1</span> ; <span class="keyword">char</span> ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt; <span class="string">'9'</span> || ch &lt; <span class="string">'0'</span>) F = (ch == <span class="string">'-'</span> ? - <span class="number">1</span> : <span class="number">1</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">'0'</span> &amp;&amp; ch &lt;= <span class="string">'9'</span>) X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+(ch^<span class="number">48</span>), ch = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> X * F ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> H[MAXN], Tot ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    E[++ Tot].F = F ; E[Tot].T = T ;</span><br><span class="line">    E[Tot].Next = H[F], H[F] = Tot ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> H2[MAXN], Tot2 ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add2</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    G[++ Tot2].F = F ; G[Tot2].T = T ;</span><br><span class="line">    G[Tot2].Next = H2[F], H2[F] = Tot2 ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> H3[MAXN], Tot3 ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add3</span><span class="params">(<span class="keyword">int</span> F, <span class="keyword">int</span> T)</span> </span>&#123;</span><br><span class="line">    V[++ Tot3].F = F ; V[Tot3].T = T ;</span><br><span class="line">    V[Tot3].Next = H3[F], H3[F] = Tot3 ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> Now)</span> </span>&#123;</span><br><span class="line">    Dfn[Now] = ++ Ken ; Low[Now] = Ken ;</span><br><span class="line">    S[++ Top] = Now ; Insta[Now] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = H[Now] ;  i ; i = E[i].Next)</span><br><span class="line">        <span class="keyword">if</span> (! Dfn[E[i].T]) &#123;</span><br><span class="line">            Tarjan(E[i].T) ;</span><br><span class="line">            Low[Now] = min(Low[Now], Low[E[i].T]) ;</span><br><span class="line">        &#125;   <span class="keyword">else</span> <span class="keyword">if</span> (Insta[E[i].T])</span><br><span class="line">            Low[Now] = min(Low[Now], Dfn[E[i].T]) ;</span><br><span class="line">    <span class="keyword">if</span> (Dfn[Now] == Low[Now]) &#123;</span><br><span class="line">        <span class="keyword">int</span> Pass ; Cnt ++ ;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            Pass = S[Top --] ;</span><br><span class="line">            B[Pass] = Cnt ;</span><br><span class="line">            Point[Cnt].push_back(Pass) ;</span><br><span class="line">            C[Cnt] ++ ;</span><br><span class="line">            Insta[Pass] = <span class="literal">false</span> ;</span><br><span class="line">        &#125;   <span class="keyword">while</span> (Pass != Now) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D[MAXN], Vis[MAXN] ;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(Vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vis)) ;</span><br><span class="line">    <span class="built_in">memset</span>(D, <span class="number">0</span>, <span class="keyword">sizeof</span>(D)) ;</span><br><span class="line">    D[B[<span class="number">1</span>]] = - C[B[<span class="number">1</span>]] ; Vis[B[<span class="number">1</span>]] = <span class="number">1</span> ; Q.push(B[<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> Now = Q.front() ; Q.pop() ; Vis[Now] = <span class="literal">false</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = H2[Now] ; i ; i = G[i].Next)</span><br><span class="line">            <span class="keyword">if</span> (D[G[i].T] &gt; D[Now] - C[G[i].T]) &#123;</span><br><span class="line">                D[G[i].T] = D[Now] - C[G[i].T] ;</span><br><span class="line">                <span class="keyword">if</span> (! Vis[G[i].T])</span><br><span class="line">                    Vis[G[i].T] = <span class="number">1</span>, Q.push(G[i].T) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> D2[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Spfa2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(D2, <span class="number">0</span>, <span class="keyword">sizeof</span>(D2)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(Vis)) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) Q.pop() ;</span><br><span class="line">    D2[B[<span class="number">1</span>]] = - C[B[<span class="number">1</span>]] ; Vis[B[<span class="number">1</span>]] = <span class="number">1</span> ; Q.push(B[<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">while</span> (! Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> Now = Q.front() ; Q.pop() ; Vis[Now] = <span class="literal">false</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = H3[Now] ; i ; i = V[i].Next)</span><br><span class="line">            <span class="keyword">if</span> (D2[V[i].T] &gt; D2[Now] - C[V[i].T]) &#123;</span><br><span class="line">                D2[V[i].T] = D2[Now] - C[V[i].T] ;</span><br><span class="line">                <span class="keyword">if</span> (! Vis[V[i].T])</span><br><span class="line">                    Vis[V[i].T] = <span class="number">1</span>, Q.push(V[i].T) ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    N = Read() ; M = Read() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; i ++) &#123;</span><br><span class="line">        <span class="keyword">int</span> A = Read(), B = Read() ;</span><br><span class="line">        Add(A, B) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; i ++)</span><br><span class="line">        <span class="keyword">if</span> (! Dfn[i]) Tarjan(i) ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Cnt ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; Point[i].size() ; j ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = H[Point[i][j]] ; k ; k = E[k].Next)</span><br><span class="line">            <span class="keyword">if</span> (B[Point[i][j]] != B[E[k].T]) &#123;</span><br><span class="line">                Add2(B[Point[i][j]], B[E[k].T]) ;</span><br><span class="line">                Add3(B[E[k].T], B[Point[i][j]]) ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    Spfa() ; Spfa2() ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= Cnt ; i ++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = H3[i] ; j ; j = V[j].Next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (D[V[j].F] &lt; <span class="number">0</span> &amp;&amp; D2[V[j].T] &lt; <span class="number">0</span>)</span><br><span class="line">            Ans = min(Ans, D[V[j].F] + D2[V[j].T] + C[B[<span class="number">1</span>]]) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, - Ans) ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      有一个有向图，Bessie可以从$1$号节点开始然后最后回到$1$号节点，其中可以逆行一次，求能够经过的最多的节点数。
    
    </summary>
    
    
      <category term="拓扑排序" scheme="http://Yeasion.github.io/tags/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    
      <category term="最短路" scheme="http://Yeasion.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
      <category term="Tarjan" scheme="http://Yeasion.github.io/tags/Tarjan/"/>
    
  </entry>
  
</feed>
