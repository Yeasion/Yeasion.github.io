<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++介绍以及编译执行和调试]]></title>
    <url>%2F2019%2F11%2F11%2FC%2B%2B%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E7%BC%96%E8%AF%91%E6%89%A7%E8%A1%8C%E5%92%8C%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[C++介绍以及编译执行和调试C++的介绍C++，实际上是另一种语言的衍生版本，它就是C，而这个语言在研发初期的名字叫做“带类的C”，那么很显然这个语言的一大特色就在于它具有class。C++是一种面向对象的程序设计语言，在基本所有的系统中都可以运行。 C的一大特点就是高性能，它的速度基本是所有高级语言中最快的，因此为了保证速度，C++语言都是编译型的。这也是它为什么可以成为算法竞赛的主流语言的原因。 C++的编译和执行关于编译执行C++程序，由于国内的算法竞赛在NOIP（目前已经成为CSP）默认使用的IDE都是Dev-C++，因此笔者就权当读者们的电脑上已经配置好了相关程序。 接下来，在代码框内打出如下代码，按下F11便可以进行编译和执行了！ 123456#include &lt;iostream&gt;using namespace std ;int main() &#123; cout &lt;&lt; "Hello World !" &lt;&lt; endl ; return 0 ;&#125; 当然，在这里我们要为大家讲解的并不只是一个简单的F11而已。读者要清楚C++文件的编译依靠的是G++，是属于GNU的编译器，而在一般情况下G++编译文件有以下几步： 预处理生成后缀名为.i的文件 转换为汇编语言.s 转换为目标代码.o 连接目标代码，生成可执行程序.exe 那么接下来我们就尝试在命令行里面执行这些操作。 按下Win + R输入cmd即可进入命令指示符，然后我们通过cd命令进入保存好的代码源文件所在的文件夹。 然后我们输入以下指令 > g++ code.cpp -o code.exe 注意，在这个地方如果我们的代码有错误，那么是会出现问题的。 比如我们的代码在最后去掉了return 0 的分号： 123456#include &lt;iostream&gt;using namespace std ;int main() &#123; cout &lt;&lt; "Hello World !" &lt;&lt; endl ; return 0&#125; 那么运行这个命令的时候就会出现以下情况： 这时G++就提醒我们，在第6行出现了错误：没有加“;”。 然后在保证没有错误的情况下，我们执行以下命令就可以运行这个程序了。 > code.exe 而如果我们不加-o code.exe的话那么给出的文件将是默认的a.exe，而运行这个a.exe也是可以得出正确的结果的。 这个-o是什么意思呢，它可以让我们自定义输入文件名和输出文件名。当然并不是指的你的源代码的程序输入和输出，而是指的g++的输入和输出，对于上面的code.cpp来说，如果不加-o那么就相当于是输入了code.cpp文件，然后输出了a.exe文件，而如果我们加了-o就可以是g++输出code.cpp文件。 源代码的调试对于调试，很多人都是直接使用的Dev-C++的内置调试，但是经常会出现错误，因此在命令行里面进行调试也是很不错的选择。 为了充分解释各种命令，我们写了一个较为复杂的程序。 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std ;int X, Y, Z ;const int N = 5 ;int Solve(int A, int B) &#123; for (int i = 1 ; i &lt;= N ; i ++) Z = X * X + Y * Y ; return Z ;&#125;int main() &#123; cin &gt;&gt; X &gt;&gt; Y ; X = X * 2 ; Y = Y / 2 ; Solve(X, Y) ; Z = Z + 1 ; cout &lt;&lt; Z &lt;&lt; endl ; return 0 ;&#125; 想必大家也都能看懂这个程序，笔者不再解释。我们把它保存为code2.cpp 接下来我们在命令行里面输入如下指令： > g++ code2.cpp -g -o code2.exe 可以发现这个指令比之前多了一个-g，它可以使我们的g++输出调试信息。 > gdb code2.exe 这样我们便可以调试这个程序了。 接下来如果我们直接输入run指令，那么程序会直接执行到底，与不调试没有什么不同。 因此和Dev-c++一样，我们一开始也要先设置断点。在这里你可以设置第几行，也可以直接写函数名称。而设置断点的指令叫做b (gdb) b main 于是你发现现在程序直接执行到了main函数的第一行。按下n指令我们可以向后进行。 因为接下来我们要输入，所以输入完毕后程序才到了下一行。 直接回车是执行上一次的指令，那么我们直接回车程序便会向后执行。 可以发现现在执行到了要进入函数的这一行。先等一等，我们输入p后面跟变量名称可以查看现在的变量的数值。 没有什么问题我们就想继续进行了。但是这里不能直接n了，直接n我们会直接跳过了这个函数的执行部分，这个时候如果我们想进入函数，要输入s 成功进入了函数，但是现在我们遇到了一个循环结构，那么如果我们想时时刻刻查看Z的数值，不用每一次都p，我们只需要display Z 就可以将Z设为默认查看变量，每一次程序往下执行都会显示。 可以发现每一次继续执行都会显示出Z的大小。那么如果我们不需要查看Z了，我们需要undisplay 1，其中1是gdb给Z的编号。 此时GDB便不会再一直显示Z的大小了。 最后，输入q我们便可以推出gdb回到命令行了。 下面是一些GDB能够用到的基本操作，给大家列出来以方便使用 命令 命令缩写 作用 list l 显示当前行或指定行附近的多行代码 break b 设置断点到指定行 info i 描述程序当前状态 run r 开始执行程序 display disp 默认显示某个变量的数值 step s 进入函数 next n 继续执行 print p 查看一次变量的当前数值 continue c 运行到下一个断点 start st 开始执行程序到main函数 kill k 终止正在执行的程序 backtrace bt 查看堆栈信息 watch 监视变量变化（在变量数值发生变化时停止继续执行） set var name = value 改变变量name的值value quit q 退出GDB]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并行编程：进程与线程]]></title>
    <url>%2F2019%2F11%2F11%2F%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%EF%BC%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程 进程就是一个执行中程序的实例。 对于Python的编程以及程序，我们通常要经历很久的等待时间，而这种等待的原因分为两个： $I/O$限制 主要是由于I/O设备的处理速度跟不上CPU处理速度造成的等待。 $CPU$限制 在进行很大数据或者复杂程度比较高的运算的时候经常遇到的CPU速度的限制。 而要解决这两种限制，我们必须要了解进程以及并发。 首先要知道，系统中所有的程序都运行在某一个进程的上下文当中。而上下文就是程序正确运行所需要的状态。可以包括程序的代码和数据、栈以及寄存器内容、$PC$、环境变量、打开文件描述符集合等等，你并不需要都知道这是什么东西，你只要知道这是程序正确运行的状态就可以了。 当你的程序在你的电脑上运行的时候，你会想当然地以为整个系统只有这个程序在运行，那是因为操作系统给你提供了一种假象，让你这么以为。那么我们也可以这么说： 进程是操作系统对一个正在运行的程序的一种抽象。 我们当然知道编译器的运行其实就相当于对shell说“运行这个程序”，那么这个时候我们的shell做了什么呢？此时，shell会创建一个新的进程，然后在这个进程的上下文当中运行你的文件，也就好像我们的程序占据了整个系统。 而这种假象大致可以分为两点： 独立逻辑控制流的假象：好像我们的程序在独占处理器？ 私有地址空间的假象：好像我们的程序在独占内存系统？ 下面我们一个个解释。 逻辑控制流不要被名字吓到，这个玩意其实相当简单。现在你的系统中有许多的程序在运行，但是我们不要忘了： 在任何一个时刻，单处理器系统都只能处理一个进程的代码。 于是我们有了一种流，表示进程运行的序列 ，也可以简称为逻辑流。 ​ 上面的这个图可以很好的说明这个事了吧。首先$A$进程运行了一个时间片，然后操作系统内核进行了上下文切换，开始进行进程$B$，因为进程$B$只有一个时间片，所以直接进行完了，接着又是上下文切换到了进程$C$，运行完一个时间片之后切换完成了$A$，然后反过头来又进行完了$C$。 其实整个步骤的关键就在于进程是轮流使用控制器的，而逻辑控制流就是这么一个东西。 上下文切换关于上面的上下文切换我们先简单介绍一下，这个东西是操作系统转换执行进程的手段，是一种较高层次形式的一场控制流，主要由操作系统内核管理，步骤大致如下： 保存当前进程的上下文 回复新进程的上下文 传递控制权 其实一个进程并不一定能够从头到尾直接一条龙的执行完毕，在进程执行的时候，内核可以决定抢占这个进程，然后重新开始另外一个进程——当然它之前也被抢占过。而这种决策也叫作调度，由内核中的调度器执行。 而这个玩意的意义在哪里呢？因为我们使用系统的过程可能并不是一帆风顺的，往往当前的进程会由一些$unexpected$的事故导致阻塞，那么这时内核的调度器就可以选择休眠这个进程，进行别的进程。你也可以很简单的使用你的C++来实现这个休眠，一个sleep就可以了。下图展示了之前的举例的逻辑控制流的$A$到$B$的切换。 私有地址空间 地址空间表示任何一个计算机实体所占用的内存大小。比如外设、文件、服务器或者一个网络计算机。地址空间包括物理空间以及虚拟空间。 在一台地址为$n$位的机器上，地址空间表示$2^n$个可能地址的集合，而进程为每个程序提供私有地址空间。在计算机中，每一个设备以及进程都被分配了一个地址空间。 为什么说是私有呢？因为一般情况下一个空间中与某个地址相关联的内存字节是不能该被其他进程读写的。下面给出的是这个空间的通用结构： 关于地址空间的介绍不多说了，想要详细了解的请自行维基。 线程这个玩意可以视作是一个“单位”，一个进程的单位。因为在现代的系统当中，每一个进程都是有多个称为线程的执行单元组成的，每一个线程都运行在进程的上下文当中，共享代码和全局数据。 一条线程指的是中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 我们的Python支持的不仅仅是多进程，也支持多线程，其实这两个玩意的最终目的都是同时执行多个编程任务。在计算机科学当中，运行在操作系统中的每一个进程可以拥有多个线程，每一个进程都有自己独享的内存，也就是说这个进程里面的多个线程可以共享一块内存，但是多个进程之间就不行了，它们必须进行显式的通信。因此，可以认为多线程之间比多进程之间更容易共享数据，使得程序运行的更快，因此，由于网络服务器中对并行处理的需求，线程正在成为越来越重要的编程模型。 并发方才我们提到了逻辑控制流，而计算机系统中有非常多类型的逻辑流，其中就有一种叫做“并发流”。它的定义是：一个逻辑流的执行在时间上与另一个流重叠。但是不要混淆概念：是重叠，但并不代表是同时执行。就好像最开始举得例子：A与B是并发，但是B和C就不是，因为B和C并没有重叠部分。 多个流并发地执行的一般现象被称为并发。一个进程和其他进程轮流运行的概念称为多任务。 以上的内容当然十分简单，但是下面我们要做的是对进程、线程的代码方面的实际应用。 进程池实现这里我们的进程池的实现方法是多进程，大家必然不陌生这个东西。现在我们尝试创建两个进程，让每一个进程都输出一个”WORKING”，最后让主进程输出”WORKOUT!!!”结束。 123456789101112131415161718192021import multiprocessing as MP, time, osdef PRINT(name, MSG): time.sleep(2) print("process %s %s says: %s" % (name, str(os.getpid()), MSG))if __name__ == '__main__': print("process %s says: %s" % (os.getpid(), "WORKING")) task1 = MP.Process(target = PRINT, args = ("1", "WORKING")) print("Now processing!") task1.start() task2 = MP.Process(target = PRINT, args = ("1", "WORKING")) print("Now processing!") task2.start() task1.join() task2.join() print('Process close') 我们从上到下解释一下。首先我们目前用的多进程模块就叫做”multiprocessing”，其中有一个类叫做”Process”，我们可以用这个类完成一个进程对象的描述。 1if __name__ == '__main__' 这一段的意思我还是解释一下，如果你并非新手当然可以跳过。 我们知道Python的代码有两种使用方式，一种是直接运行，另一种就是import进另一份代码里面。也就是说一种是脚本执行，另一种是模块调用。而在上面这行代码下的代码只有在脚本执行的时候才会被执行。为什么呢？我们每一份代码（也称作模块）都有一个内置的变量$__name__$，当模块被直接执行的时候，$__name__$就等于文件名，而如果import到其他模块当中就等于那个模块的名称。而$__main__$一直等于自己模块的名称，因此只有脚本执行的时候才会有上述的语句为真。 然后我们看到对于task1和task2的定义是这样的。 1task1 = MP.Process(target = PRINT, args = ("1", "WORKING")) 其中target是执行函数的名字，args是函数需要的参数元组。 然后start方法启动进程，join方法实现进程同步，等待所有进程退出。 在上面的代码中我们看到每一个进程都是输出了一遍WORKING，而进程之间是不能够共享数据的。 下面介绍的东西叫做Pool，也是multiprocessing模块里面的内容，作用是预先构造进程池，然后每次使用进程的时候会在进程池里面申请一个进程。对于apply方法，可以理解为“进程排队执行”，每一个进程都是从头进行到尾，也就是只有一个时间片。 12345678910111213141516from multiprocessing import Process, Pool, Managerimport time, osdef PRINT(MSG): time.sleep(1) print(MSG, os.getpid())if __name__ == '__main__': pool = Pool(10) for i in range(10): pool.apply(func = PRINT, args = (str(i) + "said 'Hello'",)) print(i, "Prepare OK") pool.close() pool.join() close顾名思义，在调用它之后们不会有任何新的进程加入到pool。 另外还有一个apply_async模块支持回调。 1234567891011121314151617from multiprocessing import Process, Pool, Managerimport time, osdef PLUS(MSG): time.sleep(1) return MSG + 100def PRINT(MSG): print(MSG)if __name__ == '__main__': pool = Pool(5) for i in range(10): pool.apply_async(func = PLUS, args = (i,), callback = PRINT) print(i, "Prepare OK") pool.close() pool.join() 以上这个程序会输出100 ~ 109的所有数。 线程实现Python内部也提供了很好的模块叫做threading，我们可以用它来实现线程。 12345678910111213import threadingdef Doit(MSG): PRINT(MSG)def PRINT(MSG): print(threading.current_thread(), "says:", MSG)if __name__ == '__main__': PRINT("I'm main") for i in range(5): thread = threading.Thread(target = Doit, args = ("I'm child",)) thread.start() threading.current_thread()是返回当前的Thread对象，对应于调用者的控制线程。start()也是启动线程活动。这里没有加close()、join()之类的函数是因为默认情况下程序就会等待线程全部执行完毕才停止的，但是也可以更改为后台线程，让主线程优先。 实例分析：文章编写与上传假设你是一个网络文章工作者（我也不知道这个名称是怎么来的），被分配了两种任务：编写文章到本地以及将本地文章上传到云上。这都是很简单的工作以至于你一个人就可以完成，那么你的工作流程大致可以分为两种： 每次编写完一篇文章都即时上传，然后删除本地的这篇文章。 先编写完所有的文章之后统一上传，然后删除所有的文章。 这两种方法看起来好像没有很大的区别，但是第二种方法却要临时地占用更大的本地磁盘空间，相比之下就不如第一步来的优。 那么如果这个工作被分配了另外一个人呢？那么工作的分配可以是一个人负责编写文章，另一个人负责上传，这都需要一定的时间，那么为了工作的流畅性，就要考虑两个人速度的问题，因为如果编写文章的人的速度非常快，那么就有可能出现文章堆积的情况。要么在上传文章的人上传完它那篇文章之前一直闲着，要么就把它堆积下来，而总的来说处理的最终速度都是取决于最慢的那个人。 multiprocessing模块里面有一个queue类，也就是队列，想必大家肯定都不陌生，我也就不再解释。 1234567891011121314151617181920212223import multiprocessing, timedef writer(articles, queue): for article in articles: time.sleep(1) print('Writing', article) queue.put(article)def updater(queue): while True: time.sleep(1) article = queue.get() print('Updating', article) queue.task_done()if __name__ == '__main__': Queue = multiprocessing.JoinableQueue() Updater = multiprocessing.Process(target = updater, args = (Queue,)) Updater.daemon = True Updater.start() Articles = ['A', 'B', 'C', 'D'] writer(Articles, Queue) $queue.task_done()$：使用者使用此方法发出信号，表示queue.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常。 $queue.join()$：生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用queue.task_done（）方法为止。 $p.daemon=True$：设置为守护进程，在主线程停止时p也停止，但是不用担心，producer内调用q.join保证了consumer已经处理完队列中的所有元素]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contest Nodeocder1100]]></title>
    <url>%2F2019%2F10%2F29%2FContest%20Nowcoder1100%2F</url>
    <content type="text"><![CDATA[仓鼠的石子游戏 有$N$个石圈，每个石圈有$A[i]$个石头围成一圈，有两个人轮流对石子进行染色，相邻不能同色，首先不能操作的一方输，求先手必赢还是后手必赢。 这个题叭，说是博弈论，但是比较好推。首先讨论只有一个石圈的情况。那么我们发现对于偶数个的话，我们类比“放盘子问题”，对于先手放的每一个石头，我们都放到过石圈中点的对称位置，那么先手一定先不能走。 再讨论奇数的时候，我们后手每一次都放到先手的相邻位置，那么我们依然必赢。也就是说对于一个石圈，无论是奇数还是偶数（1除外），先手都是必输的。 但是唯一的不同之处就在于1，1的时候先手是必赢的。 那么转而来看多个石圈，你会发现没有任何不同，你可能会认为对于一个圈$A[i]$，先手某一次不放$A[i]$而转战$A[j]$就会改变$A[i]$里面的先后手顺序。但是没有关系，我们后手只需要也转战$A[j]$就可以了。 这个时候我们会发现1仍然是个唯一的特例。所以我们手推几组样例就会发现奇数个1就是先手赢，而偶数个1就是后手赢。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define int LL#define LS (Now &lt;&lt; 1)#define RS ((Now &lt;&lt; 1) | 1)#define Mid ((L + R) &gt;&gt; 1)#define E_Mid ((G[Now].L + G[Now].R) &gt;&gt; 1)using namespace std ;typedef long long LL ;const int MAXN = 1010 ;const int MAXM = 1010 ;const int INF = 0x7fffffff ;int T, N, A[MAXN], Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;signed main() &#123; T = Read() ; while (T --) &#123; N = Read() ; Ans = 0 ; for (int i = 1 ; i &lt;= N ; i ++) &#123; A[i] = Read() ; if (A[i] == 1) Ans ++ ; &#125; if (Ans &amp; 1) puts("rabbit") ; else puts("hamster") ; &#125; return 0 ;&#125; 乃爱与城市拥挤程度 给你一棵树，问你每个节点作为根的时候距离小于$K$的节点的个数以及这些节点动态权值的乘积。 这是个换根DP。首先对于第一问，我们设$Dp[i][j]$表示$i$点在$j$布以内的点数，那么转移的时候就转移到与自己联通的其他节点上，然后我们去除重复计算的j-2步向其他方向扩散的状态，就得到$Dp$方程： Dp[i][j] = Dp[S][j - 1] - Dp[i][j - 2] * (D[i] - 1)（D表示度。） 对于第二问，我们考虑先随便找到一个根然后进行换根。我们先把随便找到的根进行Dp，然后储存起来。对于每一次换根，假设我们要从$X$转换到$Y$，那么对于$X$我们做一个自下而上的Dp，然后对于$Y$我们再做一个自上而下的Dp，然后合并一下就可以了。 （说白了还是瞎搞） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define LS (Now &lt;&lt; 1)#define RS ((Now &lt;&lt; 1) | 1)#define Mid ((L + R) &gt;&gt; 1)#define E_Mid ((G[Now].L + G[Now].R) &gt;&gt; 1)using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 15 ;const int INF = 0x7fffffff ;const int mod = 1e9 + 7 ;int N, K, H[MAXN], T, f[MAXN][MAXM], g[MAXN][MAXM] ;long long F[MAXN][MAXM], G[MAXN][MAXM], Ans[MAXN] ;int Tot[MAXN] ;struct node &#123; int p, nxt; node(int P = 0, int Nxt = 0) &#123; p = P; nxt = Nxt; &#125;&#125; Line[MAXN &lt;&lt; 2] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;long long kasumi(long long base, int K) &#123; long long res = 1 ; while(K) &#123; if(K &amp; 1) res = (res * base) % mod; K &gt;&gt;= 1 ; base = (base * base) % mod; &#125; return res ;&#125;void add() &#123; int A = Read(), B = Read() ; Line[ ++ T] = node(B, H[A]) ; H[A] = T ; Line[ ++ T] = node(A, H[B]) ; H[B] = T ;&#125;void predfs(int now, int fa = 0) &#123; f[now][0]=1; for(int i = H[now];i ; i = Line[i].nxt) &#123; int v = Line[i].p; if(v==fa) continue; predfs(v, now); for(int j = 1 ; j &lt;= K; ++ j) f[now][j]+=f[v][j - 1]; &#125; return ;&#125;void dfs(int now, int fa = 0) &#123; for(int i = 0 ; i &lt;= K ; i ++ ) Tot[now]+=g[now][i]; for(int i = H[now];i ; i = Line[i].nxt) &#123; int v = Line[i].p ; if(v==fa) continue ; g[v][0]=f[v][0] ; g[v][1]=f[v][1] + f[now][0] ; for(int j = 2 ; j &lt;= K; ++ j) g[v][j]=f[v][j]+(g[now][j - 1] - f[v][j - 2]) ; dfs(v, now) ; &#125; return ;&#125;void dfs1(int now, int fa = 0) &#123; for(int i = 0 ; i &lt;= K; ++ i) F[now][i]=1; for(int i = H[now];i ; i = Line[i].nxt) &#123; int v = Line[i].p; if(v==fa) continue; dfs1(v, now); for(int j = 1 ; j &lt;= K; ++ j) F[now][j]=(F[now][j] * F[v][j - 1]) % mod; &#125; for(int i = 1, t = 1 ; i &lt;= K; ++ i) &#123; t+=f[now][i]; F[now][i]=(F[now][i] * t) % mod; &#125; return ;&#125;void dfs2(int now, int fa = 0) &#123; Ans[now]=G[now][K]; for(int i = H[now];i ; i = Line[i].nxt) &#123; int v = Line[i].p; if(v==fa) continue; G[v][0]=F[v][0]; G[v][1]=(((F[v][1] * F[now][0] % mod) * kasumi(f[v][1], mod - 2)) % mod * g[v][1]) % mod; for(int i = 2 ; i &lt;= K; ++ i) G[v][i]=((((F[v][i] * kasumi(f[v][i], mod - 2) % mod * G[now][i - 1]) % mod * kasumi(g[now][i - 1], mod - 2)) % mod * kasumi(F[v][i - 2], mod - 2)) % mod * g[v][i]) % mod * (g[now][i - 1] - f[v][i - 2]) % mod; dfs2(v, now); &#125;&#125;signed main() &#123; N = Read() ; K = Read() ; for(int i = 1 ; i &lt; N ; ++ i) add(); predfs(1); for(int i = 0 ; i &lt;= K ; ++ i) g[1][i]=f[1][i]; dfs(1); for(int i = 1 ; i &lt;= N ; ++ i) printf("%d ", Tot[i]) ; printf("\n"); dfs1(1); for(int i = 1 ; i &lt;= N ; ++ i) for(int j = 1 ; j &lt;= K; ++ j) g[i][j]+=g[i][j - 1], f[i][j]+=f[i][j - 1]; for(int i = 0 ; i &lt;= K ; ++ i) G[1][i]=F[1][i]; dfs2(1); for(int i = 1 ; i &lt;= N ; ++ i) printf("%lld ", G[i][K]) ; return 0;&#125; 小w的魔术扑克 $K$具有正反面的卡片，打出时只能选择一面，查询$Q$次，每次问是否能组成$L$到$R$的顺子。 智障死了，这个题。发现30pts特别好拿，时间不是很充足了就弄了个匈牙利匹配，然后用前缀和特判一下10分的正反相同的情况勉勉强强拿到了40分。考场上只写出来了这些。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define LS (Now &lt;&lt; 1)#define RS ((Now &lt;&lt; 1) | 1)#define Mid ((L + R) &gt;&gt; 1)#define E_Mid ((G[Now].L + G[Now].R) &gt;&gt; 1)using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;const int INF = 0x7fffffff ;int N, K, Q, Girl[MAXN], Use[MAXN], V[MAXN] ;int Sum[MAXN], F = 1, H[MAXN], Tot ;struct NODE &#123; int F, T, Next ;&#125; E[MAXN &lt;&lt; 1 * 10] ;inline void Add(int F, int T) &#123; E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].Next = H[F], H[F] = Tot ;&#125;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;inline bool Find(int Now) &#123; for(int i = H[Now] ; i ; i = E[i].Next) if (! Use[E[i].T])&#123; Use[E[i].T] = 1 ; if(! Girl[E[i].T] || Find(Girl[E[i].T]))&#123; Girl[E[i].T] = Now ; return true ; &#125; &#125; return false;&#125;signed main()&#123; freopen("ex.in", "r", stdin) ; freopen("ex2.out", "w", stdout) ; N = Read() ; K = Read() ; for (int i = 1 ; i &lt;= K ; i ++) &#123; int A = Read(), B = Read() ; Add(A, i) ; Add(B, i) ; if (A != B) F = 0 ; V[A] = 1 ; V[B] = 1 ; &#125; if (F == 1) &#123; for (int i = 1 ; i &lt;= N ; i ++) if (V[i]) Sum[i] = Sum[i - 1] + 1 ; else Sum[i] = Sum[i - 1] ; Q = Read() ; for (int i = 1 ; i &lt;= Q ; i ++) &#123; int L = Read(), R = Read() ; if (Sum[R] - Sum[L - 1] == R - L + 1) puts("Yes") ; else puts("No") ; &#125; return 0 ; &#125; Q = Read() ; for (int i = 1 ; i &lt;= Q ; i++) &#123; memset(Girl, 0, sizeof (Girl)) ; int L = Read(), R = Read(), Ans = 0 ; for (int i = L ; i &lt;= R ; i ++) &#123; memset(Use, 0, sizeof (Use)) ; Ans += Find(i) ; &#125; if (Ans == R - L + 1) printf("Yes\n") ; else printf("No\n") ; &#125; return 0 ;&#125; 然后我们考虑正解。 如果能想到图论模型，这个题就解了一半了。对于每个面值，由于在一个查询中它最多需要一次。所以我们可以把每个面值都当成是一个节点，对于一张牌，我们都建一条连接它正反两面两个面值的边。建好模型以后，我们不难发现，如果对于一个大小为N的连通块有至少N条边，那么这个连通块一定能满足保证每个面值都能够被提供至少一次。只有一种连通块特殊，也就是当连通块的大小为N，并且它具有N-1条边时，无论怎么调整，都会漏掉一个面值无法打出，大小为N，具有N-1条边的连通块，那也就是树。 所以我们先找树，dfs并查集啥玩意都ok，总之找出所有的树就可以了。 然后我们想这个问题的反面：什么样的顺子是不能满足的，我们发现，如果你的顺子完全包含了一颗树，那这个顺子就由于上述的原因无法构造。问题来了？如何判断一个顺子是否完全包含树？ 先求出每一颗树上节点编号的最小值与最大值，构造一个约束线段，约束线段的左端点为树上节点编号的最小值，右端点为树上节点编号的最大值。 接下来问题转化成了线段覆盖问题： 即：给定查询线段l,r，问你查询线段是否至少完整的覆盖了任意一个约束线段。如果存在则输出No，反之输出Yes。 这个就是个经典问题了，按照线段的右端点排序然后离线树状数组。对于每一个约束线段都将它的左端点赋成1，然后查询，查询区间和是否为0即可。 当然你也可以使用桶排序或者链式前向星处理查询，然后离线扫描线for过去维护下界。这样做是近似O(n)复杂度的算法，因为第一步使用了并查集，所以全局复杂度不是O(n)，而是O(nlogn)，只不过并查集常数太小了所以一般近似O(n)。 $T3$以上正解来自官方题解。]]></content>
      <categories>
        <category>专题集训与赛事</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>图论</tag>
        <tag>线段树</tag>
        <tag>博弈论</tag>
        <tag>离线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[UVA1608]Non-Boring Sequences]]></title>
    <url>%2F2019%2F10%2F29%2FUVA1608-Non-Boring%20Sequences%2F</url>
    <content type="text"><![CDATA[Link首先我们要能有一个算法进行预处理使我们能够快速的确定一个数在任意区间$[L, R]$内是否只出现了一次。难么我们考虑预处理出这个数的前一个出现的位置和后一个出现的位置P和S，于是在判断的时候我们只需要判断(P &lt; L &amp;&amp; S &gt; R)就可以了。那么如何处理出两个数组？我们用另一个数组$Last[A[i]]$表示$A[i]$最后一次出现的位置，于是就有 123R[Last[A[i]]] = i, L[i] = Last[A[i]], Last[A[i]] = i ; 于是我们就可以在$O(1)$的时间复杂度内完成上面说的那项事情了。接下来我们进行分治，每次寻找出该区间内的某一个之出现过一次的值，找到即往左右分治即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std ;typedef long long LL ;const int MAXN = 2000010 ;const int MAXM = 2000010 ;const int INF = 0x7fffffff ;int T, N, A[MAXN], L[MAXN], R[MAXN] ;unordered_map &lt;int, int&gt; Last ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;bool Judge(int X, int Y) &#123; int LL = X, RR = Y ; if (X &gt;= Y) return 1 ; for (int i = X ; i &lt;= Y ; i ++) &#123; if (i &amp; 1) &#123; if (L[LL] &lt; X &amp;&amp; R[LL] &gt; Y) return Judge(X, LL - 1) &amp;&amp; Judge(LL + 1, Y) ; LL ++ ; &#125; else &#123; if (L[RR] &lt; X &amp;&amp; R[RR] &gt; Y) return Judge(X, RR - 1) &amp;&amp; Judge(RR + 1, Y) ; RR -- ; &#125; &#125; return 0 ;&#125;signed main() &#123; T = Read() ; while (T --) &#123; N = Read() ; Last.clear() ; for (int i = 1 ; i &lt;= N ; i ++) L[i] = - 1, R[i] = INF ; for (int i = 1 ; i &lt;= N ; i ++) A[i] = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; R[Last[A[i]]] = i, L[i] = Last[A[i]], Last[A[i]] = i ; &#125; for (int i = 1 ; i &lt;= N ; i ++) R[Last[A[i]]] = N + 1 ; if (Judge(1, N)) puts("non-boring") ; else puts("boring") ; &#125; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contest Nowcoder1106 Holiday Team20]]></title>
    <url>%2F2019%2F10%2F28%2FContest%20Nowcoder1106%20Holiday%20Team20%2F</url>
    <content type="text"><![CDATA[Soda Machine 求一个数列上的一个点最多被多少个区间覆盖。非常简单的一道题，直接差分+离散化就可以了。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;const int INF = 0x7fffffff ;int N, L[MAXN], R[MAXN], A[MAXN], Tot, Sum[MAXN], Ans ;inline int Read() &#123; int X = 0 ; bool F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; L[i] = Read() ; R[i] = Read() + 1 ; A[++ Tot] = L[i], A[++ Tot] = R[i] ; &#125; sort(A + 1, A + Tot + 1) ; for (int i = 1 ; i &lt;= N ; i ++) &#123; L[i] = lower_bound(A + 1, A + Tot + 1, L[i]) - A ; R[i] = lower_bound(A + 1, A + Tot + 1, R[i]) - A ; Sum[L[i]] ++ ; Sum[R[i]] -- ; &#125; for (int i = 1 ; i &lt;= Tot ; i ++) Sum[i] = Sum[i] + Sum[i - 1], Ans = max(Ans, Sum[i]) ; printf("%d\n", Ans) ; return 0 ;&#125; 细胞分裂 要求最小的正整数$K$使得存在$i$满足$S_i ^ {K} | M_1 ^ {M_2}$ 直接质因数分解。要想满足条件，那么显然$S_i$必须包含$M_1$的所有的质因数。于是先判断这个事情。如果可以继续，那么设$F[A][B]$表示$A$的质因数中的$B$的数量，$M_1$的质因子$i$的出现的次数为$B_i$那么$\frac {M_2 \times B_j}{F[S][j]} \leq K$，那么根据$K$和时间的单调性关系，可以得到$K = max(k, \lceil \frac {M_2 \times B_j}{F[S][j]} \rceil)$直接上代码了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;const int INF = 0x7fffffff ;int N, M1, M2, S[MAXN], P[MAXN], T = 2, Ans = INF, A ;inline int Read() &#123; int X = 0 ; bool F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read() ; M1 = Read() ; M2 = Read() ; for (int i = 1 ; i &lt;= N ; i ++) S[i] = Read() ; if (M1 == 1) &#123; puts("0") ; return 0 ; &#125; while (M1 != 1) &#123; while (!(M1 % T)) M1 /= T, P[T] ++ ; A = max(A, T) ; P[T ++] *= M2 ; &#125; for (int i = 1 ; i &lt;= N ; i ++) &#123; int K = 0 ; for (int j = 2 ; j &lt;= A ; j ++) &#123; if (! P[j]) continue ; int C = 0 ; while (! (S[i] % j)) S[i] /= j, C ++ ; if (! C) &#123; K = INF ; break ; &#125; K = max(K, (P[j] - 1) / C) ; &#125; Ans = min(Ans, K) ; &#125; if (Ans == INF) puts("-1") ; else printf("%d\n", Ans + 1) ; return 0 ;&#125; Making Money FJ又经营起了古董生意，买卖一些像奶牛圣诞树上的装饰之类的小玩意。他知道他会将他能存储的N(1&lt;=N&lt;=100)件不同的奶牛古董每件都卖出。而且如果他的钱足够多他可以买他想要的任意数量的古董（即他可以购买的古董数量没有限制）。他只有M(1&lt;=M&lt;=100,000)元钱来买古董，但他想要在他经商的第一年年末最大化他的利润（这有点难以解释）。第i种古董采购需要花费Ci(1&lt;=Ci&lt;=100,000)元钱，每卖掉一件可以获得Ri(1&lt;=Ri&lt;=100,000)元钱(每卖一件的利润为Ri-Ci)。FJ可以以任意顺序卖出他的货物。他并不需要花光他所有的钱来购买古董。FJ在他经商的第一年年末能得到的最大总利润（利润=初始钱数-总花费+总收入）是多少呢？输入数据保证这个数字不会超过1,000,000,000.假设FJ只有3种古董而且开始时有M=17元钱。下面是三种古董的花费和收入。 完全背包直接上就是了。123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;const int INF = 0x7fffffff ;int N, M, W[MAXN], V[MAXN], Dp[MAXN], Ans ;inline int Read() &#123; int X = 0 ; bool F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read() ; M = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; W[i] = Read(), V[i] = Read() ; V[i] -= W[i] ; &#125; for (int i = 1 ; i &lt;= N ; i ++) for (int j = W[i] ; j &lt;= M ; j ++) Dp[j] = max(Dp[j], Dp[j - W[i]] + V[i]) ; for (int i = 1 ; i &lt;= M ; i ++) Ans = max(Ans, Dp[i] - i + M) ; printf("%d\n", Ans) ; return 0 ;&#125; 道路游戏 链接：https://ac.nowcoder.com/acm/contest/1106/D来源：牛客网 小新正在玩一个简单的电脑游戏。 游戏中有一条环形马路，马路上有n个机器人工厂，两个相邻机器人工厂之间由一小段马路连接。小新以某个机器人工厂为起点，按顺时针顺序依次将这n 个机器人工厂编号为1~n，因为马路是环形的，所以第n个机器人工厂和第1 个机器人工厂是由一段马路连接在一起的。小新将连接机器人工厂的这n段马路也编号为1~n，并规定第i段马路连接第i个机器人工厂和第i+1个机器人工厂（1≤i≤n-1），第n 段马路连接第n个机器人工厂和第1个机器人工厂。 游戏过程中，每个单位时间内，每段马路上都会出现一些金币，金币的数量会随着时间发生变化，即不同单位时间内同一段马路上出现的金币数量可能是不同的。小新需要机器人的帮助才能收集到马路上的金币。所需的机器人必须在机器人工厂用一些金币来购买，机器人一旦被购买，便会沿着环形马路按顺时针方向一直行走，在每个单位时间内行走一次，即从当前所在的机器人工厂到达相邻的下一个机器人工厂，并将经过的马路上的所有金币收集给小新，例如，小新在i（1≤i≤ n）号机器人工厂购买了一个机器人，这个机器人会从i 号机器人工厂开始，顺时针在马路上行走，第一次行走会经过i 号马路，到达i+1号机器人工厂（如果i=n，机器人会到达第1个机器人工厂），并将i号马路上的所有金币收集给小新。 游戏中，环形马路上不能同时存在2个或者2个以上的机器人，并且每个机器人最多能够在环形马路上行走p次。小新购买机器人的同时，需要给这个机器人设定行走次数，行走次数可以为1~p之间的任意整数。当马路上的机器人行走完规定的次数之后会自动消失，小新必须立刻在任意一个机器人工厂中购买一个新的机器人，并给新的机器人设定新的行走次数。 以下是游戏的一些补充说明： \1. 游戏从小新第一次购买机器人开始计时。 \2. 购买机器人和设定机器人的行走次数是瞬间完成的，不需要花费时间。 \3. 购买机器人和机器人行走是两个独立的过程，机器人行走时不能购买机器人，购买完机器人并且设定机器人行走次数之后机器人才能行走。 \4. 在同一个机器人工厂购买机器人的花费是相同的，但是在不同机器人工厂购买机器人的花费不一定相同。 \5. 购买机器人花费的金币，在游戏结束时再从小新收集的金币中扣除，所以在游戏过程中小新不用担心因金币不足，无法购买机器人而导致游戏无法进行。也因为如此，游戏结束后，收集的金币数量可能为负。 现在已知每段马路上每个单位时间内出现的金币数量和在每个机器人工厂购买机器人需要的花费，请你告诉小新，经过m 个单位时间后，扣除购买机器人的花费，小新最多能收集到多少金币。 这道题是真的难。优先队列优化动态规划。 状态表示就比较难想，你在真正比赛的时候不一定敢信这是一个一维的。设$Dp[i]$表示在时间$i$的时候的最优答案。 那么我们利用一下二维前缀和就大概可以写出来$Dp$的式子。 Dp[i] = max(Dp[i], Dp[i - k] + Sum[i][j] - Sum[i - k][j - k] - Cost[j - k])然后这个$Sum$表示的是时间和工厂这两维的前缀和。上面这相当于是一个$O(N^3)$的暴力$DP$，但是我们可以用优先队列进行优化。 首先把没有$k$的一项提出来，就变成： Dp[i] = max(Dp[i - k] - Sum[i - k][j - k] - Cost[j - k]) + Sum[i][j]于是你就发现$max$里面全部都是$i - k,j - k$，因此你可以预处理一下一个$Rec[i][j]$表示$Dp[i] - Sum[i][j] - Cost[j]$，那么$Dp$方程就变成了 Dp[i] = max(Rec[i][j]) + Sum[i][j]那么如果我们能够简化对于$Rec[i][j]$的枚举，就可以做到$O(N^2)$，这就非常优秀，那么显然这个时候就可以使用优先队列来进行优化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 1010 ;const int MAXM = 1010 ;const int INF = 0x7fffffff ;int N, M, P, Cost[MAXN], Rec[MAXN][MAXN], Pre[MAXN][MAXN], T ;int Money[MAXN][MAXM], Dp[MAXN], Ans = - INF, Sum[MAXN][MAXN] ;struct Node &#123; int Data, Step ; bool operator &lt;(Node A) const &#123; return Data &lt; A.Data ; &#125;&#125; ;priority_queue &lt;Node&gt; Q[MAXN] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;inline void Update(int S, int Id) &#123; Node X = Q[S].top() ; while (Id - X.Step &gt;= P) Q[S].pop(), X = Q[S].top() ;&#125;signed main() &#123; N = Read() ; M = Read() ; P = Read() ; memset(Dp, - 127, sizeof (Dp)) ; for (int i = 1 ; i &lt;= N ; i ++) for (int j = 1 ; j &lt;= M ; j ++) Money[i % N][j] = Read() ; for (int i = 0 ; i &lt; N ; i ++) Cost[i] = Read() ; for (int i = 1 ; i &lt;= M ; i ++) for (int j = 0 ; j &lt; N ; j ++) Sum[i][j] = Sum[i - 1][(j - 1 + N) % N] + Money[j][i] ; for (int i = 0 ; i &lt; N ; i ++) Pre[0][(i - 1 + N) % N] = i ; for (int i = 0 ; i &lt; N ; i ++) &#123; Rec[0][i] = - Cost[i] ; Node X = &#123;- Cost[i], 0&#125; ; Q[Pre[0][i]].push(X) ; &#125; for (int i = 1 ; i &lt;= M ; i ++) &#123; T = - INF ; for (int j = 0 ; j &lt; N ; j ++) Dp[i] = max(Dp[i], Rec[i - 1][(j - 1 + N) % N] + Sum[i][j]), Ans = max(Ans, Dp[i]), T = max(T, Dp[i]) ; for (int j = 0 ; j &lt; N ; j ++) &#123; Pre[i][j] = Pre[i - 1][(j - 1 + N) % N] ; Node X = &#123;T - Sum[i][j] - Cost[j], i&#125; ; Q[Pre[i][j]].push(X) ; Update(Pre[i][j], i) ; Rec[i][j] = Q[Pre[i][j]].top().Data ; &#125; &#125; printf("%d\n", Ans) ; return 0 ;&#125; Lake Counting 一个八联通的$N \times M$的方格图，$W$代表水池，$.$代表空地，常识确定一共有多少个水坑。 直接搜索。（这都是些什么垃圾题啊。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt; #include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define LS (Now &lt;&lt; 1)#define RS ((Now &lt;&lt; 1) | 1)#define Mid ((L + R) &gt;&gt; 1)#define E_Mid ((E[Now].L + E[Now].R) &gt;&gt; 1)using namespace std ;typedef long long LL ;const int MAXN = 110 ;const int MAXM = 110 ;const int INF = 0x7fffffff ;int N, M, Ans ; char Map[MAXN][MAXN] ;int Dx[9] = &#123;0, 0, 0, 1, - 1, 1, - 1, 1, - 1&#125; ;int Dy[9] = &#123;0, 1, - 1, 0, 0, - 1, 1, 1, - 1&#125; ;inline int Read() &#123; int X = 0 ; bool F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;inline void Dfs(int X, int Y) &#123; Map[X][Y] = '.' ; for (int i = 1 ; i &lt;= 8 ; i ++) &#123; int Vx = X + Dx[i], Vy = Y + Dy[i] ; if (Vx &gt;= 1 &amp;&amp; Vx &lt;= N &amp;&amp; Vy &gt;= 1 &amp;&amp; Vy &lt;= M) if (Map[Vx][Vy] == 'W') Dfs(Vx, Vy) ; &#125;&#125;signed main() &#123; N = Read() ; M = Read() ; for (int i = 1 ; i &lt;= N ; i ++) for (int j = 1 ; j &lt;= M ; j ++) cin &gt;&gt; Map[i][j] ; for (int i = 1 ; i &lt;= N ; i ++) for (int j = 1 ; j &lt;= M ; j ++) if (Map[i][j] == 'W') Dfs(i, j), Ans ++ ; printf("%d\n", Ans) ; return 0 ;&#125; 多项式输出一元nn次多项式可用如下的表达式表示： F(x) = A_NX^N + A_{N - 1} X ^ {N - 1} + ... + A_1X + A_0输入系数，输出这个式子。 哈，模拟好题。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;const int INF = 0x7fffffff ;int N, A ;inline int Read() &#123; int X = 0 ; bool F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read() ; for (int i = N ; i &gt;= 0 ; i --) &#123; scanf("%d", &amp; A) ; if (A) &#123; if (i != N &amp;&amp; A &gt; 0) cout &lt;&lt; "+" ; if (abs(A) &gt; 1 || i == 0) cout &lt;&lt; A ; if (A == -1 &amp;&amp; i) cout &lt;&lt; "-" ; if (i &gt; 1) cout &lt;&lt; "x^" &lt;&lt; i ; if (i == 1) cout &lt;&lt; "x" ; &#125; &#125;&#125; Dinner Time 农民约翰的$N（1≤N≤1000）$奶牛(编号1..N)在保加利亚参加$IOI$。奶牛们喜欢保加利亚的太阳，并享受他们的假期。一切 似乎都很好。 这在晚餐时间发生了变化。餐厅很小，只有$M（1 &lt;= M = N）$个牛的座位（编号1 .. M）.每头奶牛开始在一个位置 $cx_i，cy_i（1000000 &lt;= cx_i≤1000000；1000000≤cy_i &lt;= 1000000）$；可以在$sx_j，sy_j$ $（1000000 &lt; = sx_j≤1000000；1000000≤sy_j &lt; = 1000000）$找到座位。 奶牛有一个非常有效的（虽然很原始）的方法来分配座位。只要一头母牛可以确定她会先坐到座位上，她会尽快地 赶到那里（所有的母牛都跑得一样快）。 农民约翰的奶牛跳过座位、桌子、其他的牛不成问题，所以他们可以在一条直线上跑。当多 个奶牛可以在同一时间达到一个座位，最老的牛（在输入数据中出现得早）将会得到座位。同样，当一头母牛可 以到达多个座位时，她也会选择最早在输入数据中出现的一个。 有些牛不能吃晚饭（没有座位），那些饥饿的奶牛集体计划偷农民约翰的食物。农夫约翰想要一个他应 该警惕的牛的名单。（在没有饥饿的奶牛的情况下，输出0）。你能帮他吗？ 语文好题。 直接枚举座位和牛，然后就直接让最近的牛做到这个座位上就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std ;typedef long long LL ;const LL MAXN = 1000010 ;const LL MAXM = 1000010 ;const LL INF = 5810925546507845 ;LL N, M, Range[MAXN], F = 0 ;struct MAP &#123; LL X, Y ;&#125; C[MAXN], S[MAXN] ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;inline LL D(LL X1, LL Y1, LL X2, LL Y2) &#123; return sqrt((X1 - X2) * (X1 - X2) + (Y1 - Y2) * (Y1 - Y2)) ;&#125;signed main() &#123; N = Read() ; M = Read() ; for (LL i = 1 ; i &lt;= N ; i ++) C[i].X = Read(), C[i].Y = Read() ; for (LL i = 1 ; i &lt;= M ; i ++) S[i].X = Read(), S[i].Y = Read() ; for (LL i = 1 ; i &lt;= M ; i ++) &#123; LL Min = INF, Now ; for (LL j = 1 ; j &lt;= N ; j ++) &#123; if (! Range[j]) &#123; LL Dist = D(S[i].X, S[i].Y, C[j].X, C[j].Y) ; if (Dist &lt; Min) Min = Dist, Now = j ; &#125; &#125; Range[Now] = 1 ; &#125; for (LL i = 1 ; i &lt;= N ; i ++) &#123; if (! Range[i]) F = 1, printf("%lld\n", i) ; &#125; if (! F) printf("0") ; return 0 ;&#125; Counting Beads 给你一个序列，让你求出有多少个$A[j], A[i + 1]$满足01相间 我透了这真是连普及都不到啊。 12345678910111213#include &lt;iostream&gt; using namespace std ;int Data[100], Ans ;int main() &#123; int N ; cin &gt;&gt; N ; for (int i = 1 ; i &lt;= N ; i ++) cin &gt;&gt; Data[i] ; for (int i = 2 ; i &lt;= N ; i ++) if (Data[i] != Data[i - 1]) Ans ++ ; cout &lt;&lt; Ans ; return 0 ;&#125; Barn Allocation 大概就是给你一个序列和一堆序列，然后让你选择一些序列保证任意序列不相重，最大化序列数。 这个题也算是比较经典的贪心了，直接排序右端点，然后从左往右能选就选就可以了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 1000010 ;const int MAXM = 1000010 ;const int INF = 0x7fffffff ;int N, M, S[MAXN], T, Sum[MAXN], Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X * F ;&#125;pair &lt;int,int&gt; A[MAXN] ;priority_queue&lt;int&gt; Q ;signed main() &#123; N = Read() ; M = Read() ; for (int i = 1 ; i &lt;= N ; i ++) S[i] = Read() ; for (int i = 1 ; i &lt;= M ; i ++) A[i].first = Read(), A[i].second = Read() ; sort(A + 1, A + M + 1) ; A[M + 1].first = N + 1 ; for (int i = 1 ; i &lt;= N ; i ++) &#123; while (A[T + 1].first &lt;= i) Q.push(A[++ T].second), Sum[A[T].second] ++ ; while (Q.size() &gt; S[i] + Ans) Sum[Q.top()] --, Q.pop() ; Ans += Sum[i] ; &#125; printf("%d\n", Ans) ; return 0 ; &#125;]]></content>
      <categories>
        <category>专题集训与赛事</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>模拟</tag>
        <tag>搜索</tag>
        <tag>分数规划</tag>
        <tag>离散化 - 数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contest Nowcoder1126 Holiday Team19]]></title>
    <url>%2F2019%2F10%2F21%2FContest%20Nowcoder1126%20Holiday%20Team19%2F</url>
    <content type="text"><![CDATA[Link [A]Visiting Cows After many weeks of hard work, Bessie is finally getting a vacation! After many weeks of hard work, Bessie is finally getting a vacation! numbered 1..N. The cows have set up quite an unusual road network with exactly N-1 roads connecting pairs of cows C1 and C2 (1 &lt;= C1 &lt;= N; 1 &lt;= C2 &lt;= N; C1 != C2) in such a way that there exists a unique path of roads between any two cows. FJ wants Bessie to come back to the farm soon; thus, he has instructed Bessie that if two cows are directly connected by a road, she may not visit them both. Of course, Bessie would like her vacation to be as long as possible, so she would like to determine the maximum number of cows she can visit. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAXN 100005using namespace std;int n;struct qwq &#123; int to; int nxt;&#125; e[2*MAXN];int head[MAXN],cnt;inline void add(int x,int y) &#123; e[++cnt].to=y; e[cnt].nxt=head[x]; head[x]=cnt; return ;&#125;int dp[MAXN][3]; void dfs(int x,int fa) &#123; int xuan_max=0,bu_max=0; for(int i=head[x]; i; i=e[i].nxt) &#123; if(e[i].to==fa) continue ; dfs(e[i].to,x); xuan_max+=dp[e[i].to][0]; bu_max+=max(dp[e[i].to][0],dp[e[i].to][1]); &#125; dp[x][0]=bu_max; dp[x][1]=xuan_max+1; return ;&#125;inline int read() &#123; int x=0; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x;&#125; int main() &#123; n=read(); for(int i=1; i&lt;n; i++) &#123; int x=read(),y=read(); add(x,y),add(y,x); &#125; dfs(1,-1); cout&lt;&lt;max(dp[1][0],dp[1][1]); return 0;&#125; [B]传球游戏 上体育课的时候，小蛮的老师经常带着同学们一起做游戏。这次，老师带着同学们一起做传球游戏。 游戏规则是这样的：n个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没传出去的那个同学就是败者，要给大家表演一个节目。 聪明的小蛮提出一个有趣的问题：有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m次以后，又回到小蛮手里。两种传球的方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有3个同学1号、2号、3号，并假设小蛮为1号，球传了3次回到小蛮手里的方式有1-&gt;2-&gt;3-&gt;1和1-&gt;3-&gt;2-&gt;1，共2种。 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define MAXN 50using namespace std;int n,m,dp[MAXN][MAXN];int main()&#123; scanf("%d%d",&amp;n,&amp;m); dp[1][0]=1; for(int k=1;k&lt;=m;k++)&#123; dp[1][k]=dp[2][k-1]+dp[n][k-1]; for(int i=2;i&lt;n;i++) dp[i][k]=dp[i-1][k-1]+dp[i+1][k-1]; dp[n][k]=dp[n-1][k-1]+dp[1][k-1]; &#125; printf("%d",dp[1][m]); return 0;&#125; [C]Cow Photographs Farmer John wants to take a picture of his entire herd of N (1 &lt;= N &lt;= 100,000) cows conveniently numbered 1..N so he can show off to his friends. On picture day, the cows run to form a single line in some arbitrary order with position i containing cow cic_ici​ (1 &lt;= cic_ici​ &lt;= N). Farmer John has his own ideas about how the cows should line up. FJ thinks cow i may stand only to the left of cow i+1 (for all i, 1 &lt;= i &lt;= N-1) and that cow N may only stand to the left of Cow 1. Of course, no cow will stand to the left of the first (leftmost) cow in the line. The cows are hungry for the promised post-photo dinner, so Farmer John wants to take the picture as quickly as possible. Cows are not great at following directions, so he will only choose a pair of adjacent cows and have them switch places once per minute. How quickly is Farmer John able to get them into some acceptable order? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define int long longusing namespace std; const int MAXN=100010; int n,a[MAXN],pos[MAXN],cnt,ans; int tree[MAXN&lt;&lt;1]; inline int lowbit(int x)&#123; return x&amp;(-x);&#125; int query(int x)&#123; int ans=0; for(;x;x-=lowbit(x)) ans+=tree[x]; return ans;&#125; inline void update(int x,int d)&#123; for(;x&lt;=n;x+=lowbit(x)) tree[x]+=d;&#125; signed main()&#123; scanf("%lld",&amp;n); for(int i=1;i&lt;=n;++i)&#123; scanf("%lld",&amp;a[i]); pos[a[i]]=i; &#125; for(int i=1;i&lt;=n;++i)&#123; cnt+=i-1-query(a[i]); update(a[i],1); &#125; ans=cnt; for(int i=1;i&lt;=n;++i)&#123; cnt+=n-pos[i]-pos[i]+1; ans=min(ans,cnt); &#125; printf("%lld\n",ans); return 0;&#125; [D]Chocolate Milk Farmer John’s milk production and shipping system is an intricate one! He uses milking machines for his many cows to harvest the milk that then flows into pipes. Each of these pipes connects a milking machine to a joint, where it might be joined by exactly one more pipe (the milk flowing through both pipes merges). The milk then flows through additional pipes (which all start and end at joints) until it reaches the long central pipe connecting to the distribution room. The milk then goes through a reverse process of splitting at various joints until it is flows into milk tanks that are picked up and taken to market. Farmer John notices that there is at most one way for milk to travel from one joint to any other joint. Furthermore, since Farmer John is an efficient man by nature, he has made sure that milk will flow through each and every pipe; in other words, no pipe is unneeded. If we think of a milking machine, joint, or milk tank as a node, there are N (2 &lt;= N &lt;= 100,000) nodes in total (and N-1 pipes connecting them). The input describes each pipe as an ordered pair of nodes, AiA_iAi​ (1 &lt;= AiA_iAi​ &lt;= N) and BiB_iBi​ (1 &lt;= BiB_iBi​ &lt;= N; Ai&lt;BiA_i &lt; B_iAi​&lt;Bi​) indicating milk flows from node AiA_iAi​ to node BiB_iBi​. If there is no pipe coming in to AiA_iAi​, it is a milking machine. Likewise, if no pipe goes out from BiB_iBi​, it is a tank. The demand of chocolate milk has skyrocketed in recent months, and Farmer John wants to install a chocolate inserter at one of the joints so he can create delicious chocolate milk for customers. Being thrifty, Farmer John has only bought one chocolate inserter, so he wants to place it at a joint through which all the milk passes. He knows that such a joint exists. Help Farmer John find all the possible places he can install the chocolate inserter. (Note that Farmer John cannot install the chocolate inserter at the same location as a milking machine.) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std; const int MAXN=100010;const int MAXM=400010; int n;int Head[MAXN],num,du[MAXN],cnt1,f1[MAXN];int _Head[MAXN],_num,_du[MAXN],cnt2,f2[MAXN]; struct Edge&#123; int to,nxt;&#125;e[MAXN],_e[MAXN]; inline void add(int x,int y)&#123; e[++num].to=y; e[num].nxt=Head[x]; Head[x]=num;&#125;inline void _add(int x,int y)&#123; _e[++_num].to=y; _e[_num].nxt=_Head[x]; _Head[x]=_num;&#125; int dfs1(int x)&#123; if(f1[x]) return f1[x]; int sum=0; if(du[x]==0) ++sum; for(int i=Head[x];i;i=e[i].nxt)&#123; int to=e[i].to; sum+=dfs1(to); &#125; return f1[x]=sum;&#125; int dfs2(int x)&#123; if(f2[x]) return f2[x]; int sum=0; if(_du[x]==0) ++sum; for(int i=_Head[x];i;i=_e[i].nxt)&#123; int to=_e[i].to; sum+=dfs2(to); &#125; return f2[x]=sum;&#125; int main()&#123; scanf("%d",&amp;n); int x,y; for(int i=1;i&lt;n;++i)&#123; scanf("%d%d",&amp;x,&amp;y); add(x,y); ++du[x]; _add(y,x); ++_du[y]; &#125; for(int i=1;i&lt;=n;++i)&#123; if(du[i]==0) ++cnt1; if(_du[i]==0) ++cnt2; &#125; for(int i=1;i&lt;=n;++i) if(!f1[i]) dfs1(i); for(int i=1;i&lt;=n;++i) if(!f2[i]) dfs2(i); for(int i=1;i&lt;=n;++i) if(_du[i]!=0&amp;&amp;f1[i]==cnt1&amp;&amp;f2[i]==cnt2) printf("%d\n",i); return 0;&#125; [E]Math Practice One lovely afternoon, Bessie’s friend Heidi was helping Bessie review for her upcoming math exam. Heidi presents two integers A (0 &lt;= A &lt;= 45) and B (1 &lt;= B &lt;= 9) to Bessie who must respond with an integer E in the range 1..62. E is the smallest integer in that range that is strictly greater than A and also has B as the first digit of 2 raised to the E-th power. If there is no answer, Bessie responds with 0. Help Bessie correctly answer all of Heidi’s questions by calculating her responses. 12345678910111213141516171819202122232425262728#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std;int E[64]=&#123;1,2,4,8,1,3,6,1,2,5,1,2,4,8,1,3,6,1,2,5,1,2,4,8,1,3,6,1,2,5,1,2,4,8,1,3,6,1,2,5,1,2,4,8,1,3,7,1,2,5,1,2,4,9,1,3,7,1,2,5,1,2,4,9&#125;;inline int read() &#123; int x=0; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x;&#125;int main() &#123; int a=read(),b=read(); for(int i=a+1;i&lt;=62;i++) if(b==E[i])&#123; cout&lt;&lt;i&lt;&lt;endl; return 0; &#125; cout&lt;&lt;"0"; return 0;&#125; [F]立体图 小渊是个聪明的孩子，他经常会给周围的小朋友们讲些自己认为有趣的内容。最近，他准备给小朋友们讲解立体图，请你帮他画出立体图。 小渊有一块面积为mn的矩形区域，上面有mn个边长为1的格子，每个格子上堆了一些同样大小的吉姆（积木的长宽高都是1），小渊想请你打印出这些格子的立体图。我们定义每个积木为如下格式，并且不会做任何翻转旋转，只会严格以这一种形式摆放： 每个顶点用1个加号’+’表示，长用3个”-“表示，宽用1个”/”表示，高用两个”|”表示。字符’+’，‘-‘，’/’，‘|’的ASCII码分别为43，45，47，124。字符’.’（ASCII码46）需要作为背景输出，即立体图里的空白部分需要用’.’代替。立体图的画法如下面的规则： 若两块积木左右相邻 若两块积木上下相邻 若两块积木前后相邻 立体图中，定义位于第(m,1)的格子（即第m行第1列的格子）上面自底向上的第一块积木（即最下面的一块积木）的左下角顶点为整张图最左下角的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;using std::max;const int maxn=51;int data[maxn][maxn];char m[maxn*5][maxn*5];int f[maxn][maxn];int L=0,W=0;void clear(int x,int y,int len)&#123; for(int i=0;i&lt;len;i++) m[x][y+i]=' '; return ;&#125;void out()&#123; for(int i=L;i&gt;=1;i--) &#123; for(int j=1;j&lt;=W;j++) putchar(m[i][j]); putchar('\n'); &#125; //printf("------------------------\n"); return ;&#125;void insert(int x,int y)&#123; for(int i=0;i&lt;=3;i++) clear(x+i,y,5); clear(x+4,y+1,5);clear(x+5,y+2,5); m[x+2][y+5]=m[x+3][y+5]=' '; for(int i=1;i&lt;=3;i++) m[x][y+i]=m[x+3][y+i]=m[x+5][y+2+i]='-'; for(int i=1;i&lt;=2;i++) m[x+i][y]=m[x+i][y+4]=m[x+i+2][y+6]='|'; m[x+4][y+1]=m[x+4][y+5]=m[x+1][y+5]='/'; m[x][y]=m[x+3][y]=m[x+5][y+2]=m[x+5][y+6]=m[x+3][y+4]=m[x+2][y+6]=m[x][y+4]='+'; W=max(W,y+6); L=max(L,x+5);&#125;void init()&#123; for(int i=1;i&lt;maxn*5;i++) for(int j=1;j&lt;maxn*5;j++) m[i][j]='.'; return ;&#125;int main()&#123; init(); int n,m; scanf("%d%d",&amp;n,&amp;m); for(int i=n;i&gt;=1;i--) for(int j=1;j&lt;=m;j++) scanf("%d",&amp;f[i][j]); bool F=true; int cnt=0; while(F) &#123; F=false; cnt++; for(int i=n;i&gt;=1;i--) for(int j=1;j&lt;=m;j++) if(f[i][j]) &#123; int x=3*cnt-4+i*2; int y=4*j-5+i*2; f[i][j]--; if(f[i][j]) F=true; insert(x,y); //out(); &#125; &#125; out(); return 0;&#125; [G]Candy Farmer John knows that Bessie loves to eat candy. FJ has N (1 &lt;= N &lt;= 40,000) candies that he wants to give Bessie over some number of days. Each day, Farmer John gives Bessie a choice of how many candies she chooses to eat that day by choosing the number from a master list FJ supplies that has Nopt (1 &lt;= Nopt &lt;= 50) different options, CiC_iCi (1 &lt;= CiC_iCi &lt;= N). She must take exactly CiC_iCi candies, no more, no less. Farmer John has also disclosed F (1 &lt;= F &lt;= 50) of his favorite numbers, FNiFN_iFNi​ (1 &lt;= FNiFN_iFNi​ &lt;= N). Whenever the number of candies remaining at the end of the day precisely matches one of these favorite numbers, Bessie has the option to have him add exactly M (1 &lt;= M &lt;= 100) more candies to the candy supply. Bessie might get another option to add M candies several times if adding candies creates another favorite number. In the best circumstances, Bessie can obtain an infinite amount of candy! When Bessie cannot choose some amount of candy to take (because there is not enough), and the number of candies remaining is not any of FJ’s favorite numbers, she cannot have any more candy. Unfortunately, Bessie cannot think ahead as far as she’d like to, so she needs your help in order to eat as many candies as possible. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;using std::max;using std::queue;const int maxn=101000;int ind[maxn],like[maxn];int ate[maxn],f[maxn];int g[maxn];int n,nopt,fn,m;int vis[maxn],instk[maxn];queue&lt;int&gt;q;template&lt;class T&gt;void read(T&amp; val)&#123; char c=getchar(); val=0; while(!isdigit(c)) c=getchar(); while(isdigit(c)) &#123; val=(val&lt;&lt;3)+(val&lt;&lt;1)+c-'0'; c=getchar(); &#125; return ;&#125;void dfs(int now)&#123; vis[now]=instk[now]=1; int nxt; for(int i=1;i&lt;=nopt;++i) &#123; nxt=now-ate[i]; if(nxt&lt;0) continue; if(instk[nxt]) &#123; printf("-1"); exit(0); &#125; else &#123; ++ind[nxt]; if(!vis[nxt]) dfs(nxt); &#125; &#125; if(like[now]&amp;&amp;now!=n) &#123; nxt=now+m; if(instk[nxt]) &#123; printf("-1"); exit(0); &#125; else &#123; ++ind[nxt]; if(!vis[nxt]) dfs(nxt); &#125; &#125; instk[now]=0;&#125;int main()&#123; // freopen("data.in","r",stdin); read(n),read(nopt),read(fn),read(m); for(int i=1;i&lt;=nopt;++i) read(ate[i]); for(int i=1;i&lt;=fn;++i) read(f[i]),like[f[i]]=1; dfs(n); /* * for(int i=0;i&lt;=n+m;++i) if(vis[i]) * for(int j=1;j&lt;=nopt;++j) if(i-ate[j]&gt;=0&amp;&amp;vis[i-ate[j]]) * ++ind[i-ate[j]]; * for(int i=1;i&lt;=fn;++i) if(vis[f[i]]&amp;&amp;vis[f[i]+m]&amp;&amp;f[i]!=n) * ++ind[f[i]+m]; */ q.push(n); ind[n]=0; int pas,nxt; while(!q.empty()) &#123; pas=q.front(); q.pop(); for(int i=1;i&lt;=nopt;++i) &#123; nxt=pas-ate[i]; if(nxt&lt;0) continue; g[nxt]=max(g[nxt],g[pas]+ate[i]); --ind[nxt]; if(!ind[nxt]) q.push(nxt); &#125; if(like[pas]&amp;&amp;pas!=n) &#123; nxt=pas+m; g[nxt]=max(g[nxt],g[pas]); --ind[nxt]; if(!ind[nxt]) q.push(nxt); &#125; &#125; int ans=0; for(int i=0;i&lt;=n+m;++i) ans=max(ans,g[i]); printf("%d",ans); return 0;&#125; [H]Banner Bessie is returning from a long trip abroad, and Farmer John wants to erect a nice ‘Welcome Home’ banner in her pasture for her arrival. The banner will hang between two poles on a wire whose length is in the range L1..L2 (1 &lt;= L1 &lt;= L2; L1 &lt;= L2 &lt;= 1,500). The pasture’s size is W x H (1 &lt;= W &lt;= 1,000; 1 &lt;= H &lt;= 1,000), and Farmer John has installed a post at every point with integer coordinates. Of these (W + 1) * (H + 1) points, Farmer John must pick just two that will hold either end of the wire from which he will hang the banner. FJ wants no interference with his banner as it hangs and requires that no post be directly under the tight wire he stretches between the two chosen posts. Farmer John needs your help to figure out how many possible ways he can hang the banner. He knows the number is large and that a 32-bit integer might not be sufficient to compute the answer. 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#define int long longusing namespace std; int L1,L2,W,H,ans; inline int gcd(int a,int b)&#123; if(!b) return a; return gcd(b,a%b);&#125; signed main()&#123; scanf("%lld%lld%lld%lld",&amp;W,&amp;H,&amp;L1,&amp;L2); for(int i=0;i&lt;=W;++i) for(int j=0;j&lt;=H;++j)&#123; double len=sqrt(i*i+j*j); if(gcd(i,j)==1&amp;&amp;L1&lt;=len&amp;&amp;len&lt;=L2)&#123; if(i==0||j==0) ans+=(W-i+1)*(H-j+1); else ans+=(W-i+1)*(H-j+1)*2; &#125; &#125; printf("%lld\n",ans); return 0;&#125; [I]Race Results The herd has run its first marathon! The N (1 &lt;= N &lt;= 5,000) times have been posted in the form of Hours (0 &lt;= Hours &lt;= 99), Minutes (0 &lt;= Minutes &lt;= 59), and Seconds (0 &lt;= Seconds &lt;= 59). Bessie must sort them (by Hours, Minutes, and Seconds) into ascending order, smallest times first. 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;const int INF = 0x7fffffff ;int N ;struct TIME &#123; int X, Y, Z ;&#125; E[MAXN &lt;&lt; 1] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline bool CMP(TIME A, TIME B) &#123; if (A.X == B.X) &#123; if (A.Y == B.Y) return A.Z &lt; B.Z ; return A.Y &lt; B.Y ; &#125; return A.X &lt; B.X ;&#125;int main() &#123; N = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; E[i].X = Read() ; E[i].Y = Read() ; E[i].Z = Read() ; &#125; sort(E + 1, E + N + 1, CMP) ; for (int i = 1 ; i &lt;= N ; i ++) printf("%d %d %d\n", E[i].X , E[i].Y , E[i].Z) ; return 0 ;&#125; [J]Buying Feed Farmer John needs to travel to town to pick up K (1 &lt;= K &lt;= 10,000) pounds of feed. Driving a mile with K pounds of feed costs FJ KK cents; driving D miles with K pounds of feed in his truck costs FJ DK*K cents. FJ can purchase feed from any of N (1 &lt;= N &lt;= 500) stores (conveniently numbered 1..N) that sell feed. Each store is located on a segment of the X axis whose length is E (1 &lt;= E &lt;= 500) miles. Store i is at location XiX_iXi​ (0 &lt; XiX_iXi​ &lt; E) on the number line and can sell FJ as much as FiF_iFi​ (1 &lt;= FiF_iFi​ &lt;= 10,000) pounds of feed at a cost of CiC_iCi​ (1 &lt;= CiC_iCi​ &lt;= 10,000,000) cents per pound. Surprisingly, a given point on the X axis might have more than one store. FJ starts driving at location 0 on this number line and can drive only in the positive direction, ultimately arriving at location E with at least K pounds of feed. He can stop at any of the feed stores along the way and buy any amount of feed up to the the store’s limit. What is the minimum amount FJ must pay to buy and transport the K pounds of feed? FJ knows he can purchase enough feed. 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#define int long longusing namespace std; const int N=10010; int n,E,K,dp[N];struct Data&#123; int x,f,c;&#125; a[N]; inline bool cmp(Data p,Data q)&#123; return p.x&lt;q.x;&#125; signed main()&#123; scanf("%lld%lld%lld",&amp;K,&amp;E,&amp;n); for(int i=1;i&lt;=n;++i) scanf("%lld%lld%lld",&amp;a[i].x,&amp;a[i].f,&amp;a[i].c); sort(a+1,a+1+n,cmp); memset(dp,0x3f,sizeof(dp)); dp[0]=0; for(int i=1;i&lt;=n;++i)&#123; int sum=0; for(int k=1;sum+k&lt;=a[i].f;k&lt;&lt;=1)&#123; sum+=k; for(int j=K;j&gt;=k;--j) dp[j]=min(dp[j],dp[j-k]+a[i].c*k+(j*j-(j-k)*(j-k))*(E-a[i].x)); &#125; int k=a[i].f-sum; for(int j=K;j&gt;=k;--j) dp[j]=min(dp[j],dp[j-k]+a[i].c*k+(j*j-(j-k)*(j-k))*(E-a[i].x)); &#125; printf("%lld\n",dp[K]); return 0;&#125; [K]排座椅 上课的时候总有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的D对同学上课时会交头接耳。同学们在教室中坐成了M行N列，坐在第i行第j列的同学的位置是（i，j），为了方便同学们进出，在教室中设置了K条横向的通道，L条纵向的通道。于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了两个会交头接耳的同学，那么他们就不会交头接耳了。请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生对数最少 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std; int m,n,k,l,d;//变量名最好起与题目一致的 int x[1005],y[1005];//横纵坐标数组 int c[1005],o[1005];//桶排要用的数组int main() &#123; scanf("%d%d%d%d%d",&amp;m,&amp;n,&amp;k,&amp;l,&amp;d); for(int i=1;i&lt;=d;i++) &#123; int xi,yi,pi,qi; scanf("%d%d%d%d",&amp;xi,&amp;yi,&amp;pi,&amp;qi); if(xi==pi) x[min(yi,qi)]++;//表示隔开这两排的价值 else y[min(xi,pi)]++; //记得取min，即过道与前一个坐标保持一致 &#125; for(int i=1;i&lt;=k;i++)&#123;//开始桶排 int maxn=-1;//为了求出每次的最大值，需要每次扫一遍 int p; for(int j=1;j&lt;m;j++)&#123; if(y[j]&gt;maxn)&#123; maxn=y[j]; p=j; &#125; &#125; y[p]=0;//求出max之后一定要记得清零！！否则无论排多少次都是一个答案 c[p]++;//桶排不解释 &#125; for(int i=1;i&lt;=l;i++)&#123; int maxn=-1; int p; for(int j=1;j&lt;n;j++)&#123; if(x[j]&gt;maxn)&#123; maxn=x[j]; p=j; &#125; &#125; x[p]=0; //同上 o[p]++; &#125; for(int i=0;i&lt;1005;i++)//输出答案 &#123; if(c[i])//表示需要隔开这行 printf("%d ",i); &#125; printf("\n"); for(int i=0;i&lt;1005;i++) &#123; if(o[i]) printf("%d ",i); //同上 &#125; return 0; &#125; [L] Daisy Chains in the Field Farmer John let his N (1 &lt;= N &lt;= 250) cows conveniently numbered 1..N play in the field. The cows decided to connect with each other using cow-ropes, creating M (1 &lt;= M &lt;= N*(N-1)/2) pairwise connections. Of course, no two cows had more than one rope directly connecting them. The input shows pairs of cows c1 and c2 that are connected (1 &lt;= c1 &lt;= N; 1 &lt;= c2 &lt;= N; c1 != c2). FJ instructed the cows to be part of a chain which contained cow #1. Help FJ find any misbehaving cows by determining, in ascending order, the numbers of the cows not connected by one or more ropes to cow 1 (cow 1 is always connected to herself, of course). If there are no misbehaving cows, output 0. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAXN 255using namespace std;int n;struct qwq&#123; int to; int nxt;&#125;e[MAXN*MAXN*2];int head[MAXN],cnt;void add(int x,int y)&#123; e[++cnt].to=y; e[cnt].nxt=head[x]; head[x]=cnt; return ;&#125;inline int read() &#123; int x=0; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9') ch=getchar(); while(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; x=(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48); ch=getchar(); &#125; return x;&#125;bool vis[MAXN];void dfs(int x,int fa)&#123; vis[x]=1; for(int i=head[x];i;i=e[i].nxt)&#123; if(vis[e[i].to]) continue ; dfs(e[i].to,x); &#125; return ;&#125;int main() &#123; int n=read(),m=read(); memset(vis,0,sizeof(vis)); for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(); add(x,y),add(y,x); &#125; dfs(1,-1); int bb=0; for(int i=1;i&lt;=n;i++) if(!vis[i])&#123; cout&lt;&lt;i&lt;&lt;endl; bb=1; &#125; if(bb==0) cout&lt;&lt;"0"; return 0;&#125;]]></content>
      <categories>
        <category>专题集训与赛事</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Contest Nowcoder1115 Nowcoder Challenge33]]></title>
    <url>%2F2019%2F10%2F08%2FContest%20Nowcoder1115%20Nowcoder%20Challenge33%2F</url>
    <content type="text"><![CDATA[Link 牛客挑战赛1115，很有难度的一些题，当然，我指的部分。 妖馨斋的五彩棒 给定三个正整数$A, B, C$。设$AA = \frac{AB}{C} + \frac{BC}{A} +\frac{AC}{B}$，$BB = A + B + C$。如果$AA &gt; BB$输出$YES$，否则输出$NO$。 这道题我看到的时候直接笑喷了。。。又要有不少人想各种诡异的算法。实际上虽然数据范围很大，但是对于$python$来说直接暴力模拟是没有任何问题的。 1234567891011n = input().split() ;A = float(n[0])B = float(n[1])C = float(n[2]) AA = (A * B) / C + (B * C) / A + (A * C) / BBB = A + B + C if AA &gt; BB: print("YES")else: print("NO") 鸽天的放鸽序列 给定一个$N，K$，定义一个长为$N$的$01$序列${A_i}$，其权值为$\sum_{i = 1}^{N}((\sum_{j = 1}^iA_j)~mod~2)$，求有多少个$01$序列满足有$K$个1，并且权值最大。 这个题是要好好研究一下这个式子的。 发现里面的$\sum_{j = 1}^iA_j$指的是前缀和，因为是$01$序列，因此我们可以抽象成前缀中$1$的个数，但是他后面$mod$了一个$2$，因此我们知道了，对于每一个前缀，如果含有的$1$的个数为$1$那么贡献就为$1$否则贡献为$0$。 因此我们尝试去推一下构造这个$01$序列的规律。首先我们发现如果放$0$那么是可以产生和前一位相同的贡献的，因此如果前面的$1$的个数为偶数，那么这个时候我们放$0$必然是不优的，因此直接舍弃这个转移方式。当然，如果前面是$0$个$1$的话也是一样的，同样是会浪费掉这个$0$。 因此我们尝试去构造一个$Dp$转移，设$Dp[i][j]$表示构造到了前$i$个数，并且含有$j$个$1$的满足要求的序列有多少个。那么我们有这样的转移： Dp[i][j] = Dp[i - 1][j]+Dp[i - 1][j - 1]~(j ~mod~ 2 == 1) Dp[i][j] = Dp[i - 1][j - 1]~(j~mod~2 == 0)嗯，他看起来很好理解那我就不多说了，当然你也可以选择滚动数组，但是你会发现即使这样他也会超时，因此就考虑将所有的这些玩意组合起来看最后的结果。 你会发现最后的结果相当于是在$k$个$1$里面茶语$n - k$个$0$，并且这些$0$能插入的位置必须满足前缀和为奇数。因此我们一共有$\lfloor \frac{k}{2} \rfloor$可以插入，因此直接组合数即可。当然不要忘了求$Inv$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std ;typedef long long LL ;const LL MAXN = 1000100 ;const LL MAXM = 1000100 ;const LL INF = 0x7fffffff ;const LL Mod = 1e9 + 7 ;LL N, K, A[MAXN], Ans, Fac[MAXN], Inv[MAXN] ;inline LL Read() &#123; LL X = 0 ; bool F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;LL quickMod(LL a,LL b) &#123; LL ans = 1; while (b) &#123; if (b&amp;1) ans = ans * a % Mod; a = a*a % Mod; b &gt;&gt;= 1; &#125; return ans;&#125; void getFac() &#123; Fac[0] = Inv[0] = 1; for (int i = 1 ; i &lt;= 1000010 ; i++) &#123; Fac[i] = Fac[i-1] * i % Mod; Inv[i] = quickMod(Fac[i],Mod-2); &#125;&#125; LL getC(LL n,LL m) &#123; return Fac[n] * Inv[n-m] % Mod * Inv[m] % Mod;&#125;int main() &#123; N = Read() ; K = Read() ; if (K == 0) &#123; printf("1") ; return 0 ; &#125; getFac() ; N = N - 2 + K % 2 ; K = (K - 1) / 2 ; printf("%lld\n", getC(N - K, K)) ;&#125;]]></content>
      <categories>
        <category>专题集训与赛事</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>动态规划</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019十一集训贪心专题选讲]]></title>
    <url>%2F2019%2F10%2F02%2F2019%E5%8D%81%E4%B8%80%E9%9B%86%E8%AE%AD%E8%B4%AA%E5%BF%83%E4%B8%93%E9%A2%98%E9%80%89%E8%AE%B2%2F</url>
    <content type="text"><![CDATA[New Year Snowmen 要堆起一个雪人，需要三个不同大小的雪球。 现在有$n$个给定大小的雪球，问最多能堆起多少个雪人，并输出方案。($n \leq 10 ^ 5$) Codeforces 140C 好像这个结论比较难证，但是很容易想出来。就是说我们每次取出目前数量最多的雪球种类，这样能取出来的雪人的个数一定是最多的。至于证明，还是留给读者慢慢想吧。。。 因此做法很一目了然了，基本上就是记录每一种雪球的种类数，然后用优先队列维护一下就可以了，虽然做法很简单，但是有一些细节仍然需要注意，建议大家尝试动手写一写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;const int INF = 0x7fffffff ;int N, Tot = 1, Ans ;struct Node &#123; int R, ID ; bool operator &lt; (Node B) const &#123; return R &lt; B.R ; &#125;&#125; E[MAXN] ;struct Node2 &#123; int X[4] ;&#125; G[MAXN] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;priority_queue&lt;Node&gt; Q ;int main() &#123; N = Read() ; for (int i = 1 ; i &lt;= N ; i ++) E[i].R = Read(), E[i].ID = i ; sort(E + 1, E + N + 1) ; E[0].R = - INF ; for (int i = 2 ; i &lt;= N + 1 ; i ++) &#123; if (E[i].R != E[i - 1].R) &#123; Node Now ; Now.ID = E[i - 1].R, Now.R = Tot ; Q.push(Now) ; Tot = 1 ; &#125; else Tot ++ ; &#125; Node NOW ; NOW = Q.top() ; int Cnt = 0 ; while (Q.size() &gt;= 3) &#123; Node Now[4] ; for (int i = 1 ; i &lt;= 3 ; i ++) &#123; Now[i] = Q.top() ; Q.pop() ; Now[i].R -- ; &#125; for (int i = 1 ; i &lt;= 3 ; i ++) if (Now[i].R) Q.push(Now[i]), Cnt ++ ; Ans ++ ; for (int i = 1 ; i &lt;= 3 ; i ++) G[Ans].X[i] = Now[i].ID ; &#125; printf("%d\n", Ans) ; for (int i = 1 ; i &lt;= Ans ; i ++) &#123; int L = min(G[i].X[1], min(G[i].X[2], G[i].X[3])), R = max(G[i].X[1], max(G[i].X[2], G[i].X[3])) ; printf("%d ", R) ; for (int j = 1 ; j &lt;= 3 ; j ++) if (G[i].X[j] &lt; R &amp;&amp; G[i].X[j] &gt; L) printf("%d ", G[i].X[j]) ; printf("%d\n", L) ; &#125; return 0 ;&#125; Discounts 超市打折，如果购物车里有至少一个凳子，则可半价购买购物车里最便宜的一个物品。 现在你要购买$n$个物品，其中一些是凳子。你有$K$个购物车，求一个最优的购买方案，使得花费的价格最少。 $k \leq n \leq 10 ^ 5$ Codeforces 161B 贪心策略：对于所有的凳子，最好的情况是独占一个购物车。因此最好的决断是对于所有的凳子，使其尽量独占一个购物车，如果不能使所有的凳子独占一个购物车（K - 1 &lt; 凳子数），则将所有的凳子按降序排序之后从前往后填充，然后将剩下的凳子和非凳子的物品都放到最后一个购物车当中。 策略非常简单，但是写起来很麻烦，需要分类讨论$K - 1$和凳子数的关系，很是烦人，建议大家写一写，很能锻炼码力的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 1010 ;const int MAXM = 1010 ;const int INF = 0x7fffffff ;int N, K, C_T, O_T ;double Ans ;struct NODE &#123; int C, T, ID ;&#125; E[MAXN], Chair[MAXN], Othe[MAXN] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline bool CMP(NODE A, NODE B) &#123; return A.C &gt; B.C ;&#125;int main() &#123; N = Read() ; K = Read() ; for (int i = 1 ; i &lt;= N ; i ++) E[i].C = Read(), E[i].T = Read(), E[i].ID = i ; for (int i = 1 ; i &lt;= N ; i ++) if (E[i].T == 1) Chair[++ C_T] = E[i] ; for (int i = 1 ; i &lt;= N ; i ++) if (E[i].T == 2) Othe[++ O_T] = E[i] ; sort(Chair + 1, Chair + C_T + 1, CMP) ; if (C_T &gt; K - 1) &#123; for (int i = 1 ; i &lt;= K - 1 ; i ++) Ans += (double) Chair[i].C / 2 ; int Min = INF ; for (int i = 1 ; i &lt;= O_T ; i ++) Ans += Othe[i].C, Min = min(Min, Othe[i].C) ; for (int i = K ; i &lt;= C_T ; i ++) Ans += Chair[i].C, Min = min(Min, Chair[i].C) ; Ans -= (double) Min / 2 ; &#125; if (C_T &lt;= K - 1) &#123; for (int i = 1 ; i &lt;= C_T ; i ++) Ans += (double) Chair[i].C / 2 ; for (int i = 1 ; i &lt;= O_T ; i ++) Ans += Othe[i].C ; &#125; printf("%.1lf\n", Ans) ; if (C_T &gt;= K - 1) &#123; for (int i = 1 ; i &lt;= K - 1 ; i ++) cout &lt;&lt; "1 " &lt;&lt; Chair[i].ID &lt;&lt; endl ; cout &lt;&lt; O_T + C_T - K + 1 &lt;&lt; " " ; for (int i = K ; i &lt;= C_T ; i ++) cout &lt;&lt; Chair[i].ID &lt;&lt; " " ; for (int i = 1 ; i &lt;= O_T ; i ++) cout &lt;&lt; Othe[i].ID &lt;&lt; " " ; cout &lt;&lt; endl ; &#125; if (C_T &lt; K - 1) &#123; for (int i = 1 ; i &lt;= C_T ; i ++) cout &lt;&lt; "1 " &lt;&lt; Chair[i].ID &lt;&lt; endl ; for (int i = 1 ; i &lt;= K - C_T - 1 ; i ++) cout &lt;&lt; "1 " &lt;&lt; Othe[i].ID &lt;&lt; endl ; cout &lt;&lt; O_T - K + C_T + 1 &lt;&lt; " " ; for (int i = K - C_T ; i &lt;= O_T ; i ++) cout &lt;&lt; Othe[i].ID &lt;&lt; " " ; &#125; return 0 ;&#125; 叠罗汉 有$n$个罗汉，每个罗汉有重量$w$和力量$s$。 定义一个罗汉的危险值为他上面所有物品的重量之和减去他的力量。 安排一个顺序使得危险值最大的罗汉的危险值最小。 $n≤10^5$ 首先，我们可以发现对于两个罗汉$i$和$j$，他们之间的上下顺序对于下方所造成的的贡献是完全无关的，因此我们可以将整个问题拆分成一个个两罗汉的小问题逐一解决。假设这两个罗汉上方的罗汉一共重量G。 那么考虑这两个罗汉，如果是$i$在上面的话，那么他们两个造成的危险值是： Data_i = G - s_i Data_j = G +w_i - s_j如果是$j$在上面的话，造成的危险值是： Data_i = G +w_j - s_i Data_j = G - s_j讨论这两种情况可以发现当$w_i + s_i$比较小的时候造成的危险值最大的罗汉危险值最小，于是$w_i + s_i$比较小的罗汉放到上面比较优。所以最优解就是按照$w_i +s_i$排一下序就可以了。 建筑抢修 基地里有 $N$ 个建筑设施受到了严重的损伤，但只有 一个修理工人。 修复一个建筑都需要 T1 的时间，工人一次只能修一个。如果某个建筑在T2时间之内没有修理完毕 ，这个建筑就报废了。 你的任务是制订一个合理的维修顺序，以抢修尽可能多的建筑。 N ≤ 150000 JSOI2007 开始我是估摸着能找出来一个确定的枚举顺序，$sort$一下$O(N)$就处理完了。但是我把$T1$和$T2$反复折腾还是没有找出一个正确的顺序，因为我总是能够找出反例，一般这个时候这种类型的贪心就只有一种路可走了：按一定顺序先进行排序，然后在枚举过程中根据另一变量对当前枚举顺序做出修改。 这个地方一眼的枚举方式就是按照$T2$从小到大枚举，然后我们根据$T1$在此基础上对当前枚举顺序做一下调整。 假设当前使用了的总时间为$Tot$，如果$Tot + T1 &lt;= T2$，那么我们直接维修当前i就可以。 而如果建筑i不能在$T1$时间内修复，我们转而在之前已经修理过的所有建筑中选出$T1$最大的j号点来，如果$T1_j &gt; T2_i$那么我们更改决策，放弃$j$而修$i$。 这种决策为何是正确的就在于如果第$i$号建筑的出现时间不足，由于我们是按照$T2$进行排序，因此前面的节点最多修复了$i - 1$，那么我们就尽量选择$T1$总和较小的$i - 1$个建筑，给后面的决策留出更加充足的时间。因此，这个决策没有劣处。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const LL MAXN = 200010 ;const LL MAXM = 200010 ;const LL INF = 0x7fffffff ;LL Tot, Ans ;struct HOUSE &#123; LL T1, T2 ; bool operator &lt; (HOUSE B) const &#123; return T2 &lt; B.T2 ; &#125;&#125; E[MAXN] ;priority_queue &lt;long long&gt; Q ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;LL N = Read() ;int main() &#123; for (LL i = 1 ; i &lt;= N ; i ++) E[i].T1 = Read(), E[i].T2 = Read() ; sort(E + 1, E + N + 1) ; for (LL i = 1 ; i &lt;= N ; i ++) if (E[i].T1 + Tot &lt;= E[i].T2) Tot += E[i].T1, Q.push(E[i].T1), Ans ++ ; else if (Q.top() &gt; E[i].T1 &amp;&amp; Tot - Q.top() + E[i].T1 &lt;= E[i].T2) Tot -= Q.top() - E[i].T1, Q.pop(), Q.push(E[i].T1) ; printf("%lld", Ans) ; return 0 ;&#125; 删数问题 给定一个高精度的大正整数S（S最长可达240位），你需要去掉其中任意N位数字。剩下的数字按原次序组成一个新的正整数S’。 对给定的NS，寻找一种方案使得剩下的数字组成的新数S’最小。 LuoguP1106 这个题的话，不管花多长时间，我感觉最后所有人应该还是都想得出来的。所以我在这里就直接下结论了。 我们都知道贪心是可以由局部最优解推出全局最优解的，于是我们只要保证每一步都是最优的，那么最终答案也是最优的，因此我们每一次都选择使当前数字序列最大的方式进行删数。从高位到低位遍历，如果各位数字递增，那么删除最后一个数字，否则删除第一个递减区间的第一个数字。重复N次就可以了。（实际上就是删除第一个极大值啦。。。 而如何简化一下程序呢？题目要求我们删数，我们不妨设为选数，按照上方的思想，我们可以每次直接选取整个序列中最小的并且位数最高的一个数，然后将他的左边部分全部删去，然后对于左边的序列我们再次进行同样的操作就可以保证结果最优。至于如何证明这个情况，我建议大家从“答案这个数列的各个位数”方面入手分析。 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const LL MAXN = 300 ;const LL INF = 0x7fffffff ;string N ; int L, K, Data[MAXN], Last, Cnt, Min, T = 1, F ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; cin &gt;&gt; N &gt;&gt; K ; L = N.length() ; for (int i = 1 ; i &lt;= L ; i ++) Data[i] = N[i - 1] - '0' ; Last = L - K ; while (Cnt &lt; Last) &#123; Min = T ; for (int i = T ; i &lt;= K + T ; i ++) if (Data[Min] &gt; Data[i]) Min = i ; if (Data[Min]) F = 1 ; if (F) cout &lt;&lt; Data[Min] ; K -= Min - T, T = Min + 1, Cnt ++ ; &#125; if (! F) puts("0") ; return 0 ;&#125; 取数游戏 给出n个正整数，你需要把它们连接成一排，组成一个最大的多位整数。 例如：n=3时，3个整数13、312、343，连成的最大整数为34331213。 又如：n=4时，4个整数7、13、4、246，连成的最大整数为7424613。 $ n≤10^5$ 没错这是一道很水的题。只需要从高位向低位判断就可以了。 个屁。这样说起来好像是很容易但是仔细想一想怎么写你就会发现自己陷入一个很智障的无底洞。 我们考虑重新定义字符串的大小关系，对于两个字符串A, B如果$A后面接B$比$B后面接A$大，那么我们才定义$A &gt;B$，（12， 121） 然后我们对于所有的数都进行一次这样的比较，直接按照这样的法则sort就可以了。 兔子与樱花HEOI2015]]></content>
      <categories>
        <category>专题集训与赛事</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019十一集训二分与倍增专题]]></title>
    <url>%2F2019%2F10%2F02%2F2019%E5%8D%81%E4%B8%80%E9%9B%86%E8%AE%AD%E4%BA%8C%E5%88%86%E4%B8%8E%E5%80%8D%E5%A2%9E%E4%B8%93%E9%A2%98%2F</url>
    <content type="text"><![CDATA[第K大区间 定义一个区间的值为其众数出现的次数。现给出一个数列a[1…n]，求将所有区间的值排序后，第K大的值为多少。区间大小为1的不计。$1≤n≤10^5$ 我们首先可以发现这个玩意是有一个单调性的，就是对于一个区间$[L, R]$，如果将它向右扩展，那么这个区间的价值（也就是众数）一定是不降的。那么满足单调性我们显然可以二分，直接二分出一个答案$Ans$表示第K大值，病假设一个函数$F(X)$表示价值大于等于$X$的区间个数。则题目转化为$F(Ans) \geq K$的基础上最大化$Ans$。二分这个$X$,$F(X) \geq K$那么范围缩小到$[X, R]$，反之就缩小到$[L, X - 1]$。 基本的思路有了，接下来就剩一个求$F(X)$了。关于这个东西有一个叫做$two ~pointers$的算法可以很好地解决，简而言之就是维护两个指针$l, r$和一个表示$i$出现了几次的桶$T[i]$，从左向右扫就可以维护价值大于等于$X$的区间。 123456r = 0 ;for (int i = 1 ; i &lt;= N ; i ++) &#123; T[A[l - 1]] -- ; while(T[A[r]] &lt; X) r ++ ; F += N - r +1 ;&#125; 时间复杂度$O(NlogN)$ 聪明的质检员 小 T 是一名质量监督员，最近负责检验一批矿产的质量。这批矿产共有 n 个矿石，从 1 到 n 逐一编号，每个矿石都有自己的重量 $w_i$ 以及价值$v_i$ 。 检验矿产的流程是： 1.给定 $m$ 个区间$[L_i，R_i]$； 2.选出一个参数 $W$； 3.对于一个区间 $[L_i，R_i ]$，计算矿石在这个区间上的检验值 $y$ ： y_{i}=\left(\sum_{j} 1\right) \times\left(\sum_{j} v_{j}\right), j \in\left[L_{i j}, R_{i}\right] 且 w_{j} \geq W也就是 $w$ 大于等于 $W$ 的个数和乘以价值和。 这批矿产的检验结果 $Y=∑_{i=1}^ny_i$ 上头给了个标准值$S$，他希望你帮他调整参数 $W$ 的值，使 $|S-Y|$ 最小。 Noip2011 这个显然是要求我们二分$W$，但是如果你真的直接去二分$W$然后一个一个地计算检验的话，时间复杂度是$O(NMLogN)$显然是会炸掉的。 首先考虑单调性，我们发现当$W$变大的时候，$y$显然是会变小的，因为符合条件的矿石变少了嘛。所以$Y$也显然会跟着变小，那么$S - Y$就会变大。而至于加上绝对值，就需要分类讨论一下了。 不管这个，因为Y可以被表示成一个关于W的函数，我们设这个函数位$F(W)$，那么因为其单调不升，所以我们就可以将问题转化为求$|F(W) - S|$的最小值。而这个$F(W)$我们显然不能直接按照给的式子进行计算，我们统计对于已经确定的$W$，有贡献的$A[i]$个数的前缀和$Sum0$和$A[i]$的前缀和$Sum1$。然后计算就变成： y_i = (Sum0_{R_i} - Sum0_{L_i - 1}) * (Sum1_{R_i} - Sum1_{L_i - 1})就变成了$O(N)$的啦，配合上二分就可以$O(NlogN)$解决啦。 数比较大，记得开$long~long$ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const LL MAXN = 200010 ;const LL MAXM = 200010 ;const LL INF = 0x3f3f3f3f3f3f3f3f ;LL N, M, S, W[MAXN], V[MAXN], Sum0[MAXN], Sum1[MAXN], Max = - INF, Min = INF, Ans = INF ;struct SQU &#123; LL L, R ;&#125; E[MAXN &lt;&lt; 1] ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read() ; M = Read() ; S = Read() ; for (LL i = 1 ; i &lt;= N ; i ++) W[i] = Read(), V[i] = Read(), Max = max(Max, W[i]), Min = min(Min, W[i]) ; for (LL i = 1 ; i &lt;= M ; i ++) E[i].L = Read(), E[i].R = Read() ; LL L = Min - 1, R = Max + 2, WW ; while (L &lt;= R) &#123; WW = (L + R) &gt;&gt; 1 ; for (LL i = 1 ; i &lt;= N ; i ++) Sum0[i] = Sum1[i] = 0 ; for (LL i = 1 ; i &lt;= N ; i ++) &#123; if (W[i] &gt;= WW) Sum0[i] = Sum0[i - 1] + 1, Sum1[i] = Sum1[i - 1] + V[i] ; else Sum0[i] = Sum0[i - 1], Sum1[i] = Sum1[i - 1] ; &#125; LL Y = 0 ; for (LL i = 1 ; i &lt;= M ; i ++) Y += (Sum0[E[i].R] - Sum0[E[i].L - 1]) * (Sum1[E[i].R] - Sum1[E[i].L - 1]) ; if (Y &gt; S) L = WW + 1 ; else R = WW - 1 ; if (abs(Y - S) &lt; Ans) Ans = abs(Y - S) ; &#125; printf("%lld\n", Ans) ; return 0 ;&#125; 跳石头 一年一度的“跳石头”比赛又要开始了！ 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块距离为 L 的岩石作为比赛起点和终点。在起点和终点之间，有 N 块岩石(不含起点和终点的岩石)。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石(不能移走起点和终点的岩石)。 $0≤M≤N≤50000, 1≤L≤10^9$。 Noip2015 额，这时间上就是一个很纯的二分，考虑单调性，显而易见地发现移走的石头越多，那么最短跳跃的最大值就越大，额，起码不会减就是了。然后就直接枚举最短跳跃的最大值，然后从头开始判断，记录最少要移走的石头的个数与M比较一下看看是否合法就可以了。 怎么算这个最少要移走的石头的个数其实可以人类智慧法，你发现如果枚举到一个$i$与$i - 1$的距离，它是小于我们二分的值$Mid$的，那么我们把这块石头移走就可以了。这样的答案一定是最优的，好像可以用反证法来证明，但是我觉得直觉就足以告诉你最优解了，这也是为什么目前普遍认为这道题的水平并不是很高的原因。 至于怎么操作叫移去这个石头，你可以记录一下上一个石头的下标嘛。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 200010 ;const int MAXM = 200010 ;const int INF = 0x7fffffff ;int Len, N, M, D[MAXN], Cnt = 0, Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; Len = Read() ; N = Read() ; M = Read() ; for (int i = 1 ; i &lt;= N ; i ++) D[i] = Read() ; int L = 0, R = Len ; while (L &lt;= R) &#123; int Mid = (L + R) &gt;&gt; 1, Pas = 0 ; Cnt = 0 ; for (int i = 1 ; i &lt;= N ; i ++) &#123; if (D[i] - D[Pas] &lt; Mid) Cnt ++ ; else Pas = i ; &#125; if (Cnt &gt; M) R = Mid - 1 ; else L = Mid + 1, Ans = Mid ; &#125; printf("%d\n", Ans) ;&#125; 借教室 我们需要处理$n$天的借教室信息，其中第 i 天学校有$ r_i $个教室可供租借。 共有$m$份订单，每份订单用三个正整数描述，分别为$d_j,s_j,t_j，$表示某租借者需要从第$s_j$天到第$t_j$天租借教室（包括第$s_j$天和第$t_j$天），每天需要租借$d_j$个教室。 借教室的原则是先到先得，也就是说我们要按照订单的先后顺序依次为每份订单分配教室。如果在分配的过程中遇到一份订单无法完全满足，则需要停止教室的分配，通知当前申请人修改订单。这里的无法满足指从第$s_j$天到第$t_j$天中有至少一天剩余的教室数量不足$d_j$个。 现在我们需要知道，是否会有订单无法完全满足。如果有，需要通知哪一个申请人修改订单。 $1≤n,m≤10^6, 0≤r_i,d_j≤10^9,1≤s_j≤t_j≤n$。 Noip2012 首先依然是考虑单调性，很容易发现，第$i$天肯定比$i + 1$天更容易满足需求，并且如果$i$天满足不了，那么接下来也不可能满足。单调性已有，那么考虑二分。 如何验证前 i 天是否满足条件？ 由于天数已经固定了，需求也就固定了。问题转化为，有很多次离线区间加，最后要求判断每一个元素是否小于$ d $。离线区间加我们可以差分后使用前缀和的技巧来解决：设数组$s[1..n]$，对于所有区间$[l,r]$整体$+c$的操作，我们令$s[l]+=c,s[r+1]-=c$这样做完之后，我们枚举位置$i=1~n$,同时设变量add。每当访问到一个位置$i$，$add+=s[i]，a[i]+=add$。这样就解决了区间加的问题。 复杂度：$O((n+m) log⁡m)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#define MAXN 1000010#define Inf 0x7fffffff#define LL long longusing namespace std ;LL Read()&#123; LL X = 0 ; char ch = getchar() ; while(ch &gt; '9' || ch &lt; '0') ch = getchar() ; while(ch &gt;= '0' &amp;&amp; ch &lt;= '9') X = (X &lt;&lt; 1) + (X &lt;&lt; 3) + (ch ^ 48), ch = getchar() ; return X ;&#125;LL Before[MAXN] ;LL N, M, Room[MAXN] ;LL Rest[MAXN + 1] ;struct Make&#123; LL Data, L, R ;&#125;Edge[MAXN] ;LL L, R, Mid;bool Search(LL Now)&#123; for(int i = 1; i &lt;= Now; i ++)&#123; Rest[Edge[i].L] += Edge[i].Data ; Rest[Edge[i].R + 1] -= Edge[i].Data ; &#125; for(int i = 1; i &lt;= N ; i ++)&#123; Room[i] = Rest[i] + Room[i - 1] ; if(Room[i] &gt; Before[i]) return 0 ; &#125; return 1 ;&#125;int main()&#123; N = Read(), M = Read() ; for(int i = 1; i &lt;= N; i ++) Before[i] = Read() ; for(int i = 1; i &lt;= M; i ++)&#123; Edge[i].Data = Read() ; Edge[i].L = Read() ; Edge[i].R = Read() ; &#125; L = 0; R = M + 1 ; while(L &lt; R)&#123; memset(Rest, 0, sizeof(Rest)) ; memset(Room, 0, sizeof(Room)) ; Mid = (L + R) &gt;&gt; 1 ; int Num = Search(Mid) ; if(! Num) R = Mid ; else L = Mid + 1 ; &#125; if(0 &lt; L &amp;&amp; L &lt;= M) printf("-1\n%d", L) ; else puts("0") ; return 0 ;&#125; 这种做法是有可能被卡的，因此还可以用一些数据结构进行优化，但是已经超出了本题的范围，在这里不再探究。 妮厨的愤怒 对于一个字符串$S[1…n]$，询问$q$次，每次询问$[l,r]$内最长的回文串。 $1≤n ,q≤10^5，0≤l≤r&lt;n$ ，只包含小写拉丁字母]]></content>
      <categories>
        <category>专题集训与赛事</category>
      </categories>
      <tags>
        <tag>二分</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2005]午餐]]></title>
    <url>%2F2019%2F10%2F01%2FZJOI2005-%E5%8D%88%E9%A4%90%2F</url>
    <content type="text"><![CDATA[Link两个窗口不是很好想，那么首先我们需要确定一个窗口内的打饭顺序。考虑对于一个窗口的所有人，假设这些人不变，那么不管这个窗口的人的排列是怎么样的，其打饭的时间永远都是所有排队的人的打饭时间的和，那么，但是我们仍然需要考虑所有人打完饭之后仍然会有人在吃饭的问题，于是考虑将吃饭时间长的人排在前面。如何解释想必不用我说了，这种东西稍微想一想应该是可以明白的。那么首先的算法确定为一个贪心的排序处理，按照吃饭时间从大到小排序。之后我们要考虑的就是谁在1号窗口，谁在二号窗口，这个DP数组应该还是比较好想的，一般来说首先想到的的就是一个三位数的数组$F[i][j][k]$,表示前i个人，j个人在1号窗口，k个人在2号窗口吃完饭的最早时间。而显然我们可以看到k = i - j，于是我们省下来一维。然后怎么转移呢，首先可以考虑维护一个打饭时间前缀和Sum[]，对于第i个人，只有两种方案可以转移，就是1号窗口和2号窗口，分别是这样的： Dp[i][j] = min(Dp[i][j], max(Dp[i - 1][j - E[i].X], j + E[i].Y)) ;这个玩意是什么意思呢？就是说，我们在这个转移之中需要考虑第i个人和第i - 1个人的打饭和吃饭时间。目前，第i - 1个人刚刚打完饭去吃饭，然后第i个人来打饭，打完饭之后吃饭，然后这两个人的回合结束，那么结束时间以谁为准呢？当然是时间长的那个，那么我们那就比较第i - 1个人的吃饭时间，和第i个人的打饭时间+吃饭时间，取最优。对于上面那个式子，$Dp[i][j] = Dp[i - 1][j - E[i].X]$时就是说i - 1赢过了i，那么就没有任何影响，但是当$Dp[i][j] = j + E[i].Y$的时候代表i赢过了i - 1，于是需要相应的变换。然后我们如上就等到第二号窗口的状态转移方程： Dp[i][j] = min(Dp[i][j], max(Dp[i - 1][j], Sum[i] - j + E[i].Y)) ;1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 210 ;const int MAXM = 210 ;const int INF = 0x7fffffff ;int N, Tot1, Tot2, Sum[MAXN], Dp[MAXN][MAXN * MAXM], Ans = INF ;struct Person &#123; int X, Y ;&#125; E[MAXN] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline bool CMP(Person A, Person B) &#123; return A.Y &gt; B.Y ;&#125;int main() &#123; N = Read() ; for (int i = 1 ; i &lt;= N ; i ++) E[i].X = Read(), E[i].Y = Read() ; sort(E + 1 , E + N + 1, CMP) ; for (int i = 1 ; i &lt;= N ; i ++) Sum[i] = Sum[i - 1] + E[i].X ; memset(Dp, 127, sizeof(Dp)) ; Dp[0][0] = 0 ; for (int i = 1 ; i &lt;= N ; i ++) for (int j = 0 ; j &lt;= Sum[i] ; j ++) &#123; if (j &gt;= E[i].X) Dp[i][j] = min(Dp[i][j], max(Dp[i - 1][j - E[i].X], j + E[i].Y)) ; Dp[i][j] = min(Dp[i][j], max(Dp[i - 1][j], Sum[i] - j + E[i].Y)) ; &#125; for (int i = 0 ; i &lt;= Sum[N] ; i ++) Ans = min(Ans, Dp[N][i]) ; printf("%d\n", Ans) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Uva12169]Disgruntled Judge]]></title>
    <url>%2F2019%2F10%2F01%2FUva12169-Disgruntled-Judge%2F</url>
    <content type="text"><![CDATA[Link 这个题没有那么麻烦，实际上来说是有一些奇怪的，因为在你听完之后你会感到这个题真的是非常非常的简单。怎么说呢，由上面那个递推公式： X_i = (A \times x_(i - 1) + B) ~ mod ~ 10001那么一定有$X_2 = (A \times X_1 + B) ~ mod ~ 10001$$X_3 = (A \times X_2 + B) ~ mod ~ 10001$那么显然我们可以把这两个式子合起来，也就是： X_3 = (A \times ((A \times X_1 + B) ~ mod ~ 10001) _ B) ~ mod ~ 10001化简一下： B = \frac{X_3 - A ^ 2 X_1}{A + 1}那么假设我们知道了A，因为我们一定知道$X_1$, $X_3$，就可以根据上面这个式子直接知道B，那么转而来看A的数据范围，只有1000，也就是说假设我只是简单地枚举A时间也是够的。于是我们枚举A然后推出B，然后就可以在$O(TA)$的时间复杂度内取得可行解。当然在处理的时候我们仍然需要考虑到逆元。至于如何判断该解可行，你只需要奇偶一起推，当你推出来的奇数序号的数和输入有悖时，这个A就是不可行的咯。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std ;typedef long long LL ;const LL MAXN = 10010 ;const LL MAXM = 100010 ;const LL INF = 0x7fffffff ;const LL Mod = 10001 ;LL T, B, X[MAXN], F = 1, Y[MAXN], Inv[MAXN] ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline LL Exgcd(LL A, LL B, LL &amp; X, LL &amp; Y) &#123; if (! B) &#123; X = 1, Y = 0 ; return A ; &#125; else &#123; LL Ans = Exgcd(B, A % B, X, Y) ; LL Tmp = X ; X = Y ; Y = Tmp - (A / B) * Y ; return Ans ; &#125;&#125;inline LL Init(LL A) &#123; LL X, Y ; LL Tmp = Exgcd(A, Mod, X, Y) ; X /= Tmp ; X = (X % Mod + Mod) % Mod ; return X ;&#125;int main() &#123; T = Read() ; for (LL i = 1 ; i &lt;= 10001 ; i ++) Inv[i] = Init(i) ; for (LL i = 1 ; i &lt;= 2 * T ; i += 2) X[i] = Read() ; Y[1] = X[1] ; for (LL A = 0 ; A &lt;= 10001 ; A ++) &#123; F = 1 ; B = ((X[3] - A * A *X[1]) % Mod + Mod) % Mod ; B = B * Inv[A + 1] % Mod ; for (LL i = 2 ; i &lt;= 2 * T ; i ++) &#123; if (i % 2 == 1) &#123; Y[i] = (A * Y[i - 1] + B) % 10001 ; if (Y[i] != X[i]) &#123; F = 0 ; break ; &#125; &#125; else Y[i] = (A * Y[i - 1] + B) % 10001 ; &#125; if (F == 1) &#123; for (LL i = 2 ; i &lt;= 2 * T ; i += 2) printf("%lld\n", Y[i]) ; return 0 ; &#125; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Uva</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2019%2F09%2F27%2FContest%20Nowcoder1090%20-%20TG%20Months%2012%2F</url>
    <content type="text"><![CDATA[T1 小w的进制转换 小$w$在将一个$10$进制数转换为二进制数的时候，不小心将“$0$”和“$1$”搞混了，也就是说本来该输出$1$的时候他输出了$0$，本来该输出0的时候他又输出了$1$。而他在输出答案的时候，又将输出的左右顺序搞混了。举个例子：小$w$将$6$转换为二进制，本来$6$的二进制表示为$110$，但是小$w$转换成了$001$，输出时又倒了过来变成$100$。现在假设评测姬中的评测数据是$1,2,3,4,5,6…n$也就是从$1$到$n$，问小$w$能$AC$其中的多少组测试案例？ 这个东西是一个很纯的进制题，题目大意就是计数合法的串，满足各位异或1之后调转整个序列使得与原序列相同。也就是让你求“反对称01串”的个数。显然奇数长度的串是不会合法的，那么考虑偶数长度的串，推一推样例可以发现第$N$个符合长度的串就是$N$的二进制接上$N$的反对称串，熟悉位运算的话实际上就是一个模拟题，思维难度不大，就是看你能不能掌握位运算了。。。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#define Half (Len &gt;&gt; 1)using namespace std ;typedef long long LL ;const LL MAXN = 110 ;const LL INF = 0x7fffffff ;LL T, N, A[MAXN], Len, Old, Ans ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; T = Read() ; while (T --) &#123; N = Read() ; Old = N ; Len = 0, Ans = 0 ; while (Old) &#123; LL X = Old % 2 ; if (X == 1) A[++ Len] = 1 ; else A[++ Len] = 0 ; Old &gt;&gt;= 1 ; &#125; for (int i = 1 ; i &lt;= Half ; i ++) swap(A[i], A[Len - i + 1]) ; if (Len &amp; 1) for (int i = 1 ; i &lt;= Half ; i ++) Ans += 1 &lt;&lt; (i - 1) ; else &#123; for (int i = 1 ; i &lt;= (Half - 1) ; i ++) Ans += 1 &lt;&lt; i - 1 ; for (int i = 2 ; i &lt;= Half ; i ++) if (A[i]) Ans += 1 &lt;&lt; (Half - i) ; Old = 0 ; LL Old2 = 0 ; for (int i = 1 ; i &lt;= Half ; i ++) Old = (Old &lt;&lt; 1) + A[i] ; for (int i = Half ; i &gt;= 1 ; i --) Old2 = (Old2 &lt;&lt; 1) - A[i] + 1 ; if ((Old &lt;&lt; Half) + Old2 &lt;= N) Ans ++ ; &#125; printf("%lld\n", Ans) ; &#125; return 0 ;&#125; T2 小doge的快乐阳光跑 每次开始阳光跑，会在n个点里随机生成好多点位，并且需要按照点位顺序跑. 当且仅当，阳光跑随机生成的点位序列（注意顺序）是你跑步序列的一个子序列时，你完成阳光跑。 某一个序列的子序列指的是，保留该序列的顺序并删除一些元素或者不进行删除后的结果。 小$doge$是一个乐于助人的好孩子，他常常帮助别人跑步。 这天，小$doge$想要完成自己的阳光跑并且顺便帮助小$w$一起完成即一个人完成两人的任务，并且两个人的任务是独立的，小$doge$有$a$个点位，小$w$有$b$个点位。小$doge$想要最效率的跑法，所以他想知道他最少要跑多远。小$doge$可以选择任何一个点出发。 对于阳光跑的要求，我们如下定义：有$n$个有顺序的点位$a_1到a_n$，想要完成阳光跑，必须按照顺序依次经过每个点位，并且在到达前一个点位后到达下一个点位才有效。 搬过来的题解里面的题意简化：给一张图，求一个权值和路径最小的移动序列，使得移动序列包含两个给定的子序列。（早这样说多好 这题很显然你应该求一个最短路，想用$Floyed$的大可不必了，数据范围对于$A$和$B$来说只有$100$，所以我们可以直接对于每一个$A$和$B$中的点为起点跑一遍$SPFA$，时间上是没有问题的。现在有了$D[i][j]$之后我们就可以进行$Dp$了，设$Dp[i][j][0/1]$，表示当前完成了$A$的第$i$位和$B$的第$j$位，然后$0$为停留在$A$路径上，$1$为停留在$B$路径上。转移方程还是需要推一推的。 1234Dp[i][j][0] = min(Dp[i][j][0], Dp[i - 1][j][0] + D[La[i - 1]][La[i]]) ;Dp[i][j][0] = min(Dp[i][j][0], Dp[i - 1][j][1] + D[Lb[j]][La[i]]) ;Dp[i][j][1] = min(Dp[i][j][1], Dp[i][j - 1][1] + D[Lb[j - 1]][Lb[j]]) ;Dp[i][j][1] = min(Dp[i][j][1], Dp[i][j - 1][0] + D[La[i]][Lb[j]]) ; 看起来非常的整齐（嗯 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const LL MAXN = 1010 ;const LL MAXM = 10010 ;const LL MAXA = 110 ;const LL INF = 0x7fffffff ;LL N, M, H[MAXN], Tot, A, B, Dp[MAXA][MAXN][2] ;LL La[MAXN], Lb[MAXN], D[MAXN][MAXN], Ans = 0 ;struct Node &#123; LL F, T, L, Next ;&#125; E[MAXM &lt;&lt; 1 &lt;&lt; 1] ;bool Vis[MAXN] ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add(LL F, LL T, LL L) &#123; E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ; E[Tot].Next = H[F] ; H[F] = Tot ;&#125;inline void Spfa(LL F) &#123; queue &lt;LL&gt; Q ; memset(Vis, 0, sizeof (Vis)) ; D[F][F] = 0 ; Vis[F] = 1 ; Q.push(F) ; while (! Q.empty()) &#123; LL Now = Q.front() ; Q.pop() ; Vis[Now] = 0 ; for (LL i = H[Now] ; i ; i = E[i].Next) if (D[F][E[i].T] &gt; D[F][Now] + E[i].L) &#123; D[F][E[i].T] = D[F][Now] + E[i].L ; if (! Vis[E[i].T]) Q.push(E[i].T), Vis[E[i].T] = 1 ; &#125; &#125;&#125;int main() &#123; N = Read() ; M = Read() ; for (LL i = 1 ; i &lt;= M ; i ++) &#123; LL X = Read(), Y = Read(), Z = Read() ; Add(X, Y, Z) ; Add(Y, X, Z) ; &#125; memset(D, 127, sizeof (D)) ; A = Read() ; for (LL i = 1 ; i &lt;= A ; i ++) La[i] = Read(), Spfa(La[i]) ; B = Read() ; for (LL i = 1 ; i &lt;= B ; i ++) Lb[i] = Read(), Spfa(Lb[i]) ; memset(Dp, 127, sizeof (Dp)) ; Dp[0][0][0] = Dp[0][0][1] = 0 ; for (LL i = 1 ; i &lt;= N ; i ++) D[0][i] = 0 ; for (LL i = 1 ; i &lt;= A ; i ++) Dp[i][0][0] = Dp[i - 1][0][0] + D[La[i - 1]][La[i]] ; for (LL i = 1 ; i &lt;= B ; i ++) Dp[0][i][1] = Dp[0][i - 1][1] + D[Lb[i - 1]][Lb[i]] ; for (LL i = 1 ; i &lt;= A ; i ++) for (LL j = 1 ; j &lt;= B ; j ++) &#123; Dp[i][j][0] = min(Dp[i][j][0], Dp[i - 1][j][0] + D[La[i - 1]][La[i]]) ; Dp[i][j][0] = min(Dp[i][j][0], Dp[i - 1][j][1] + D[Lb[j]][La[i]]) ; Dp[i][j][1] = min(Dp[i][j][1], Dp[i][j - 1][1] + D[Lb[j - 1]][Lb[j]]) ; Dp[i][j][1] = min(Dp[i][j][1], Dp[i][j - 1][0] + D[La[i]][Lb[j]]) ; &#125; printf("%lld\n", min(Dp[A][B][0], Dp[A][B][1])) ; return 0 ;&#125; T3 区间异或和异或区间最大值异或区间最小值 小$w$学会了$RMQ$算法，他现在可以求出一个给定数组某一段子区间的最大值，最小值。在这之前，他也学会了前缀和，并且他知道前缀和可以扩展到位运算求出区间异或和。 现在你给了他一个长度大小为$n$的数组，为了考察小$w$写$RMQ$以及前缀异或和的正确性，你要求他求出该数组的某一个子区间，记该子区间的异或和为$xorsum$，记该子区间的最大值为$max$，记该子区间的最小值为$min$，你要求使得$xorsum⊕max⊕min$最大。其中$⊕$为位运算异或操作。 看起来就是一道很毒瘤的数据结构题，（从题目名字就看得出来好嘛 先考虑考虑部分分吧。首先我们得知道一个原理$A⊕B⊕B =A$，相当于一个数两次异或另一个数答案是不变的。那么对于答案所求就是去掉最大值和最小值之后的区间异或和。对于区间最大值和区间最小值我们可以使用$RMQ$进行维护，对于$Sumxor$我们可以使用前缀和进行维护，于是对于确定区间的求值就只$O(1)$的，我们枚举区间的左右端点，时间复杂度就是$O(N^2)$的。 但是出题人十分毒瘤，导致$O(N^2)$只能过$30\%$的点，这就有些不良心了。。 接下来想正解，发现这个序列实际上是可以用分治瞎搞进行维护的，对于该区间取中点$Mid$，然后考虑从左端点在$Mid$左侧，右端点在$Mid$右侧的所有子区间，它们有一个共性就是一定是由一个从$Mid$开始往左延伸的区间和从$Mid$开始往右延伸的区间拼接得到的（意会），对于这两个区间我们需要找到一个支持快速插入以及查询的数据结构来进行维护从$Mid$向左延伸的区间的贡献，之后再遍历往右的区间。 这样我们就处理完了所有左端点在$Mid$左侧，右端点在$Mid$右侧的子区间，那么之后直接递归计算$[L, Mid]和[Mid +1, R]$就可以了。 回想这个数据结构，我们发现字典树可以较好地解决这个问题，我们只需要将异或和放入字典树中，然后分类讨论： 左侧区间提供最大值最小值 右侧区间提供最大值最小值 左侧区间提供最大值，右侧区间提供最小值 左侧区间提供最小值，右侧区间提供最大值 并且，由于显而易见的是随着区间延伸最大值单调不减，最小值单调不升，所以我们枚举极值的时候有一个双单调性，因此可以考虑尺取法，之中对于以上四种情况分类讨论即可。 思维难度颇大，鄙人在考场上大致也只能想出来$O(N^2)$暴力做法。（没准还可以水一水特殊数据点？]]></content>
      <categories>
        <category>专题集训与赛事</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>进制</tag>
        <tag>字典树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[USACO18FEB-Making the Grade]]></title>
    <url>%2F2019%2F07%2F22%2FUSACO08FEB-Making%20the%20Grade%2F</url>
    <content type="text"><![CDATA[Link大概就是给你一段序列，然后让你对一些数做出一些调整，最后使得这个序列单调不升或者单调不减。显然是一个动态规划问题，而较为显然的是对于每一个数，要么不修改，要么就是修改成原来序列中的某一个数的值。至于为什么，大家可以手推几组数据，或者说来看一下一个错误的贪心法。对于每一个数我们将它修改成相邻两个数中的差值最小的一个，然后就可以保证单调性。但是这样显然是不对的，因为它具有单调性，自己改变之后后面一个数修改的情况有可能也会发生改变。但是我们依然可以知道：数的修改一定存在于当前序列的数中这一点是没错的。因此首先我们进行排序，那么原序列$A$最终肯定要变成这个排完序之后的序列$B$，于是我们就有了$DP$的思路。设$Dp[i][j]$表示第$i$个数修改成$j$的最小花费，然后就有 Dp[i][j] = min(Dp[i - 1][k] + abs(A[i] - B[j])) ;加个单调队列就可以$O(N^2)$过了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 2010 ;const int MAXM = 2010 ;const int INF = 1e9 ;int N, Tall[MAXN], Old[MAXN], Dp[MAXN][MAXN], Q[MAXN], Ans = INF, T ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read() ; for (int i = 1 ; i &lt;= N ; i ++) Tall[i] = Read(), Old[i] = Tall[i] ; sort(Old + 1, Old + N + 1) ; for (int i = 1 ; i &lt;= N ; i ++) &#123; T = 0 ; for (int j = 1 ; j &lt;= N ; j ++) &#123; while (T &amp;&amp; Dp[i - 1][j] &lt; Dp[i - 1][Q[T]]) T -- ; Q[++ T] = j ; Dp[i][j] = Dp[i - 1][Q[1]] + abs(Tall[i] - Old[j]) ; &#125; &#125; for (int i = 1 ; i &lt;= N ; i ++) Ans = min(Ans, Dp[N][i]) ; memset(Dp, 0, sizeof (Dp)) ; for (int i = 1 ; i &lt;= N ; i ++)&#123; T = 0 ; for (int j = N ; j &gt;= 1 ; j --) &#123; while (T &amp;&amp; Dp[i - 1][j] &lt; Dp[i - 1][Q[T]]) T -- ; Q[++ T] = j ; Dp[i][j] = Dp[i - 1][Q[1]] + abs(Tall[i] - Old[j]) ; &#125; &#125; for (int i = 1 ; i &lt;= N ; i ++) Ans = min(Ans, Dp[N][i]) ; printf("%d", Ans) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO05DEC]布局]]></title>
    <url>%2F2019%2F05%2F26%2FUSACO05DEC-%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Link 又是一道差分约束新系统的裸题，直接上最短路就可以。对于两个点之间的距离小于某个数，直接$Add(X, Y, Z)$就行。对于两个点之间的距离大于等于某个数，直接$Add(Y, X, - Z)$就行。但是这个题确实是有坑点的，就是这个图是有可能不连通的，因此你必须还得做一次判断，看这个图是否连通。很简单，就是取一个新的节点0，然后把他和所有的节点连起来$Add(0, i, 0)$，然后$Spfa(0)$一次就可以了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;const int Inf = 100000000 ;int N, ML, MD, Tot, H[MAXN], Num[MAXN] ;struct Node &#123; int F, T, L, Next ;&#125; E[MAXN &lt;&lt; 1] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add(int F, int T, int L) &#123; E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ; E[Tot].Next = H[F] ; H[F] = Tot ;&#125;#define LS (Now &lt;&lt; 1)#define RS ((Now &lt;&lt; 1) | 1)#define Mid ((L + R) &gt;&gt; 1)#define E_Mid ((E[Now].L + E[Now].R) &gt;&gt; 1)struct TREE &#123; int L, R, Sum, Tag ;&#125; E[MAXN &lt;&lt; 1] ;inline void Push_Up(int Now) &#123; &#125;int D[MAXN] ; bool V[MAXN] ;inline void Spfa(int S) &#123; for (int i = 1 ; i &lt;= N ; i ++) D[i] = Inf, V[i] = false, Num[i] = 0 ; D[S] = 0 ; V[S] = true ; queue &lt;int&gt; Q ; Q.push(S) ; while (! Q.empty()) &#123; int Now = Q.front () ; V[Now] = false ; Q.pop() ; for (int i = H[Now] ; i ; i = E[i].Next) if (D[E[i].T] &gt; D[Now] + E[i].L) &#123; D[E[i].T] = D[Now] + E[i].L ; Num[E[i].T] = Num[Now] + 1 ; if (Num[E[i].T] &gt;= N) &#123; printf("-1") ; exit(0) ; &#125; if (! V[E[i].T]) V[E[i].T] = true, Q.push(E[i].T) ; &#125; &#125; for (int i = 1 ; i &lt;= N ; i ++) cout &lt;&lt; E[i].F &lt;&lt; " " &lt;&lt; E[i].T &lt;&lt; " " &lt;&lt; E[i].Next &lt;&lt; endl ;&#125;int main() &#123; N = Read() ; ML = Read() ; MD = Read() ; for (int i = 1 ; i &lt;= N ; i ++) Add(0, i, 0) ; for (int i = 1 ; i &lt;= ML ; i ++) &#123; int A = Read(), B = Read(), C = Read() ; Add(A, B, C) ; &#125; for (int i = 1 ; i &lt;= MD ; i ++) &#123; int A = Read(), B = Read(), C = Read() ; Add(B, A, - C) ; &#125; Spfa(0) ; Spfa(1) ; if (D[N] == Inf) printf("-2") ; else printf("%d\n", D[N]) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>USACO</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2011]糖果]]></title>
    <url>%2F2019%2F05%2F26%2FSCOI2011-%E7%B3%96%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[Link一道非常好的差分约束系统的板子题，正好可以借此回顾一下差分约束的有关内容。假设我们现在有N个方程，$X_1 - X_2 \leq 0$$X_1 - X_5 \leq 1$$X_2 - X_5 \leq 1$$X_3 - X_1 \leq 5$$X_4 - X_1 \leq 4$$X_4 - X_3 \leq - 1$$X_5 - X_3 \leq - 3$$X_5 - X_4 \leq - 3$这样第一个方程组，我们当然可以解不等式组，但是如果我们要求电脑计算的话就需要一些方法，比如说最短路对于这道题来说，我们对于每一种情况。 Add(X, Y, 0), Add(Y, X, 0) ; Add(X, Y, 1) ; Add(Y, X, 0) ; Add(Y, X, 1) ; Add(X, Y, 0) ;并且还要特判一下当$Type = 2$ 或 $4$ 的时候，如果$X == Y$那么久一定是没有解的。然后直接跑SPFA就是了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ; const LL MAXN = 1000100 ;const LL MAXM = 1000100 ;const LL Inf = 1000000000 ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;LL N, M, H[MAXN], Tot, D[MAXN], INQ[MAXN], F, Num[MAXN] ;struct Node &#123; LL F, T, L, Next ;&#125; E[MAXM &lt;&lt; 1] ;inline void Add(LL F, LL T, LL L) &#123; E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ; E[Tot].Next = H[F] ; H[F] = Tot ;&#125;inline long long Spfa(LL S) &#123; queue &lt;LL&gt; Q ; for (register LL i = 1 ; i &lt;= N ; i ++) D[i] = 0, INQ[i] = 0, Num[i] = 0 ; Q.push(S) ; D[S] = 0 , INQ[S] = 1 ; while (! Q.empty()) &#123; LL Now = Q.front() ; Q.pop() ; INQ[Now] = 0 ; if (Num[Now] == N - 1) return - 1 ; Num[Now] ++ ; for (register LL i = H[Now] ; i ; i = E[i].Next) if (D[E[i].T] &lt; D[Now] + E[i].L) &#123; D[E[i].T] = D[Now] + E[i].L ; if (! INQ[E[i].T]) Q.push(E[i].T), INQ[E[i].T] = 1 ; &#125; &#125; long long Ans = 0 ; for (LL i = 1 ; i &lt;= N ; i ++) Ans += D[i] ; return Ans ;&#125;int main() &#123; //freopen("testdata.in", "r", stdin) ; N = Read() ; M = Read() ; for (register LL i = 1 ; i &lt;= M ; i ++) &#123; LL Type = Read(), X = Read(), Y = Read() ; if (Type == 1) Add(X, Y, 0), Add(Y, X, 0) ; if (Type == 2) Add(X, Y, 1) ; if (Type == 3) Add(Y, X, 0) ; if (Type == 4) Add(Y, X, 1) ; if (Type == 5) Add(X, Y, 0) ; if (Type == 2 || Type == 4) if (X == Y) return puts("-1"), 0 ; &#125; for (register LL i = N ; i &gt;= 1 ; i --) Add(0, i, 1) ; printf("%lld\n", Spfa(0)) ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵树定理及其应用（未完成）]]></title>
    <url>%2F2019%2F04%2F04%2F%E7%9F%A9%E9%98%B5%E6%A0%91%E5%AE%9A%E7%90%86%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这个东西首次出现在周冬的国家集训队论文里面，解决的问题叫做生成树计数问题。顾名思义，就是让你求一张无向图中生成树的个数。首先我们要知道三个概念。 邻接矩阵A这个东西不用我说了吧，就是对于每一条边$Edge_{ij}$，矩阵的$i$行$j$列和$j$行$i$列设为1，其他设为0。 度数矩阵D啥意思呢，就是将每一个点的度数，其中对于每一个不相等的$i,j$有$D[i][j] = 0$ 基尔霍夫矩阵C$C = D - A$ 而Matrix-Tree定理就是说这个无向图的生成树个数就等于基尔霍夫矩阵的任意一个$N - 1$阶主子式的行列式的绝对值。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵树定理</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卢卡斯定理与扩展卢卡斯定理]]></title>
    <url>%2F2019%2F04%2F04%2F%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%E4%B8%8E%E6%89%A9%E5%B1%95%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[概念卢卡斯定理要解决的问题很简单： C_n^m ~mod~ p如果$p$规定为质数，那么就用卢卡斯定理解决，否则就是扩展卢卡斯定理。洛谷上两个模板题都有 Lucas ExLucas 前置知识如果你不知道前置的知识的话，最好还是去系统学习一下。 1. 乘法逆元 若$Ax \equiv 1 (mod~p)$且$A$与$p$互质，则称$A$的$mod~p$意义下的乘法逆元为$X$ 关于求逆元：因为$(a,p) = 1$所以$a^{p-1} \equiv 1 (mod~p)$所以$a \times a ^{p - 2} \equiv 1 (mod~p)$所以$m!(n - m)!$的逆元为$(m!(n - m)!) ^{p - 2}$直接快速幂就可以了。 2.扩展欧几里得 扩展欧几里得用来在求得$gcd(a,b)$的同时，找出整数$x,y$使其满足$ax + by = gcd(a,b)$ 3.费马小定理 $a^(p-1) \equiv 1 (mod~p)$。 4.中国剩余定理还请移步博客欧几里得与扩展中国剩余定理Excrt 卢卡斯定理证明过程：首先根据组合数的只是我们可以很显然推出 C_p^i \equiv \frac pi C_{p-1}^{i-1} \equiv 0 (mod~p)然后根据二项式定理得出： (1 + x)^p \equiv \sum_{i=0}^p C_p^0 X^i \equiv C_p^o1^pX^0 + C^p_p1^0X^p \equiv 1 + x^p (mod~p)然后我们继续从二项式定理推出： C^b_a \equiv \prod_{i = 0}^p0 C_{a_ip^i}^{b_ip^i} (mod~p)上式也就是所谓的卢卡斯定理，这玩意的用处就在于下面这个递推式： Lucas(n,m,p) = CC_{m \% p}^{n \% p} \times Lucas(\frac np, \frac mp, p其中$Lucas(x,0,p) = 1$且$CC_m^n = (C_m^n)^(p-2) ~mod ~p$实际上就是一个费马小定理和乘法逆元。根据这个东西就可以很快地求出来上面的问题了。如果你看不大懂，那就只需要记结论。。。。 C_m^n ~mod~ p = (C_{m / p}^{n / p} ~mod~p) \times (C^{n ~mod~ p}_{m ~mod~ p} ~mod~p)~mod~p然后直接递归调用$C_{m~mod~p}^{n~mod~p} ~mod~p$就可以了。对于$C_m^n$的除法取模就需要用到逆元了。123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;LL N, M, P, X[MAXN] ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline LL QuickPow(LL A, LL B) &#123; LL Ans = 1 ; if (! B) return 1 % P ; while (B) &#123; if (B &amp; 1) Ans = Ans * A % P ; A = A * A % P, B &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline LL C(LL A, LL B) &#123; if (B &gt; A) return 0 ; return (X[A] * QuickPow(X[B], P - 2)) % P * QuickPow(X[A - B], P - 2) % P ;&#125;inline LL Lucas(LL A, LL B) &#123; if (! B) return 1 ; else return (C(A % P, B % P) * Lucas(A / P, B / P)) % P ;&#125;int main() &#123; int T = Read() ; while (T --) &#123; N = Read(), M = Read(), P = Read() ; X[0] = 1 ; for (LL i = 1 ; i &lt;= P ; i ++) X[i] = (X[i - 1] * i) % P ; LL Ans = Lucas(N + M, N) ; printf("%lld\n", Ans) ; &#125; return 0 ;&#125; 扩展卢卡斯定理令$P = \prod p_i^{c_i}$假设我们知道$C_n^m ~mod~p_i^{c_i}$就可以直接上$Crt$，但是我们并不知道。（泪目怎么求呢？对于$C^n_m = \frac{n!}{(n-m)!m!}$我们可以阶乘的变换。假设我们现在要求$19! % 3$我们将$1 \times…\times 19$中所有$3$的倍数拿出来合并。那么我们就得到$\lfloor \frac{19}{3} \rfloor$个满足项，然后除以$3$之后，就得到$\lfloor \frac{19}{3} \rfloor !$,这一部分不好算，我们直接递归下去。然后对于其他的项，可以看出来他们具有小于$3^k$的循环节这种东西，就可以暴力。然后时间复杂度就很可观了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>Lucas</tag>
        <tag>ExLucas</tag>
        <tag>扩展欧几里得</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TSP-旅行商问题]]></title>
    <url>%2F2019%2F03%2F19%2FTSP-%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[$TSP$是一个“组合优化问题”，同时也是数学领域中一个较为著名的$NPC$问题。 现在的算法都没有办法在确定型机器上在多项式时间内求出最优解，但是有办法在多项式时间内求出一个较优解。 可以发现这个问题并不是真正意义上的$NPC$，而是属于一个$NP-Hard$，因此可以求出较优解。这个问题的实质就是求一个带权无向图中，找一个权值最小的哈密尔顿回路，在给出的节点数目非常小的情况下，我们可以考虑状压$DP$。当然，我们知道没有什么算法是暴力搜索解决不了的，在没有十分优的解决方案的时候没我们自然想到枚举全排列。但是这显然白搭，因为$O(N!)$的时间复杂度即使点数很小也是很难接受的。于是考虑压缩状态。对于一种方案，我们用一个$N$位的二进制数表示，其中$1$表示第$i$个点被经过，若是$0$则是没有经过。我们设$Dp[i][j]$表示路径状态为$i$，当前处于$j$节点的最短路径。假设我们现在有一个$Dp[i][j]$，那么我们可以枚举一个点$k$，因为当前的$j$是刚刚经过，因此上一个状态一定没有经过$j$这个点。因此在上一个时刻的点的状态的第$j$位就一定是$0$，状态就是$i \times (1 &lt;&lt; k)$。并且从$k$走到$j$需要$L[i][j]$（也就是两点之间的最短路），于是我们取遍所有的$k$取最小值即可。得出递推关系式： Dp[i][j] = min(Dp[i][j], Dp[i * (1 < j)][k] + L[k][j])]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩</tag>
        <tag>NPC问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2010]生成字符串]]></title>
    <url>%2F2019%2F03%2F17%2FSCOI2010-%E7%94%9F%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[这题首先就得有一个画坐标系的想法，这很智障，我一开始也没有想出来。我们设$X = Num[1] + Num[0]$, $Y = Num[1] - Num[0]$也就是将1的个数加上0的个数设为X横坐标，把其和设为纵坐标。稍微画一下图，如果我们从原点开始向右上方走(y = x)，那么就是$X + 1, Y + 1$，表示我们选择了1,，如果朝右下角走$y = - x$那么就是$X + 1, Y - 1$，表示我们选择了0。很显然最后的方案数就是从原点走到$(N + M),(N - M)$节点。因为无论如何$X$都是加一，所以步数一定是$N + M$步，而我们要选出$M$次向下走，方案数就是$C^{N +M} _M$。当然，这是没有考虑限制情况。题目要求$1$的个数不能超过$0$的个数。发现也就是不能超过$y = - 1$这条直线。而经过直线的方案数就是$C^{N +M} _{M - 1}$然后最后的答案就是 C^{N +M} _M - C^{N +M} _{M - 1}这种东西直接预处理前缀积然后逆元一下就好了…12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const LL MAXN = 1000010 &lt;&lt; 1 ;const LL MAXM = 1000010 &lt;&lt; 1 ;const LL Inf = 0x7fffffff ;const LL Mod = 20100403 ;LL N, M, Fac[MAXN], Inv[MAXN] ;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline LL QUCIK_POW(LL X, LL Y) &#123; LL Ans = 1 ; while (Y) &#123; if (Y &amp; 1) Ans = Ans * X % Mod ; X = X * X % Mod ; Y &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline LL C(LL X, LL Y) &#123; LL U = Fac[X] * Inv[Y] % Mod ; return U * Inv[X - Y] % Mod ;&#125;int main() &#123; N = Read() ; M = Read() ; Fac[0] = 1 ; for (LL i = 1 ; i &lt;= N + M ; i ++) Fac[i] = Fac[i - 1] * i % Mod ; Inv[N + M] = QUCIK_POW(Fac[N + M], Mod - 2) ; for (LL i = N + M - 1 ; i &gt;= 0 ; i --) Inv[i] = Inv[i + 1] * (i + 1) % Mod ; printf("%lld", (C(N + M, M) - C(N + M, M - 1) + Mod) % Mod) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>字符串</tag>
        <tag>逆元</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[USACO15JAN]草鉴定]]></title>
    <url>%2F2019%2F03%2F12%2FUSACO15JAN-%E8%8D%89%E9%89%B4%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[Link一道及其智障的题目，关键在于博主调这个智障题调了基本一天…其实不是很难想，我们先缩一下点，把新图建出来，当然是因为要保证图无环，要不然下面就没法做了。这里实际上要建两个新图，一个正着的，还有一个反图。干什么用的呢？主要就是因为题目要求回到原点，这个玩意怎么实现的问题。首先这个路经肯定是一个圈，然后我们就可以找一下这个圈的一个“转折节点”，实际上就是枚举一个中间节点$X$，然后吧路经分为$1 -&gt; X$和$X -&gt; 1$两个链，这就需要我们建一个反图来进行实现。因为题目要求经过的点最多，因此我们就跑两个最长路。第一个最长路记录正图的$1 - &gt; Point_i$节点为$D[i]$。第二个最长路记录反图的$Point_i - &gt; 1$节点为$D2[i]$。（实际上也是从1节点出发）然后对于这个逆行的边我们如下处理：首先在$Tarjan$的时候进行一个记录$C[i]$表示$SCCi$号节点里面包含的原图的点数。那么$C[B[i]]$就是表示原图$i$号节点所属的$SCC$节点包含的原图的点数。对于逆行的边我们直接枚举答案就是$min(Ans, D[V[j].F] + D2[V[j].T] + C[B[1]])$（V为反图） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std ;typedef long long LL ;const int MAXN = 1010000 ;const int MAXM = 200010 ;const int Inf = 0x7fffffff ;int N, M, B[MAXN], Low[MAXN], Dfn[MAXN &lt;&lt; 1] ;struct EDGE &#123; int F, T, Next ;&#125; E[MAXM &lt;&lt; 1] ;struct GDGE &#123; int F, T, Next ;&#125; G[MAXM &lt;&lt; 1] ;struct VDGE &#123; int F, T, Next ;&#125; V[MAXM &lt;&lt; 1] ;int Ken, Top, S[MAXN], Cnt, C[MAXN],Ans ;bool Insta[MAXN] ;vector &lt;int&gt; Point[MAXN] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int H[MAXN], Tot ;inline void Add(int F, int T) &#123; E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].Next = H[F], H[F] = Tot ;&#125;int H2[MAXN], Tot2 ;inline void Add2(int F, int T) &#123; G[++ Tot2].F = F ; G[Tot2].T = T ; G[Tot2].Next = H2[F], H2[F] = Tot2 ;&#125;int H3[MAXN], Tot3 ;inline void Add3(int F, int T) &#123; V[++ Tot3].F = F ; V[Tot3].T = T ; V[Tot3].Next = H3[F], H3[F] = Tot3 ;&#125;inline void Tarjan(int Now) &#123; Dfn[Now] = ++ Ken ; Low[Now] = Ken ; S[++ Top] = Now ; Insta[Now] = 1 ; for (int i = H[Now] ; i ; i = E[i].Next) if (! Dfn[E[i].T]) &#123; Tarjan(E[i].T) ; Low[Now] = min(Low[Now], Low[E[i].T]) ; &#125; else if (Insta[E[i].T]) Low[Now] = min(Low[Now], Dfn[E[i].T]) ; if (Dfn[Now] == Low[Now]) &#123; int Pass ; Cnt ++ ; do &#123; Pass = S[Top --] ; B[Pass] = Cnt ; Point[Cnt].push_back(Pass) ; C[Cnt] ++ ; Insta[Pass] = false ; &#125; while (Pass != Now) ; &#125;&#125;int D[MAXN], Vis[MAXN] ;queue&lt;int&gt; Q ;inline void Spfa() &#123; memset(Vis, 0, sizeof(Vis)) ; memset(D, 0, sizeof(D)) ; D[B[1]] = - C[B[1]] ; Vis[B[1]] = 1 ; Q.push(B[1]) ; while (! Q.empty()) &#123; int Now = Q.front() ; Q.pop() ; Vis[Now] = false ; for (int i = H2[Now] ; i ; i = G[i].Next) if (D[G[i].T] &gt; D[Now] - C[G[i].T]) &#123; D[G[i].T] = D[Now] - C[G[i].T] ; if (! Vis[G[i].T]) Vis[G[i].T] = 1, Q.push(G[i].T) ; &#125; &#125;&#125;int D2[MAXN] ;inline void Spfa2() &#123; memset(D2, 0, sizeof(D2)) ; memset(Vis, 0, sizeof(Vis)) ; while (! Q.empty()) Q.pop() ; D2[B[1]] = - C[B[1]] ; Vis[B[1]] = 1 ; Q.push(B[1]) ; while (! Q.empty()) &#123; int Now = Q.front() ; Q.pop() ; Vis[Now] = false ; for (int i = H3[Now] ; i ; i = V[i].Next) if (D2[V[i].T] &gt; D2[Now] - C[V[i].T]) &#123; D2[V[i].T] = D2[Now] - C[V[i].T] ; if (! Vis[V[i].T]) Vis[V[i].T] = 1, Q.push(V[i].T) ; &#125; &#125; &#125;int main() &#123; N = Read() ; M = Read() ; for (int i = 1 ; i &lt;= M ; i ++) &#123; int A = Read(), B = Read() ; Add(A, B) ; &#125; for (int i = 1 ; i &lt;= N ; i ++) if (! Dfn[i]) Tarjan(i) ; for (int i = 1 ; i &lt;= Cnt ; i ++) for (int j = 0 ; j &lt; Point[i].size() ; j ++) for (int k = H[Point[i][j]] ; k ; k = E[k].Next) if (B[Point[i][j]] != B[E[k].T]) &#123; Add2(B[Point[i][j]], B[E[k].T]) ; Add3(B[E[k].T], B[Point[i][j]]) ; &#125; Spfa() ; Spfa2() ; for (int i = 1 ; i &lt;= Cnt ; i ++) for (int j = H3[i] ; j ; j = V[j].Next) &#123; if (D[V[j].F] &lt; 0 &amp;&amp; D2[V[j].T] &lt; 0) Ans = min(Ans, D[V[j].F] + D2[V[j].T] + C[B[1]]) ; &#125; printf("%d", - Ans) ; return 0 ;&#125;]]></content>
      <tags>
        <tag>拓扑排序</tag>
        <tag>最短路</tag>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2009]Elaxia的路线]]></title>
    <url>%2F2019%2F03%2F10%2FSDOI2009-Elaxia%E7%9A%84%E8%B7%AF%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[Link很经典的图论题目，分析下来不是特别有难度，算是比较简单的一类拓扑题吧。首先对于题目给定的$S1,S2,T1,T2$肯定要分别求一遍最短路，而我们选择的是从这四个节点出发分别求对所有点的最短路，得到$Dist[1 -&gt; 4][i]$分别表示$S1,T1,S2,T2$出发到第$i$个节点的最短路。因为题目是无向图，所以考虑重新建图变成$DAG$。在这之前我们要知道一个结论，就是这个最长公共路经一定是一条链，具体很好推，瞎证一证就可以了。所以如果我们在这里有了一张关于$S1 -&gt; T2$的所有最短路组成的$DAG$，那么其最长公共路经一定在这个图上，反过来$S2-&gt;T2$也是成立的。所有我们取一个交集，就知道怎么建图了：1.首先大循环是建一个$S1-&gt;T1$的图，对于某一条边$(Now-&gt;To)$，我们只需要判断$S1-&gt;Now-&gt;To-&gt;T1$这条路经是不是$S1-&gt;T1$的最短路就可以了。于是 1if (Dist[1][E[i].F] + E[i].L + Dist[2][E[i].T] == Dist[1][T1]) 2.之后循环的是$S2-&gt;T2$，和上面一样，但是为了保证$S2-&gt;Now-&gt;T-&gt;T2$和$S2-&gt;T-&gt;Now-&gt;T2$这两种情况都可以考虑到，我们需要分别考虑。12345678for (int i = 1 ; i &lt;= Tot ; i ++) if (Dist[1][E[i].F] + E[i].L + Dist[2][E[i].T] == Dist[1][T1]) &#123; if (Dist[3][E[i].F] + E[i].L + Dist[4][E[i].T] == Dist[3][T2]) Add2(E[i].F, E[i].T, E[i].L, 1) ; else if (Dist[3][E[i].T] + E[i].L + Dist[4][E[i].F] == Dist[3][T2]) Add2(E[i].F, E[i].T, E[i].L, 1) ; else Add2(E[i].F, E[i].T, E[i].L, 0) ;&#125; 看到这个建新图的函数$Add2()$中最后有一个关于$1$和$0$的参数，这个是为了表达在拓扑排序中是否需要计入答案的,也就是说这条边是不是在两条最短路的交集上（好绕~。然后就是一个拓扑排序了，直接从$S1$跑到$T1$，然后在其中对答案取$max$就可以了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 800010 ;const int MAXM = 800010 ;const int Inf = 0x7fffffff ;int N, M, D[MAXN], H[MAXN], Tot, Ans[MAXN] ;int S1, S2, T1, T2, Dist[6][MAXN], Ind[MAXN] ;struct EDGE&#123; int F ; int T ; int Next ; int L ;&#125; E[MAXM &lt;&lt; 1] ;int H2[MAXN], Tot2 ;struct EDGE2 &#123; int F ; int T ; int Next ; int L ; bool P ;&#125; Ed[MAXM &lt;&lt; 1] ;struct NODE &#123; int Num ; long long Len ; bool operator &lt; (const NODE &amp; B) const &#123; return Len &gt; B.Len ; &#125;&#125; Node ;bool Vis[MAXN] ;priority_queue&lt;NODE&gt; Q ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add(int F, int T, int L) &#123; E[++ Tot].F = F, E[Tot].T = T, E[Tot].L = L ; E[Tot].Next = H[F], H[F] = Tot ;&#125;inline void Add2(int F, int T, int L, int P) &#123; Ed[++ Tot2].F = F, Ed[Tot2].T = T, Ed[Tot2].L = L ; Ed[Tot2].Next = H2[F], H2[F] = Tot2, Ed[Tot2].P = P ;&#125;inline void Dijkstra(int S, int Num) &#123; memset(D, 127, sizeof(D)) ; memset(Vis, 0, sizeof(Vis)) ; while (! Q.empty()) Q.pop() ; D[S] = 0 ; Vis[S] = 0 ; Node.Num = S ; Node.Len = 0 ; Q.push(Node) ; while (! Q.empty()) &#123; NODE Now = Q.top() ; Q.pop() ; if (Vis[Now.Num]) continue ; for (int i = H[Now.Num] ; i ; i = E[i].Next) if (! Vis[E[i].T]) if (D[E[i].T] &gt; D[Now.Num] + E[i].L) &#123; D[E[i].T] = D[Now.Num] + E[i].L ; Q.push(Node = &#123;E[i].T, D[E[i].T]&#125;) ; &#125; &#125; for (int i = 1 ; i &lt;= N ; i ++) Dist[Num][i] = D[i] ;&#125;queue&lt;int&gt; Que ;inline void Topo() &#123; Que.push(S1) ; while (! Que.empty()) &#123; int Now = Que.front() ; Que.pop() ; for (int i = H2[Now] ; i ; i = Ed[i].Next) &#123; Ind[Ed[i].T] -- ; if (! Ind[Ed[i].T]) Que.push(Ed[i].T) ; Ans[Ed[i].T] = max(Ans[Ed[i].T], Ans[Now] + Ed[i].L * Ed[i].P) ; &#125; &#125;&#125;int main() &#123; N = Read(), M = Read() ; S1 = Read(), T1 = Read(), S2 = Read(), T2 = Read() ; for (int i = 1 ; i &lt;= M ; i ++) &#123; int F = Read(), T = Read(), L = Read() ; Add(F, T, L) ; Add(T, F, L) ; &#125; Dijkstra(S1, 1) ; Dijkstra(S2, 3) ; Dijkstra(T1, 2) ; Dijkstra(T2, 4) ; for (int i = 1 ; i &lt;= Tot ; i ++) if (Dist[1][E[i].F] + E[i].L + Dist[2][E[i].T] == Dist[1][T1]) &#123; if (Dist[3][E[i].F] + E[i].L + Dist[4][E[i].T] == Dist[3][T2]) Add2(E[i].F, E[i].T, E[i].L, 1) ; else if (Dist[3][E[i].T] + E[i].L + Dist[4][E[i].F] == Dist[3][T2]) Add2(E[i].F, E[i].T, E[i].L, 1) ; else Add2(E[i].F, E[i].T, E[i].L, 0) ; Ind[E[i].T] ++ ; &#125; Topo() ; printf("%d\n", Ans[T1]) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[ZJOI2004]嗅探器]]></title>
    <url>%2F2019%2F03%2F10%2FZJOI2004-%E5%97%85%E6%8E%A2%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Link2004年的水题，10分钟就过了…我也不知道为什么难度是省选/NOI-，可能是恶意评分吧。很简单，这个节点一定在两个中心节点中间的割点上。然后我们还有两个需要判断的东西： $Dfn[T] &gt;= Dfn[E[i].T]$啥意思呢，就是说$T$，也就是我们在这两个中心节点中选的一个当做终点，要在$E[i].T$之后被搜到，这样可以保证使得$Now$是必经之路。 $Low[T] &gt;= Dfn[Now]$也就是保证要经过$Now$点。以上两个都是为了确保$Now$是两个中心节点的必经之路。然后还要记得判断一下$Now != S &amp;&amp; Now != T$，不在两个中心节点上。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 5010 ;const int MAXM = 5010 ;const int Inf = 100000000 ;int N, M, Dfn[MAXN], Low[MAXN], Tot, H[MAXN], Ken ;bool Cut[MAXN] ; int S, T, Ans = Inf ;struct Node &#123; int F, T, Next ;&#125; E[MAXN &lt;&lt; 1] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add (int F, int T) &#123; E[++ Tot].F = F, E[Tot].T = T, E[Tot].Next = H[F], H[F] = Tot ;&#125;inline void Tarjan(int Now) &#123; Dfn[Now] = Low[Now] = ++ Ken ; for (int i = H[Now] ; i ; i = E[i].Next) &#123; if (! Dfn[E[i].T]) &#123; Tarjan(E[i].T) ; Low[Now] = min(Low[E[i].T], Low[Now]) ; if (Now != S &amp;&amp; Now != T) if (Dfn[Now] &lt;= Low[E[i].T]) if (Dfn[E[i].T] &lt;= Dfn[T]) if (Dfn[S] &lt;= Low[T]) Ans = min(Ans, Now) ; &#125; Low[Now] = min(Low[Now], Dfn[E[i].T]) ; &#125;&#125;int main() &#123; cin &gt;&gt; N ; int A, B ; do &#123; cin &gt;&gt; A &gt;&gt; B ; Add(A, B) ; Add(B, A) ; &#125; while (A + B) ; cin &gt;&gt; S &gt;&gt; T ; Tarjan(S) ; if (Ans == Inf) puts("No solution") ; else &#123;printf("%d", Ans) ;&#125; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>Tarjan</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[Noip2013]车站分级]]></title>
    <url>%2F2019%2F03%2F09%2FNoip2013-%E8%BD%A6%E7%AB%99%E5%88%86%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[Link很脑缺的一道题，我也不知道自己为什么要整这个。首先我们把题目转化一下，也就是在$i$车站之后没有停靠的火车站，其级别肯定都是低于$i$的级别。于是我们有了一堆车站的大小关系，选择从小级别的车站像大级别的车站连边，然后跑一下拓扑排序就行了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 1010 ;const int MAXM = 1010 ;const int Inf = 0x7fffffff ;int N, M, Train[MAXN][MAXN], S[MAXN], H[MAXN], Tot, Ans ;bool V[MAXN], Link[MAXN][MAXN] ; int Ind[MAXN] ;struct Node &#123; int F ; int T ; int Next ;&#125; E[MAXN &lt;&lt; 10] ;//数组大小一定要开够，不然会爆炸.....struct Node2 &#123; int Num ; int Level ;&#125; G ;queue&lt;Node2&gt; Q ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add (int F, int T) &#123; E[++ Tot].F = F ; E[Tot].T = T, E[Tot].Next = H[F], H[F] = Tot ;&#125;inline void Topo() &#123; Ans = 1 ; for (int i = 1 ; i &lt;= N ; i ++) if (! Ind[i]) Q.push(&#123;i, 1&#125;) ; while (! Q.empty()) &#123; int Now = Q.front().Num, L = Q.front().Level ; Q.pop() ; for (int i = H[Now] ; i ; i = E[i].Next) &#123; Ind[E[i].T] -- ; if (! Ind[E[i].T]) Q.push(&#123;E[i].T, L + 1&#125;), Ans = max(Ans, L + 1) ; &#125; &#125;&#125;int main() &#123; N = Read(), M = Read() ; for (int i = 1 ; i &lt;= M ; i ++) &#123; S[i] = Read() ; memset(V, 0, sizeof(V)) ; for (int j = 1 ; j &lt;= S[i] ; j ++) Train[i][j] = Read(), V[Train[i][j]] = 1 ; for (int j = Train[i][1] ; j &lt;= Train[i][S[i]] ; j ++) &#123; if (! V[j]) for (int k = 1 ; k &lt;= S[i] ; k ++) if (! Link[j][Train[i][k]]) &#123; Ind[Train[i][k]] ++ ; Add(j, Train[i][k]) ; Link[j][Train[i][k]] = 1 ; &#125; &#125; &#125; Topo() ; printf("%d", Ans) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>Noip</category>
      </categories>
      <tags>
        <tag>拓扑排序</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2014]数表]]></title>
    <url>%2F2019%2F03%2F08%2FSDOI2014-%E6%95%B0%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Link对于 \sum_{i = 1}^N \sum_{j = 1}^M F(gcd(i, j))这个式子来说，我们首先把它变换一下改变枚举顺序 \sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ N \sum_{j = 1} ^ M [gcd(i,j) == d]把$d$除过去 \sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ {N / d} \sum_{j = 1} ^ {M / d} [gcd(i,j) == 1]把最后的式子莫比乌斯反演一下 \sum_{d = 1} ^{N} F(d) \sum_{i = 1} ^ {N / d} \sum_{j = 1} ^ {M / d} \sum _{x | i, x | j} \mu (x)把$x$的枚举挪到前面去。 \sum_{d = 1} ^{N} F(d) \sum _{x = 1} ^ {N / d}\mu (x) \lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor设$T = dx$，然后再变一下枚举顺序。 \sum _{T = 1} ^ {N / d}\lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor \sum_{d | T} F(d) \mu (\frac{T}{d})然后发现出现了狄雷克利卷积，这就非常棒。然后我们记一个 G(T) = \sum_{d | T} F(d) \mu (\frac{T}{d})然后式子变成 \sum _{T = 1} ^ {N / d}\lfloor \frac{N}{T} \rfloor \lfloor \frac{M}{T} \rfloor G(T)这道题比较难的地方就在于其要求不大于$a$。于是我们将原来的$F(x)$函数加上一个$a$的限制。然后发现$F(d) \leq a$时对答案产生贡献。对于随着$a$的变化而变化的$G(x)$，采取离线筛选然后升序排序的情况。然后问题转化成了一个很熟悉的形式： 每次加入$d$满足$F(d) \leq a$ 查询前缀和。然后我们就可以用树状数组来进行维护。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const long long MAXN = 100010 ;const long long MAXM = 100010 ;const long long Inf = 0x7fffffff ;const long long Mod = (1LL &lt;&lt; 31) ;long long T ;long long U[MAXN], F[MAXN], S[MAXN], P[MAXN] ;long long Sum[MAXN], Ans[MAXN], Tot, B[MAXN] ;struct Node &#123; long long N, M, A, Num ; bool operator &lt; (const Node &amp; Y) const &#123; return A &lt; Y.A ; &#125;&#125; E[MAXN] ;struct Node2 &#123; long long X ; bool operator &lt; (const Node2 &amp; Y) const &#123; return S[X] &lt; S[Y.X] ; &#125;&#125; G[MAXN] ;inline long long Read() &#123; long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Init () &#123; S[1] = U[1] = 1 ; for (long long i = 2 ; i &lt;= MAXN ; i ++) &#123; if (! B[i]) &#123; P[Tot ++] = i ; U[i] = - 1 ; S[i] = i + 1 ; F[i] = i + 1 ; &#125; for (long long j = 0 ; j &lt; Tot ; j ++) &#123; if (i * P[j] &gt; MAXN) break ; B[i * P[j]] = 1 ; if (i % P[j] == 0) &#123; U[i * P[j]] = 0 ; F[i * P[j]] = F[i] * P[j] + 1 ; S[i * P[j]] = S[i] / F[i] * F[i * P[j]] ; break ; &#125; U[i * P[j]] = - U[i] ; F[i * P[j]] = P[j] + 1 ; S[i * P[j]] = S[i] * (P[j] + 1) ; &#125; &#125; for (long long i = 1 ; i &lt;= MAXN ; i ++) G[i].X = i ; sort(G + 1, G + MAXN + 1) ;&#125;inline long long Lowbit(long long Now) &#123; return Now &amp; (- Now) ; &#125; ;inline void Add(long long Now, long long K) &#123; while (Now &lt;= MAXN) &#123; Sum[Now] = ((LL) Sum[Now] + K) % Mod ; Now += Lowbit(Now) ; &#125; return ;&#125;inline void Change(long long Now) &#123; for (long long i = 1 ; i * Now &lt;= MAXN ; i ++) &#123; // cout &lt;&lt; U[i] &lt;&lt; " " &lt;&lt; S[Now]&lt;&lt; " " &lt;&lt; (LL) U[i] * S[Now] % Mod &lt;&lt; endl ; // system("pause") ; Add(Now * i, (LL) U[i] * S[Now] % Mod) ; &#125;&#125;inline long long Query (long long Now) &#123; long long Ans = 0 ; while (Now &gt;= 1) &#123; Ans = ((LL) Ans + Sum[Now]) % Mod ; Now &amp;= Now - 1 ; &#125; return Ans ;&#125;inline long long Answer(long long L, long long R) &#123; long long Ans = 0, ll = 0, rr ; for (long long l = 1, r ; l &lt;= L ; l = r + 1, ll = rr) &#123; r = min (L / (L / l), R / (R / l)) ; rr = Query(r) ; Ans = (Ans + ((LL) rr - ll) % Mod * (L / l) % Mod * (R / l) % Mod) % Mod; &#125; return ((LL) Ans + Mod) % Mod ;&#125;int main() &#123; T = Read() ; Init() ; for (long long i = 1 ; i &lt;= T ; i ++) &#123; E[i].N = Read(), E[i].M = Read(), E[i].A = Read() ; if (E[i].N &gt; E[i].M) swap(E[i].N, E[i].M) ; E[i].Num = i ; &#125; sort(E + 1, E + T + 1) ; long long j = 1 ; for (long long i = 1 ; i &lt;= T ; i ++) &#123; for (; j &lt;= MAXN &amp;&amp; S[G[j].X] &lt;= E[i].A ; j ++) Change(G[j].X) ; Ans[E[i].Num] = Answer(E[i].N, E[i].M) ; &#125; for (long long i = 1 ; i &lt;= T ; i ++) printf("%lld\n", Ans[i]) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>前缀和</tag>
        <tag>树状数组</tag>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2011]MET-Meteors]]></title>
    <url>%2F2019%2F03%2F05%2FPOI2011-MET-Meteors%2F</url>
    <content type="text"><![CDATA[Link考虑朴素算法，循环$K$次，每次循环$1$到$N$增加相应的$[L,R,A]$，然后$O(N)$判断某一个数是不是已经合法。这样的算法的时间复杂度是$O(N^3)$，那么我们考虑逐步优化。 首先区间加我们肯定可以使用线段树或者树状数组，这里使用的是后者。 改换一下枚举顺序就可以变成先枚举每一个数，然后枚举$K$次，然后我们发现枚举$K$次的这个步骤是单调的，因为对于某一个数，如果在$X$次区间加之后没有合法，那么在之前肯定也是不合法的，如果在$X$次区间加之后是合法的，那么在这之后肯定也是合法的，所以这个枚举$K$的步骤是单调的，于是可以考虑二分答案。那么总步骤就得出来了： 枚举每一个位置 二分区间加的次数 树状数组区间加 总时间复杂度$O(Nlog^2N)$123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std ;const unsigned long long Inf = 0x7fffffff ;const unsigned long long MAXN = 300010 ;const unsigned long long MAXM = 300010 ;unsigned long long N, M, Sta[MAXN], Data[MAXN], W[MAXN], Now, K ;vector &lt;unsigned long long&gt; H[MAXN] ; unsigned long long Tot[MAXN] ;unsigned long long LSum[MAXN], RSum[MAXN], Sum[MAXN], Ans[MAXN] ;struct Node &#123; unsigned long long L, R, V ;&#125; E[MAXN &lt;&lt; 1] ;inline unsigned long long Read() &#123; unsigned long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline unsigned long long Lowbit(unsigned long long Now) &#123; return Now &amp; (- Now) ; &#125;inline void Add(unsigned long long Now, unsigned long long K) &#123; while (Now &lt;= M) &#123; Sum[Now] += K ; Now += Lowbit(Now) ; &#125; return ;&#125;inline unsigned long long Query(unsigned long long Now) &#123; unsigned long long Ans = 0 ; while (Now) &#123; Ans += Sum[Now] ; Now -= Lowbit(Now) ; &#125; return Ans ;&#125;inline void Change(unsigned long long Now, unsigned long long L, unsigned long long R) &#123; if (L &lt;= R) Add(L, Now), Add(R + 1, - Now) ; if (L &gt; R) Add(1, Now), Add(R + 1, - Now) , Add(L, Now), Add(M + 1, - Now) ;&#125;inline void Erfen(unsigned long long L, unsigned long long R, unsigned long long U, unsigned long long D) &#123; //out &lt;&lt; L &lt;&lt; " " &lt;&lt; R &lt;&lt; " " &lt;&lt; U &lt;&lt; " " &lt;&lt; D &lt;&lt; endl ; unsigned long long Mid = (L + R) &gt;&gt; 1 ; if (L == R) &#123; for (unsigned long long i = U ; i &lt;= D ; i ++) Ans[W[i]] = L ; return ; &#125; while (Now &lt; Mid) Now ++, Change(E[Now].V, E[Now].L, E[Now].R) ; while (Now &gt; Mid) Change(- E[Now].V, E[Now].L, E[Now].R), Now -- ; for (unsigned long long i = U ; i &lt;= D ; i ++) &#123; Tot[W[i]] = 0 ; for (unsigned long long j = 0 ; j &lt; H[W[i]].size() ; j ++) Tot[W[i]] += Query(H[W[i]][j]) ; &#125; unsigned long long LL = 0, RR = 0 ; for (unsigned long long i = U ; i &lt;= D ; i ++) if (Tot[W[i]] &gt;= Data[W[i]]) LSum[++ LL] = W[i] ; else RSum[++ RR] = W[i] ; for (unsigned long long i = 1 ; i &lt;= LL ; i ++) W[i + U - 1] = LSum[i] ; for (unsigned long long i = 1 ; i &lt;= RR ; i ++) W[U + LL + i - 1] = RSum[i] ; Erfen(L, Mid, U, U + LL - 1) ; Erfen(Mid + 1, R, U + LL, D) ;&#125;int main() &#123; N = Read(), M = Read() ; for (unsigned long long i = 1 ; i &lt;= M ; i ++) Sta[i] = Read(), H[Sta[i]].push_back(i) ; for (unsigned long long i = 1 ; i &lt;= N ; i ++) Data[i] = Read(), W[i] = i ; K = Read() ; for (unsigned long long i = 1 ; i &lt;= K ; i ++) E[i].L = Read(), E[i].R = Read(), E[i].V = Read() ; E[K + 1].L = 1, E[K + 1].R = M, E[K + 1].V = Inf, Now = 0 ; Erfen(1, K + 1, 1, N) ; for (unsigned long long i = 1 ; i &lt;= N ; i ++) &#123; if (Ans[i] == K + 1) printf("NIE\n") ; else printf("%lld\n", Ans[i]) ; &#125; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>POI</category>
      </categories>
      <tags>
        <tag>树状数组</tag>
        <tag>整体二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[NOI2010]超级钢琴]]></title>
    <url>%2F2019%2F03%2F03%2FNOI2010-%E8%B6%85%E7%BA%A7%E9%92%A2%E7%90%B4%2F</url>
    <content type="text"><![CDATA[Link我们先来考虑朴素算法：将所有的方案求出来，然后排序。但是这样当然是不可能过的。对于某一个区间的综合我们肯定很自然地想到前缀和。那首先定住一个左节点$X$，那么这个区间的右端点肯定处于$[X + L - 1, X + R - 1]$之间。那么如果我们想要求这个区间里面的最大值，可以考虑使用询问时间复杂度为$O(1)$的$ST$表。如果右端点为$Y$，那么区间的值就是$Sum[Y] - Sum[X]$，那么我们可以直接寻找右端点区间中的$Sum[i]$的最大值。然后我们就得到了一堆区间的最大值，一共应该是$N - R + 1$，但是$K$是有可能大于这个数的，因此我们不能只求这个区间的最大值。于是考虑将这个区间二分。具体来说，就是首先将所有以$i$左端点，右端点在$[X + L - 1, X + R - 1]$的一个结构体存储到一个大根堆中，当然，本人使用的是单调队列，因为这样结构比较清晰。然后循环$K$次，每次取出堆顶计入答案。接下来的操作是以当前答案所处的右端点为中间，二分$[X + L - 1, X + R - 1]$这个区间，分别加入单调队列。因为如果想要寻找原来右端点区间中的第二大，第三大，我们选择去掉当前的最大值，然后将它的左边和右边分别入队，算法正确性就可以保证了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 500010 ;const int MAXM = 500010 ;const int Inf = 0x7fffffff ;LL N, K, L, R, Muc[MAXN] ;long long Sum[MAXN], Max[MAXN][20] ;long long Ans ;inline long long Read() &#123; long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void ST_BUILD() &#123; for (int i = 1 ; i &lt;= N ; i ++) Max[i][0] = i ; for (int j = 1 ; (1 &lt;&lt; j) &lt;= N ; j ++) for (int i = 1 ; i + (1 &lt;&lt; j) - 1 &lt;= N ; i ++) &#123; int X = Max[i][j - 1] ; int Y = Max[i + (1 &lt;&lt; (j - 1))][j - 1] ; if (Sum[X] &gt; Sum[Y]) Max[i][j] = X ; else Max[i][j] = Y ; &#125;&#125;inline int Query(int L, int R) &#123; int T = log2(R - L + 1) ; int X = Max[L][T], Y = Max[R - (1 &lt;&lt; T) + 1][T] ; return Sum[X] &gt; Sum[Y] ? X : Y ;&#125;struct Q &#123; int X, L, R, P ; Q() &#123;&#125; Q (int X, int L, int R) : X(X), L(L), R(R), P(Query(L, R)) &#123;&#125; friend bool operator &lt; (const Q &amp; A, const Q &amp; B) &#123; return Sum[A.P] - Sum[A.X - 1] &lt; Sum[B.P] - Sum[B.X - 1] ; &#125;&#125; ;priority_queue&lt;Q&gt; E ;int main() &#123; N = Read(), K = Read(), L = Read(), R = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; Muc[i] = Read() ; Sum[i] = Sum[i - 1] + Muc[i] ; &#125; ST_BUILD() ; for (int i = 1 ; i &lt;= N ; i ++) if (i + L - 1 &lt;= N) E.push(Q(i, i + L - 1, min(i + R - 1, N))) ; for (int i = 1 ; i &lt;= K ; i ++) &#123; int X = E.top().X, l = E.top().L, r = E.top().R, P = E.top().P ; E.pop() ; Ans += Sum[P] - Sum[X - 1] ; if (l != P) E.push(Q(X, l, P - 1)) ; if (r != P) E.push(Q(X, P + 1, r)) ; &#125; printf("%lld\n", Ans) ; return 0 ;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>NOI</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>前缀和</tag>
        <tag>堆</tag>
        <tag>ST表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SCOI2009]粉刷匠]]></title>
    <url>%2F2019%2F03%2F03%2FSCOI2009-%E7%B2%89%E5%88%B7%E5%8C%A0%2F</url>
    <content type="text"><![CDATA[Link2019的四川NOI题目，很经典的动态规划题目。首先设$Dp[i][j][k][l]$表示当到达$(i,~j)$点的时候恰好用了$k$次粉刷的机会，其中$l$只有$0$和$1$两种取值，因为题目中说的一个格子如果没有被粉刷或者粉刷上了错误的颜色都算粉刷错误，因此我们可以将这两种情况分开来看，统一成$0$，如果粉刷对了就是$1$。状态转移：对于每一次换木板的时候要刷一次，那么最优情况下，也就是跟前一个木板完全一样的情况下，我们将上一块木板的$Dp$转移过来就可以了。记住要把$1$和$0$的状态都转移过来。 Dp[i][j][k][0] = max(Dp[i][M][k - 1][0], Dp[i][M][k - 1][1]) ; Dp[i][j][k][1] = max(Dp[i][M][k - 1][0], Dp[i][M][k - 1][1]) + 1 ;然后对于上一个格子和当前格子的颜色都一样的话，我们就像换行一样进行处理。将上一个格子的状态直接转移过来就可以了。 Dp[i][j][k][1] = Dp[i][j - 1][k][1] + 1, Dp[i][j][k][0] = Dp[i][j - 1][k][0] ;如果上一个格子的颜色与当前格子的颜色不一样，那么可以选择 继续上一个格子的颜色，不减少机会，但是当前的格子就错误了。 减少一次机会，换一个k，当前的格子粉刷正确。 Dp[i][j][k][1] = max(Dp[i][j - 1][k - 1][1] + 1, Dp[i][j - 1][k][0] + 1) ; Dp[i][j][k][0] = max(Dp[i][j - 1][k][1], Dp[i][j - 1][k - 1][0]) ;所以从思路上来说是非常简单的，只要你能想到是几维的Dp，接下来的转移方程基本是水到渠成的。12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 60 ;const int MAXM = 60 ;const int MAXT = 2510 ;int N, M, K, Color[MAXN][MAXM], Dp[MAXN][MAXM][MAXT][2], Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read(), M = Read(), K = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; string A ; cin &gt;&gt; A ; for (int j = 1 ; j &lt;= M ; j ++) Color[i][j] = A[j - 1] - '0' ; &#125; for (int i = 1 ; i &lt;= N ; i ++) for (int j = 1 ; j &lt;= M ; j ++) for (int k = 1 ; k &lt;= K ; k ++) &#123; if (j == 1) Dp[i][j][k][0] = max(Dp[i - 1][M][k - 1][0], Dp[i - 1][M][k - 1][1]), Dp[i][j][k][1] = max(Dp[i - 1][M][k - 1][0], Dp[i - 1][M][k - 1][1]) + 1 ; else if (Color[i][j] == Color[i][j - 1]) Dp[i][j][k][1] = Dp[i][j - 1][k][1] + 1, Dp[i][j][k][0] = Dp[i][j - 1][k][0] ; else &#123; Dp[i][j][k][1] = max(Dp[i][j - 1][k - 1][1] + 1, Dp[i][j - 1][k][0] + 1) ; Dp[i][j][k][0] = max(Dp[i][j - 1][k][1], Dp[i][j - 1][k - 1][0]) ; &#125; Ans = max(Ans, max(Dp[i][j][k][0], Dp[i][j][k][1])) ; &#125; printf("%d", Ans) ; return 0;&#125; 后记没有写滚动数组，追求完美的当然可以滚动，但是不滚动数组也依然能过啦~。]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2009]虔诚的墓主人]]></title>
    <url>%2F2019%2F02%2F25%2FSDOI2009-%E8%99%94%E8%AF%9A%E7%9A%84%E5%A2%93%E4%B8%BB%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[Link 讲解转化一下题目的要求，假设我们知道点$(i,j)$的上下左右的常青树的个数分别为$U[i][j]$，$D[i][j]$，$L[i][j]$和$R[i][j]$，那么依据一个很简单的组合数学我们知道： Ans = C_{K}^{U[i][j]} \times C_{K}^{D[i][j]} \times C_{K}^{L[i][j]} \times C_{K}^{R[i][j]}其中$C$为组合。基本的思路就是这样，但是我们要考虑优化。从空间上来说，$1 \leq N, M \leq 1000000000$，肯定会直接爆炸（并且空间限制还是$128MB$）。题目并不要求十分确切的常青树位置，因此可以直接离散化。于是我们可以将坐标离散到一个$W \times W$的图中，因为$1 \leq W \leq 10000$，因此空间的问题就直接解决了。然后是时间，对于每一个墓地，原始做法是$O(N^2)$的求出上下左右的四个数组，但是最终的时间复杂度是$O(N^4)$。于是对于优化来说这里用到一个扫描线的思想。对于扫描线的具体讲解可以直接$Google$，这里只是针对题目讲方法罢了。将所有的常青树按照$X$为第一关键字，$Y$为第二关键字的方法升序排序。对于同一行的两个常青树，如果中间没有任何常青树，那么发现中间的所有的墓地的$L[i][j]$和$R[i][j]$都相等，因此只需要前缀和预处理出来 \sum_{i}^{N} \sum_{j}^M C_{K}^{L[i][j]} \times C_{K}^{R[i][j]}即可，下面要求的就只剩下了$U[i][j]$和$D[i][j]$。 维护上下所有常青树的乘积，而左右乘积的改变次数就等于常青树的个数，而考虑其他行的时候上下乘积的改变次数也就是常青树的个数。 于是我们要维护上下组合数的乘积的区间和，这种维护显然就可以线段树或者树状数组。 步骤对于同一行的两个数$A$和$B$，$Ans += C_{k}^{L[A]} \times C_{k}^{R[B]}$，然后用树状数组维护$A$和$B$点的$C_{k}^{U[i]} \times C_{k}^{D[i]}$的和。（省略掉了列，因为是同一行嘛） 答案实际上就是 \sum C_{k}^{L[A]} \times C_{k}^{R[B]} \times \sum [C_{k}^{U[i]} \times C_{k}^{D[i]}]从左向右处理的时候，修改树状数组该点横坐标位置上的数值为 C_{k}^{U[i]} \times C_{k}^{D[i]} - C_{k}^{U[i] + 1} \times C_{k}^{D[i] +1}代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int Inf = 0x7ffffff ;const int Mod = 2147483647 ;int N, M, W, K, S[MAXN], C[MAXN][11] ;int X[MAXN], Y[MAXN], Ans ;struct Node &#123; int X, Y, L, R, U, D ;&#125; E[MAXN] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;struct BIT &#123; int Sum[MAXN] ; inline int Lowbit(int Now) &#123; return Now &amp; ( - Now) ; &#125; inline void Add(int Now, int K) &#123; while (Now &lt;= W) &#123; Sum[Now] += K ; Now += Lowbit(Now) ; &#125; &#125; inline int Query(int Now) &#123; int Ans = 0 ; while (Now &gt; 0) &#123; Ans += Sum[Now] ; Now -= Lowbit(Now) ; &#125; return Ans ; &#125;&#125; Bit ;inline bool CMP(Node A, Node B) &#123; if (A.Y != B.Y) return A.Y &lt; B.Y ; else return A.X &lt; B.X ;&#125;inline void Init() &#123; for (int i = 0 ; i &lt;= W ; i ++) &#123; C[i][0] = 1 ; for (int j = 1 ; j &lt;= min(K, i); j ++) C[i][j] = C[i - 1][j] + C[i - 1][j - 1] ; &#125; sort(E + 1, E + W + 1, CMP) ; int Ken = 0 ; for (int i = 1 ; i &lt;= W ; i ++) &#123; if (E[i].Y == E[i - 1].Y) Ken ++ ; else Ken = 1 ; E[i].L = Ken ; S[E[i].X] ++ ; E[i].U = S[E[i].X] ; &#125; Ken = 0 ; for (int i = W ; i &gt;= 1 ; i --) &#123; if (E[i].Y == E[i + 1].Y) Ken ++ ; else Ken = 1 ; E[i].R = Ken ; E[i].D = S[E[i].X] - E[i].U ; &#125;&#125;int main() &#123; N = Read(), M = Read(), W = Read() ; for (int i = 1 ; i &lt;= W ; i ++) &#123; E[i].X = Read(), E[i].Y = Read() ; X[i] = E[i].X ; Y[i] = E[i].Y ; &#125; K = Read() ; sort(X + 1, X + W + 1) ; sort(Y + 1, Y + W + 1) ; for (int i = 1; i &lt;= W ; i ++) &#123; E[i].X = lower_bound(X + 1, X + W + 1, E[i].X) - X ; E[i].Y = lower_bound(Y + 1, Y + W + 1, E[i].Y) - Y ; &#125; Init() ; for (int i = 1 ; i &lt;= W ; i ++) &#123; int V = Bit.Query(E[i].X) - Bit.Query(E[i].X - 1) ; Bit.Add(E[i].X, - V) ; Bit.Add(E[i].X, C[E[i].U][K] * C[E[i].D][K]) ; if (E[i].Y == E[i - 1].Y) Ans = Ans + C[E[i - 1].L][K] * C[E[i].R][K] * (Bit.Query(E[i].X - 1) - Bit.Query(E[i - 1].X)); &#125; printf("%d", Ans &amp; Mod) ; return 0 ;&#125; 后记有人说可不可以搞一个二维线段树，思路上来说是可行的，但是空间上大概会爆炸吧~。最后在冲浪的时候发现由于模数为$2147483647$所以可以自然溢出然后最后$ \&amp; 2147483646$就可以了。]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>组合数学</tag>
        <tag>树状数组</tag>
        <tag>线段树</tag>
        <tag>离散化</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[POI2012]FES-Festival]]></title>
    <url>%2F2019%2F02%2F23%2FPOI2012-FES-Festival%2F</url>
    <content type="text"><![CDATA[Link看到题目首先肯定想到差分约束，当然这也是一个差分约束的题。题目比较难想的地方在于建图，设$Dist[i][j]$表示$max\{A_i - A_j\}$，也就是$A_i$最多能比$A_j$大多少。那么根据题意我们知道对于第一种情况，应该是 Dist[X][Y] = 1,~Dist[Y][X] = - 1然后对于第二种情况，题目对数量上并没有限制，限制的只是大小关系，然而我们转化一下依然能知道$A_Y - A_X \geq 0$，对此我们选择从$Y$向$X$连一条边权为零的单项边，然后$Dist[Y][X] = 0$，对于这种情况我们连边的目的不是为了限制数值，而是为了限制关系，大小关系。由于限制条件可以叠加，于是对于每一个建边都要取$min$。然后首先要考虑的肯定是合法问题。稍加分析我们可以知道图如果存在非零环，肯定是不合法的，于是我们考虑判断非零环。一般来说判负环就是简单地跑一遍$Spfa$然后记录每一个点入队的次数就可以解决。但是这个题有一点问题。就是这个图并不一定是联通的。所以不论以哪一个节点作为起点都是不能保证的。因此舍弃$Spfa$，观察数据发现$N \leq 600$非常的小，完全可以考虑$Floyed$，使用弗洛伊德的判断负环的方式就是看有没有$Dist[i][i] != 0$，然后弗洛伊德怎么解决问题了呢？因为图并不是联通的，但是只要每一个强连通分量合法就可以了，于是我们考虑$Tarjan$缩点，然后对于每一个强联通分量分别求解。在三重循环的过程中判断$i,j,k$是不是都属于一个强连通分量，然后就可以有一个小小的优化。缩完点之后发现剩下的就是连接每一个联通块的零权边，对答案并没有影响，只会影响关系，并且我们设的$Dist[i][j]$表示的是$i,j$的最大差值，于是就可以寻找每一个强联通分量里面的最大值。并且每一个强联通分量在数值上没有关系，因此将答案直接累加即可，最后输出答案加上强连通分量的数量。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990// luogu-judger-enable-o2#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#define RE registerusing namespace std ;typedef long long LL ;const int MAXN = 610 ;const int MAXM = 100010 ;const int Inf = 1000000000 ;int N, M1, M2, D[MAXN], H[MAXN], Tot ;int Low[MAXN], Dfn[MAXN], B[MAXN] ;int S[MAXN], Top, Ken, Cnt, Ans ; bool Insta[MAXN], Inq[MAXN], V[MAXN] ;int Num[MAXN], Max, Dist[MAXN][MAXN] ;queue &lt;int&gt; Q ;struct Node &#123; int F, T, L, Next ;&#125; E[MAXM &lt;&lt; 1] ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Add(int F, int T, int L) &#123; E[++ Tot].F = F, E[Tot].T = T ; E[Tot].L = L ; E[Tot].Next = H[F] ; H[F] = Tot ;&#125;inline void Tarjan(int Now) &#123; Dfn[Now] = Low[Now] = ++ Ken ; S[++ Top] = Now ; Insta[Now] = 1 ; for (RE int i = H[Now] ; i ; i = E[i].Next) if (! Dfn[E[i].T]) &#123; Tarjan(E[i].T) ; Low[Now] = min(Low[E[i].T], Low[Now]) ; &#125; else if (Insta[E[i].T]) Low[Now] = min(Dfn[E[i].T], Low[Now]) ; if (Dfn[Now] == Low[Now]) &#123; Cnt ++ ; int Pass ; do &#123; Pass = S[Top --] ; B[Pass] = Cnt ; Insta[Pass] = false ; &#125; while (Pass != Now) ; &#125;&#125;int main() &#123; N = Read(), M1 = Read(), M2 = Read() ; for (RE int i = 1 ; i &lt;= N ; i ++) for (RE int j = 1 ; j &lt;= N ; j ++) Dist[i][j] = Inf ; for (RE int i = 1 ; i &lt;= M1 ; i ++) &#123; int X = Read(), Y = Read() ; Add(X, Y, 1) ; Add(Y, X, - 1) ; Dist[X][Y] = min(Dist[X][Y], 1) ; Dist[Y][X] = min(Dist[Y][X], - 1) ; &#125; for (RE int i = 1 ; i &lt;= N ; i ++) Dist[i][i] = 0 ; for (RE int i = 1 ; i &lt;= M2 ; i ++) &#123; int X = Read(), Y = Read() ; Add(Y, X, 0) ; Dist[Y][X] = min(Dist[Y][X], 0) ; &#125; for (RE int i = 1 ; i &lt;= N ; i ++) if (! Dfn[i]) Tarjan(i) ; for (RE int k = 1 ; k &lt;= N ; k ++) for (RE int i = 1 ; i &lt;= N ; i ++) if (B[k] == B[i]) for (RE int j = 1 ; j &lt;= N ; j ++) if (B[i] == B[j]) Dist[i][j] = min(Dist[i][j], Dist[i][k] + Dist[k][j]) ; for (RE int i = 1 ; i &lt;= N ; i ++) if (Dist[i][i] != 0) &#123; puts("NIE") ; return 0 ; &#125; for (RE int i = 1 ; i &lt;= N ; i ++) for (RE int j = 1 ; j &lt;= N ; j ++) if (B[i] == B[j]) D[B[i]] = max(D[B[i]], Dist[i][j]) ; for (RE int i = 1 ; i &lt;= N ; i ++) Ans += D[i] ; printf("%d\n", Ans + Cnt) ; return 0 ;&#125; 最后发现弗洛伊德跑还是比较慢，最后加了很多$register$和$inline$才勉强卡过去。后来知道有一个非常神奇的深搜版$Spfa$，应该是可以更好地解决这个问题的。]]></content>
      <categories>
        <category>题解</category>
        <category>POI</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>Tarjan</tag>
        <tag>Floyed</tag>
        <tag>差分约束系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]墨墨的等式]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-%E5%A2%A8%E5%A2%A8%E7%9A%84%E7%AD%89%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Link题意大概就是求$B_l,B_r$范围内$B$的个数使等式 \sum_{i = 1}^N a_Nx_N = B存在非负整数解。其实转化一下题意也就是 在N种物品中任意选择，物品有一个价值，使得最后的总价值处于给定区间内。 这很显然是一个完全背包，而且是类似于一种模板题，但是这道题的数据范围是$B \leq 10^{12}$，因此这么做显然是不行的，但是我们可以从完全背包的视角出发思考题目。我们取出最小的$a$为$a_{min}$,并且假设我们现在知道了一种方案，物体的总重为$D[i]$，并且满足K ~mod~ a_{min} = i，在这两种条件下$D[i]$为最小值。那么显然，对于任意一个同样满足上述两个条件的总重X，$X \leq D[i]$，并且因为$X ~mod~ a_{min} = D[i] ~mod~ a_{min}$，所以可以知道$X$方案可以由$D[i]$方案加上若干个$a_{min}$得到。现在我们考虑加入一个物体$Now$，那么有 D[(i + Now) ~mod~ a_{min}]可以从$d[i] + Now$而来。于是可以考虑从i向$(i + Now) ~mod~ a_{min}$连一条比边权为$Now$的边，而求$D[i]$的最小值也就被转化成了最短路问题。那么算法就得出来了： 首先求一下$a_{min}$的最小值保存下来。 跑最短路，预处理出D数组。 枚举所有的D，计算mod T = i的数在区间$B_l,B_r$中有多少个。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;using namespace std ;typedef long long LL ;const int MAXN = 15 ;const int MAXM = 500010 ;LL Inf = (LL)1 &lt;&lt; 60 ;LL N, L, R, a[MAXN], H[MAXN], Tot, D[MAXM] ;struct Edge &#123;int F, T, L, Next ;&#125; E[MAXN] ;queue&lt;int&gt; Q ; bool F[MAXM] ; LL K, Ans ; inline void Add(int F, int T, int L) &#123; E[++ Tot].F = F ; E[Tot].T = T ; E[Tot].L = L ; E[Tot].Next = H[F] ; H[F] = Tot ;&#125;inline void Spfa(int S) &#123; memset(F, 0, sizeof(F)) ; for (int i = 1 ; i &lt; K ; i ++) D[i] = Inf ; D[S] = 0 ; F[S] = 1 ; Q.push(S) ; while (! Q.empty()) &#123; int Now = Q.front() ; Q.pop() ; F[Now] = 0 ; for (int i = 1 ; i &lt;= N ; i ++) &#123; int T = (Now + a[i]) % K ; if (D[T] &gt; D[Now] + a[i]) &#123; D[T] = D[Now] + a[i] ; if (! F[T]) Q.push(T), F[T] = 1 ; &#125; &#125; &#125;&#125;inline LL Read() &#123; LL X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int main() &#123; N = Read(), L = Read(), R = Read() ; for (int i = 1 ; i &lt;= N ; i ++) a[i] = Read() ; sort (a + 1, a + N + 1) ; K = a[1] ; //储存最小的a。 Spfa(0) ; for (int i = 0 ; i &lt; K ; i ++) if (D[i] != Inf) D[i] = (D[i] - i) / K ; for (int i = 0 ; i &lt; K ; i ++) if (D[i] != Inf) &#123; int K1 = (L - i - 1) / K - D[i] + 1 ; int K2 = (R - i) / K - D[i] + 1 ; Ans = Ans - max(K1, 0) + max(K2, 0) ; &#125; printf("%lld", Ans) ; return 0 ;&#125; 这种在求解用$\{a_i\}$能组成多少个在$B_l, B_r$范围内的数的问题其实是很经典的图论问题，像这种建图困难，但是最短路很好跑的题目便可以称为是建图题了。]]></content>
      <categories>
        <category>题解</category>
        <category>国家集训队</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[国家集训队]Crash的数字表格]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%9B%BD%E5%AE%B6%E9%9B%86%E8%AE%AD%E9%98%9F-Crash%E7%9A%84%E6%95%B0%E5%AD%97%E8%A1%A8%E6%A0%BC%2F</url>
    <content type="text"><![CDATA[Link如题，给定$N$和$M$，求 \sum_{i = 1} ^ N \sum_{j = 1}^ M lcm(i, j)有人说这道题是BZOJ上面的JZPTAB，但其实不是，JZBTAB虽然具体问题和改题是一样的，但是那道题是多组询问，比这道题还要难一些。首先我们知道$lcm(i,j) = \frac{i \times j}{gcd(i,j)}$，那么题目转化为 \sum_{i = 1}^N \sum_{j=1}^M \frac{i \times j}{gcd(i,j)}然后我们枚举最大公约数，式子转化为 \sum_{d = 1}^{min(N,M)} \sum_{i = 1} ^ N \sum_{j = 1}^ M \frac{i \times j}{d} [gcd(i,j) == d]提出d,式子变成 \sum_{d = 1}^{min(N,M)} d \sum_{i = 1}^{N / d} \sum_{j = 1} ^ {M / d}[gcd(i, j) == 1] \times ij并且我们知道 \sum_{d|N}\mu (d) = [N == 1]直接带入上面的式子可以得到 \sum_{d = 1}^{min(N,M)} d \sum_{i = 1}^{N / d} \sum_{j = 1} ^ {M / d} \sum_{x|gcd(i,j)} \mu (x) \times ij保留前缀和$S[i]$，优先枚举$x$。 \sum _{d = 1} ^ N d \sum_{x = 1}^{n / d} x ^ 2 μ (x) S(\frac {N}{dx}) S(\frac {M}{dx})优先枚举$S$ \sum_{dx = 1}^{N} S(\frac{N}{dx} S(\frac{M}{dx})dx \sum_{e|dx}e \mu(dx))对于其中的$f(dx) = dx \sum_{e|dx}e \mu(dx)$可以线性筛，有式子 f(dxp) = f(dx)f(p)之后的式子可以整除分块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 10000010 ;const int MAXM = 10000010 ;const int Mod = 20101009 ;int N, M, F[MAXN], P[MAXN], Tot ;bool V[MAXN] ; int Sum[MAXN], Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline int MOD (int Now) &#123; if (Now &gt;= Mod) return Now - Mod ; else return Now ;&#125;inline void Init() &#123; F[1] = 1 ; for (int i = 2 ; i &lt;= min(N, M) ; i ++) &#123; if (! V[i]) &#123; P[++ Tot] = i, F[i] = MOD (Mod + 1 - i) ; &#125; for (int j = 1 ; j &lt;= Tot &amp;&amp; i * P[j] &lt;= min(N, M) ; j ++) &#123; V[i * P[j]] = true ; if (i % P[j]) F[i * P[j]] = 1LL * F[i] * F[P[j]] % Mod ; else &#123; F[i * P[j]] = F[i] ; break ; &#125; &#125; &#125; for (int i = 1 ; i &lt;= min(N, M) ; i ++) F[i] = MOD(F[i - 1] + 1ll * F[i] * i % Mod) ; for (int i = 1 ; i &lt;= max(N, M) ; i ++) Sum[i] = MOD(Sum[i - 1] + i) ;&#125;int main() &#123; N = Read() ; M = Read() ; Init() ; Ans = 0 ; for (int l = 1, r ; l &lt;= min(N, M) ; l = r + 1) &#123; r = min(N / (N / l), M / (M / l)) ; int Ans2 = MOD(F[r] - F[l - 1] + Mod) ; Ans = MOD(Ans + 1LL * Ans2 * Sum[N / l] % Mod * Sum[M / l] % Mod) ; &#125; printf("%d", Ans % Mod) ; return 0 ;&#125; 这道题的式子确实难推，但是时间复杂度化简到$O(N)$左右也就可以了，据说BZOJ上面的题目是真正的JZPTAB是多组数据，时间复杂度要推倒$O(\sqrt N)$才行。至于那种级别的题目，即使没有眼见为实，笔者也是有做不了的自知之明的…如果有想要了解的朋友还请另寻高就吧。]]></content>
      <categories>
        <category>题解</category>
        <category>国家集训队</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧几里得与扩展中国剩余定理ExCrt]]></title>
    <url>%2F2019%2F02%2F15%2F%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E4%B8%8E%E6%89%A9%E5%B1%95%E4%B8%AD%E5%9B%BD%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86ExCrt%2F</url>
    <content type="text"><![CDATA[欧几里得算法为什么要放欧几里得算法，因为这个玩意是扩展欧几里得的铺垫，为什么要将扩展欧几里得，因为这个玩意是中国剩余定理的铺垫。很简单，就是要我们求$gcd(i,j)$。由于证明过程十分繁琐并且没有什么很大的意义，所以便不多管闲事地证明了，结论也很简单：$gcd(i,j) = gcd(j, i \% j)$。于是可以不断递归，直到j变成0，然后返回i就可以了，很常见的方法，直接放代码了。1234inline int Gcd(int X, int Y) &#123; if (Y == 0) return X ; return Gcd(Y, X % Y) ;&#125; 裴蜀定理裴蜀定理是扩展欧几里得算法的第二个铺垫，也是一个关于最大公约数的定理。假设有一个线性方程$ax + by = c$，问这个方程有没有整数解，那么根据裴蜀定理我们就知道当$gcd(a,b) | c$的时候线性方程才可能有整数解。简单的证明就是$gcd(a,b)$显然$|(ax+by)$。对于$gcd(a,b)|c$的情况有没有整数解我们便需要用到扩展欧几里得。 扩展欧几里得对于 ax + by = gcd(a,b)当$a &lt; 0$的时候，式子就可以变成 |a| (-x) + by = gcd(|a|, b)可以知道这个式子必然是有整数解的。我们可以对于$(a,b)$进行欧几里得算法，得到最大公约数，然后保存辗转相除法中的式子倒推便可以得到$ax + by = gcd(a,b)$的整数解。那么也就是证明了裴蜀定理，同时也给出了计算线性方程的整数解的方法。关于推导呢？$xa + yb = d$且有$x’b + y’(a \% b) = d$则$x’b + y’(a = \lfloor \frac ab \rfloor b) = d$$y’a + (x’ - y’ \lfloor \frac a b \rfloor) b = d$可得$x = y’, y = x’ - y \lfloor \frac ab \rfloor$推导完毕。。。123456inline int Exgcd(int a, int b, int &amp; X, int &amp; Y) &#123; if (b == 0) &#123;X = 1, Y = 0 ; return a ;&#125; int R = Exgcd(b, a % b, X, Y) ; int E = X ; X = Y ; Y = E - a / b * Y ; return R ;&#125; 中国剩余定理此算法称为扩展中国剩余定理，而中国剩余定理满足$m_i$之间两两互质，我们先从中国剩余定理说起。还是使用上面的式子，假设方程组有解。那么我们设$M = \prod_{i = 1}^nm_i$，（当然也可以设$M = Lct({m_i})$，效果是一样的）且有n个$M_i = M / m_i$，也就是除了第i个以外其他n-1个$m_i$的乘积。以及$t_i = M_i^{-1}$，则我们知道 t_iM_i \equiv 1 (mod ~ m_i)于是有结论：方程组的通解形式为 \sum _{i = 1}^n a_it_iM_i + kM以上是通解形式，而通解有无数个，对于每一个解加上$kM$依然是方程组的解，其中$k \in Z$。 证明关于证明，因为我们知道t_iM_i \equiv 1 (mod ~ 1)所以有 a_it_iM_i \equiv a_i (mod ~ m_i)而因为所有的$m_i$之间两两互质，因此对于除了$m_i$之外的所有的$m_j$都有 a_it_iM_i \equiv 0 (mod ~ m_j)因此 x = \sum _{i = 1}^ n a_it_iM_i满足 x = a_i t_i M_i + \sum _{j ≠ i}a_j t_j+M j \equiv a_i + \sum_{j ≠ i} 0 \equiv a_i (mod ~ m_i)因此，$x \equiv a_i (mod ~ m_i)$，所以$x$就是方程的一个特殊解。而至于为什么加上若干个$M$都是解我想就不用我再证明了吧。 123456789101112long long a[MAXN], m[MAXN], n ;inline long long Crt() &#123; long long M = 1 ; for (int i = 1 ; i &lt;= n ; i ++) M *= m[i] ; long long X = 0 ; for (int i = 1 ; i &lt;= N ; i ++) &#123; long long x, y ; long long M_i = M / m[i] ; Exgcd(M_i, m[i], x, y) ; X = (X + M_i * x * a[i]) % M ; &#125; return (X + M) % M ;&#125; 扩展中国剩余定理然后关于扩展中国剩余定理，相较之就是取消掉了$m_i$两两互质这个条件。我们依然假设$M = \sum_{i = 1}^{k - 1} m_i$，那么假设我们已经知道了前$k-1$个式子的方程通解为$x + i \times M$，那么在加入第$i$个方程后的通解，只消求出一个满足 x + t * M \equiv a_k (mod~m_k)的$t$就可以。 t \times M \equiv a_k - x~(mod ~ m_k)直接欧几里得求解$t$即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std ;typedef long long LL ;const int MAXN = 100010 ;const int MAXM = 100010 ;int N ;long long A[MAXN], B[MAXN] ;inline long long Read() &#123; long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline long long Exgcd(LL a, LL b, LL &amp; X, LL &amp; Y) &#123; if (b == 0) &#123; X = 1 ; Y = 0 ; return a ; &#125; LL R = Exgcd(b, a % b, X, Y), E = X ; X = Y ; Y = E - a / b * Y ;return R ;&#125;inline long long Quick_Mul(LL X, LL Y, LL Mod) &#123; long long Ans = 0 ; while (Y) &#123; if (Y &amp; 1) Ans = (Ans + X) % Mod ; X = (X + X) % Mod ; Y &gt;&gt;= 1 ; &#125; return Ans ;&#125;inline long long Excrt() &#123; long long X, Y, M = B[1], Ans = A[1] ; for (int i = 2 ; i &lt;= N ; i ++) &#123; LL a = M, b = B[i], C = (A[i] - Ans % b + b) % b ; LL R = Exgcd(a, b, X, Y), E = b / R ; if (C % R != 0) return - 1 ; X = Quick_Mul(X, C / R, E) ; Ans += X * M ; M = M * E ; Ans = (Ans % M + M) % M ; &#125; return (Ans % M + M) % M ;&#125;int main() &#123; N = Read() ; for (int i = 1 ; i &lt;= N ; i ++) B[i] = Read(), A[i] = Read() ; printf("%lld", Excrt()) ; return 0 ;&#125; 后记培训的时候听$zhx$神仙讲了大骗分法：大数翻倍法。很简单，就是对于最大的$a_i$不断地把它加上$p_i$，然后合法检查就可以了。时间复杂度大概在$O(\sum_i p_i)$到$O(max(p))0$之间，据说是可以用来做题的，但是唯一不能适用的情况就是两组方程，其中$p \in 10^9$。嗯，骗分大法好。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>扩展欧几里得</tag>
        <tag>中国剩余定理</tag>
        <tag>扩展中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性积分与傅里叶变换]]></title>
    <url>%2F2019%2F02%2F13%2F%E7%BA%BF%E6%80%A7%E7%A7%AF%E5%88%86%E4%B8%8E%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[文章被题目大致分为了两个部分：线性积分和 傅里叶变换。其实这么分实际上是不甚妥当的，因为傅里叶变换就是线性积分变换中的一种。如果要结合题目细讲，写起来怕是一个浩大的工程了，因此讲解的内容大多就仅止步于在信息学奥赛中的应用。当然，博主也会尽力深挖，争取让文章不只是初步。 写在前面很多人学快速傅里叶变换，学它的微分关系，学它的卷积特性，但是始终都没有思考过这个玩意是干嘛用的。毕竟本篇文章实际上想要讲的就是傅里叶变换，我们也首先要了解到傅里叶变换的作用是什么。 从数学上来说，傅里叶变换是用于解决两个多项式的 卷积，简单来说就是两个多项式相乘的次数，如果直接暴力计算，那么时间复杂度应该是$O(N^2)$，而快速傅里叶变换可以将时间复杂度降为$O(NlogN)$。这在时间维度上就体现了它宝贵的价值，因为多项式相乘的普遍性，复杂的快速傅里叶变换也渐渐走进人们的视野。 而从物理学或者工程学中，傅里叶变换的常见用途是 信号处理，而所属的信息与系统又是大学中大部分工科的基础，足以见其重要性。具体的讲就是 将给定信号把时间映射到振幅。而关于时间和频率的有关内容还请参考Heinrich关于傅里叶变换的教程：傅里叶分析之掐死教程 ，例如其在讯号处理的经典应用就是将讯号分解为振幅分量和频率分量。 线性积分变换 积分变换是数学中作用于函数的算子，用以处理微分方程等问题。 一个十分生涩的定义，我们假设当前有一个函数$f(x)$，将操作$T$表示为一个积分转换，而$f$经过此积分变换后的函数表示为$Tf(y)$：Tf(y) = \int_{x_1}^{x_2}K(x, y)f(x) dx。 其中$K()$是一个确定的含有两个参数的函数，称为此次积分变换的核函数（简称核）。而核使我们自己选择的，当我们选择不同的核函数$K()$或者积分域$(x_1,x_2)$就得到了不同的积分变换，这应该是很显然的。而相对应的，积分变换也有相对的反积分变换，也就是：f(x) = \int_{y_1}^{y_2}K^{-1}(y, x)Tf(y)dy 其中$K^{-1}(y, x)$被称为反核。 而积分变换与反积分变换构成了傅里叶变换的框架，在傅里叶变换中，核函数为$\frac{e^{ixy}}{\sqrt{2 \pi}}$，其积分域为$-\infty, \infty$。 下面我们会从基础开始一步步地将傅里叶变换拆成我们好理解的东西。 傅里叶变换多项式我想来到这里的人肯定不需要我再讲这东西了，如果果真有人不会，还请自行维基。为了讲解需要，在此强调几个多项式的概念性内容： 多项式的框架式形式：\sum_{i = 0}^{N - 1}a_ix_i 若其最高次的非零系数为$a_k$，则该多项式的次数为k。 任何一个严格大于其次数的整数都是这个多项式的次数界。 对于多项式的计算，加法显然很简单。C(x) = A(x) + B(x) = \sum_{i = 0}^{N - 1}a_ix^i + \sum_{i = 0}^{N - 1}b_ix^i = \sum_{i = 1}^{N - 1}c_ix^i 只需要将对应次数的系数相加即可，我们可以在$O(N)$的时间复杂度内得到答案。 而对于多项式乘法，方法是将$A(x)$中的每一项与$B(x)$中的每一项相乘，之后合并同类项即可。C(x) = \sum_{i = 0}^{2N - 2}c_ix_i其中$c_i = \sum_{j = 0}^ia_jb_i-j$称为两个多项式的卷积，表示为$a \otimes b$ 对于一个多项式来说我们有两种表示方法：系数表示法和点值表示法，其实两种表示方法应该是等价的，但是在计算上来说，对于点值表示的多项式，求解的时间复杂度是$O(N)$，这已经非常优秀，但是系数表示的多项式的暴力求解却是$O(N^2)$，而快速傅里叶变换就可以做到将系数表示的多项式在$O(NlogN)$的时间内求解。 对于点值表示的多项式求值运算的逆运算（已知点值表示的多项式求系数表示）称为插值，关于插值内容还请参照博主的另一篇博客：对插值法及拉格朗日插值多项式的初步理解运用。 单位复数根 N次单位复数根$\omega$满足$\omega ^N = 1$ 定义很好理解，但是这一部分作为前置知识的内容实际上算是难点了。下图表示了$n$个单位复数根均匀的分布在以复平面的原点为圆心的单位半径的圆上。 而这究竟是怎么理解呢？Heinrich的教程很形象的做了解释： 我们假设有一条长度为1的线段在一条数轴上，那么乘以-1之后的线段就与其相反，而$i = \sqrt{-1}$，那么我们将其乘以i的线段就在一个垂直的虚数轴上，于是我们就得到了一个由一个实数轴做x轴，一个虚数轴做y轴的复平面。 然后这里就可以引入另一个重要的公式：欧拉公式：$e^{ix} = cosx + i sinx$。运用这个式子我们就得到了上图的8次单位复数根，并且也知道n次单位复数根一共有n个。而这些单位根就是$e^{\frac{2 \pi i k}{n}}$我们把n次单位根的第m个写作$\omega_n^m$。 下面是单位复数根的几个性质或推论： $\omega _{d \times n}^{d \times m} = \omega _n^m$，其中$d &gt; 0$ 对于任何偶数$n&gt;0$有$\omega _n^{n/2} = \omega_2 = -1$ 对于偶数$n&gt;0$，n个n次单位复数根的平方的集合就是$\frac n2$个$\frac n2$次单位复数根的集合。 对于任意$n \geq1$ 和不能被n整除的非负整数k，有$\sum_{i = 0}^{N - 1}(\omega_n^m)^i = 0$ 至于具体的证明就不再说了，都是很简单的推论，博友们大可自行脑补，权当是练习了。 离散傅里叶变换好了铺垫完所有的前置知识之后我们终于开始了傅里叶变换的内容。对于一个次数界为n的多项式$F(x) = \sum_{i = 1} ^{n - 1}a_ix^i$，我们在插值方面的知识可以知道n个点就可以确定这个多项式，那么我们同样也可以代入n次的n个单位复数根，来确定这个多项式，可以 求出其结果k_k = F(\omega_n^k) = \sum_{i = 0}^{n - 1}a_i \omega _n^{k_i}。 而$y​$就被称为是系数向量a的离散傅里叶变换。 这个东西计算的时间复杂度依然是$O(N^2)$，那它到底有什么用处呢？这在算法上或许无法体现，但是它是傅里叶变换在时域和频域上都呈现离散的形式，具体依然可以参考Heinrich的讲解，使其在频谱分析和数据压缩等领域发挥了巨大优势。 快速傅里叶变换也就是常说的FFT，可以说是对于DFT（离散傅里叶变换）在时间复杂度上的一大改进。 设多项式$F(x)$的系数向量$a(a_0, a_1, a_2…a_{n - 1})$，对于多项式$F(x) = \sum_{i = 0} ^ {n - 1}a_ix_i$来说，可以按照下标的奇偶性分为两个部分： F(x) = (a_0 + a_2x^2 +...+ a_{n - 2}x^{n - 2}) + (a_1 + a_3x^3...a_{n - 1}x^{n - 1})我们设 F_1(x) = a_0 + a_2x + a_4x^+...+ a_{n - 2}x^{\frac n2 - 1}F_2(x) = a_1 + a_3x + a_5x^+...+ a_{n - 1}x^{\frac n2 - 1}则 F(x) = F_1(x^2) + xF_2(x^2)和离散傅里叶变换一样，我们把$\omega _n^k$代入得到 F(\omega _n^k) = F_1(\omega _n^{2k}) + \omega _n^kF_2(\omega _n^{2k})然后同理，将$\omega _n^{k + \frac n2}$代入可以得到： F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k + n}) - F(\omega _n^kF_2(F(\omega _n^{2k} \times \omega_n^n)最后得到 F(F(\omega _n^{k + \frac n2}) = F_1(\omega _n^{2k}) - \omega _n^kF_2(\omega _n^{2k})如此我们发现，两个式子化简后，只有一个常数项相反，其他都相同，于是再计算出第一个式子的时候我们可以$O(1)$求出第二个式子，并且发现两个式子将最初的范围缩小了一半，于是原问题缩小了一般，然后我们发现子问题也满足原问题性质，$k$与$k +\frac n2$同时取遍了(0, n - 1)，于是时间复杂度缩小到$O(NlogN)$。 这个算法在FFT的计算中最为常见，是在1965年由J.W.Cooley和J.W.Tuky提出的，因此也被称为Cooley-Tukey算法，实际上是基于分治的思想实现的， 快速傅里叶逆变换也称为傅里叶反变换，上文我们在线性积分变换中提到过反积分变换，而傅里叶反变换就是傅里叶变换的反积分变换，在数学中的意义是点值表示的多项式转化为系数表示，也就是说我们要从点值向量$(a_0, a_1, a_2…a_{n - 1})$得到系数向量$(y_0, y_1, y_2…y_{n - 1})$。则我们可以设$(y_0, y_1, y_2…y_{n - 1})$是$(a_0, a_1, a_2…a_{n - 1})$进行傅里叶逆变换后的结果，并设有多项式$F(x) = \sum_{i = 0} ^{n - 1}y_0x^i$，假设有向量$(c_0, c_1, c_2…c_{n - 1})$表示多项式在$\omega_n^0, \omega_n^{-1}…\omega_n^{1 - n}$上的点值表示，则向量c满足 c_k = \sum_{i = 0} ^{n - 1}y_i(\omega_n^{-k})^i然后我们考虑将式子展开。 c_k = \sum_{i = 0} ^ {n - 1}y_i(\omega _n^{-k}) ^ i= \sum_{i = 0} ^ {n - 1}(\sum_{j = 0} ^ {n - 1}a_j(\omega _n^{j} k) ^ j)(\omega_n^{-k})^i= \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i)(\omega_n^{-k})^i ~=~ \sum_{i = 0}^{n - 1}(\sum_{j = 0} ^{n - 1}a_j(\omega_n^j)^i(\omega_n^{-k})^i)= \sum_{i = 0}^{n - 1}\sum_{j = 0}^{n - 1}a_j(\omega_n^{j - k})^i ~=~ \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0}^{n - 1}(\omega_n^{j - k})^i)设一个式子 S(\omega_n^k) = \sum_{i = 0} ^{n - 1}(\omega_n^k)^i在两边同时乘一个$\omega_n^k$得： \omega_n^kS(\omega_n^k) = \sum_{i = 0} ^{n - 1}(\omega_n^k)^{(i+1)}将前后两个式子相减，得到 \omega _n^kS(\omega_n^k) - S(\omega _n^k) = (\omega_n^k)^n - 1S(\omega _n^k) = \frac {(\omega_n^k)^n - 1}{\omega_n^k - 1}= 0则当$k = 0$的时候，其值为0 而原来的式子 c_k = \sum_{j = 0}^{n - 1}a_j(\sum_{i = 0} ^ {j - k})^i = \sum_{j = 0} ^ {n-1}a_jS(\omega_n^{j - k})当$j = k$的时候$S = n$，否则$S = 0$，所以a_i = \frac 1n c_i 这样我们得到了点值和系数的关系式，所以，从结论来说，将单位根幂上-1，然后做一次快速傅里叶变换，将结果的数除以n就是傅里叶逆变换的结果。 代码实现一般的分治都会采用递归操作实现，但是在FFT中递归实现的效率比较低，所以大多数情况下采用迭代操作实现。我们观察二进制下的序列规律发现分治到边界条件的时候每个数的下标等于原下标的二进制翻转，于是我们省去了分奇偶的操作，直接枚举每一个二进制位，然后向上合并就可以了。下面是迭代操作实现的代码。 1234567int l = 0 ; while ((1 &lt;&lt; l) &lt; N) l ++ ;for (int i = 0 ; i &lt; N ; i ++) &#123; int T = 0 ; for (int j = 0 ; j &lt; l ; j ++) if (i &amp; (1 &lt;&lt; j)) T /= (1 &lt;&lt; (k - j - 1)) ; if (i &lt; t) swap(a[i], a[T]) ;&#125; 蝴蝶操作我们把$\omega_n^k$称为旋转因子并保留下来，进入两个向量$a_k^0$和$a_k^1$时，旋转因子$\omega_n^k$乘以$a_k^1$，输出与$a_k^0$的和与差，这一个操作被称为蝴蝶操作。那这个东西究竟有什么作用呢？ 重新考虑我们向上合并两个子问题时，假设有$A_1(\omega_{n/2}^k)$储存在$a(k)$中，$A_2(\omega _{n/2}^k)$储存在$a(k +\frac n2)$中，并且这两个值将要被储存在$b(k)$和$b(k + \frac n2)$中，则合并的操作可以如下表示： b(k) ← a(k) + a(k +\frac n2) \times\omega_n^kb(k +\frac n2) ← a(k) - a(k +\frac n2) \times\omega_n^k于是我们考虑将两个值存放在原来的a中，取消b数组的存在，但是需要覆盖原来的值，所以就需要一个临时变量T。 T ←a(k +\frac n2) \times\omega_n^ka(k +\frac n2) ← a(k) - Ta(k) ← a(k) - T名字很好听，其实操作很简单，仅仅有一行而已。 模板代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;using namespace std ;typedef long long LL ;const int MAXN = 10000010 ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;int N, M, l, r[MAXN], L = 1 ;const double Pi = acos(-1.0);struct complex &#123; double x, y ; complex (double xx = 0, double yy = 0) &#123;x = xx, y = yy ;&#125;&#125; a[MAXN], b[MAXN] ;complex operator + (complex a, complex b) &#123; return complex(a.x + b.x , a.y + b.y) ;&#125;complex operator - (complex a, complex b) &#123; return complex(a.x - b.x , a.y - b.y) ;&#125;complex operator * (complex a, complex b) &#123; return complex(a.x * b.x - a.y * b.y , a.x * b.y + a.y * b.x) ; &#125;inline void FFT(complex *A, int type) &#123; for (int i = 0 ; i &lt; L ; i ++) if (i &lt; r[i]) swap(A[i], A[r[i]]) ; for (int Mid = 1 ; Mid &lt; L ; Mid &lt;&lt;= 1) &#123; complex W(cos(Pi / Mid), type * sin(Pi / Mid)) ; for (int R = Mid &lt;&lt; 1, j = 0 ; j &lt; L ; j += R) &#123; complex w(1, 0) ; for (int k = 0 ; k &lt; Mid ;k ++, w = w * W) &#123; complex x = A[j + k], y = w * A[j + Mid + k] ; A[j + k] = x + y ; A[j + Mid + k] = x - y ; &#125; &#125; &#125;&#125;int main() &#123; int N = Read(), M = Read() ; for (int i = 0 ; i &lt;= N ; i ++) a[i].x = Read() ; for (int i = 0 ; i &lt;= M ; i ++) b[i].x = Read() ; while (L &lt;= N + M) L &lt;&lt;= 1, l ++ ; for (int i = 0 ; i &lt; L ; i ++) r[i] = (r[i &gt;&gt; 1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (l - 1)) ; FFT (a, 1) ; FFT (b, 1) ; for (int i = 0 ; i &lt;= L ; i ++) a[i] = a[i] * b[i] ; FFT(a, - 1) ; for (int i = 0 ; i &lt;= N + M ; i ++) printf("%d ", (int)(a[i].x/ L + 0.5)) ; &#125; 参考文献同济高等数学，Thomas H.Cormen算法导论，Miskcoo 从多项式乘法到快速傅里叶变换，郭晓旭 FFT讲义，维基百科 傅里叶变换，白霂凡 Fast Fourier Transform，Menci FFT学习笔记，Heinrich 傅里叶分析之掐死教程，attack 快速傅里叶变换(FFT)详解]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>傅里叶变换</tag>
        <tag>线性积分变换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[SDOI2015]约数个数和]]></title>
    <url>%2F2019%2F02%2F13%2FSDOI2015-%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%2F</url>
    <content type="text"><![CDATA[如题，设$d(x)$表示$x$的约数个数，求\sum_{i = 1}^N \sum_{j = 1}^Md(i \times j)首先要知道约数个数的一种表示方法：d(i,j) = \sum_{x|i} \sum_{y_j}[gcd(x,y) == 1]然后题目所求就变成了 \sum_{i = 1}^N \sum_{j = 1}^M \sum_{k | i} \sum_{l | j}[gcd(k,l) == 1]化简，改变量之后式子变为 \sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == 1)(\frac Mi)(\frac Mj)考虑莫比乌斯反演,设 f(X) = \sum_{i = }^N \sum_{j = 1}^M(gcd(i,j) == x)(\frac Ni)(\frac Mj) F(x) = \sum_{x|n}f(n) → F(x) = \sum_{i = }^N \sum_{j = 1}^{N / x}(x|gcd())(\frac Ni)(\frac Mj) → F(x) = \sum_{i = }^N \sum_{j = 1}^{M / x}(\frac {N}{ix})(\frac {M}{jx})考虑优化算法时间复杂度，可以预处理出$\sum_{i = 1}^N(\frac Ni)$和$\sum_{j = 1}^M (\frac Mj)$，连带着莫比乌斯函数可以直接O(N)预处理。12345678910111213141516171819inline void Init() &#123; U[1] = F[1] = 1 ; for (int i = 2 ; i &lt;= MAXN ; i ++) V[i] = true ; for (int i = 2 ; i &lt;= MAXN ; i ++) &#123; if (V[i]) U[i] = - 1, P[++ Tot] = i, F[i] = 2, G[i] = 1 ; for (int j = 1 ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123; V[i * P[j]] = false ; if (i % P[j] == 0) &#123; U[i * P[j]] = 0 ; F[i * P[j]] = F[i] / (G[i] + 1) * (G[i] + 2) ; G[i * P[j]] = G[i] + 1 ; break ; &#125; else U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; 1), G[i * P[j]] = 1 ; &#125; &#125; for (int i = 1 ; i &lt;= MAXN ; i ++) S[i] = S[i - 1] + U[i], Sum[i] = Sum[i - 1] + F[i] ;&#125; 问题答案化简为$f(1)$。反演后得到f(1) = \sum{x = 1}^N \mu (x) F(x) = \sum_{x = 1}^N \mu(x) \sum_{i = 1}^{N/x} \sum _{j = 1}^{M / x} (\frac Ni) (\frac Mj)进行数论分块就可以了，总体时间复杂度$O(T\sqrt N)$，其中T为数据组数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 50010 ;const int MAXM = 50010 ;int N, M, U[MAXN], P[MAXN], Tot ;int S[MAXN], Sum[MAXN], F[MAXN], G[MAXN] ;bool V[MAXN] ; long long Ans ;inline int Read() &#123; int X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void Init() &#123; U[1] = F[1] = 1 ; for (int i = 2 ; i &lt;= MAXN ; i ++) V[i] = true ; for (int i = 2 ; i &lt;= MAXN ; i ++) &#123; if (V[i]) U[i] = - 1, P[++ Tot] = i, F[i] = 2, G[i] = 1 ; for (int j = 1 ; j &lt;= Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123; V[i * P[j]] = false ; if (i % P[j] == 0) &#123; U[i * P[j]] = 0 ; F[i * P[j]] = F[i] / (G[i] + 1) * (G[i] + 2) ; G[i * P[j]] = G[i] + 1 ; break ; &#125; else U[i * P[j]] = - U[i], F[i * P[j]] = (F[i] &lt;&lt; 1), G[i * P[j]] = 1 ; &#125; &#125; for (int i = 1 ; i &lt;= MAXN ; i ++) S[i] = S[i - 1] + U[i], Sum[i] = Sum[i - 1] + F[i] ;&#125;int main() &#123; int T = Read() ; Init () ; while (T --) &#123; Ans = 0 ; N = Read() ; M = Read() ; for (int l = 1, r ; l &lt;= min(N, M) ; l = r + 1) &#123; r = min(N / (N / l), M / (M / l)) ; Ans += 1ll * (S[r] - S[l - 1]) * Sum[N / l] * Sum[M / l] ; &#125; printf("%lld\n", Ans) ; &#125;&#125;]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数论 莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[莫比乌斯反演初步与实际应用]]></title>
    <url>%2F2019%2F02%2F02%2F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94%E5%88%9D%E6%AD%A5%E5%92%8C%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[莫比乌斯反演初步和实际应用定义和一般形式及其证明 假设有数论函数关系式$F(N) = \sum_{x|N}f(x)$，则有$f(N) = \sum_{x|N}\mu(x)F(\frac Nx) = \sum_{x|N}\mu(\frac xN)F(x)$ 此为基本定义，但是看到这个函数也有限制就是必须是数论函数。，也就是定义域为正整数，对应集合为复数的函数。下面是函数的一般形式。 假设d定义在$[1,∞)$上的复值函数$G(N) = \sum_{x = 1}^NF(\frac Nx)$，则有$F(N) = \sum_{x = 1}^N\mu(x)G(\frac Nx)$ 而这个$\mu(x)$函数就是莫比乌斯函数，其定义如下： $x= 1$时，$\mu(x) = 1$。 $x = P_1P_2…P_M$，（$P$为互异素数），则$\mu(x) = (-1)^M$ 其他情况下$\mu(x) = 0$ 由定义可以得到莫比乌斯函数的两个重要性质： 对任意正整数$N$有$\sum_{x|N}\frac{\mu(x)}{x} = \frac{\varphi(N)}{N}$ 证明 : 设有 \sum_{x|N}\mu(x) = [N = 1], f(N) = \sum_{x|N}[\frac Nx = 1]f(x)代入得 f(N) = \sum_{x|N}\sum_{y|\frac Nx}\mu(y)f(x)由于$\sum_{x|N}\sum_{y|\frac Nx}$的限制条件为$xy|N$，所以等式写成: f(N) = \sum_{y|N}\mu(y)\sum_{x|\frac Ny}f(x) = \sum_{y|N}\mu(y)F(\frac Ny)证明完毕。 代码实现用线性筛法求莫比乌斯函数，时间复杂度$O(N)$ 123456789101112131415inline void Init() &#123; memset(V, 0, sizeof(V)) ; Mu[1] = 1 ; Tot = 0 ;&#125;inline void MU() &#123; for (int i = 2 ; i &lt; N ; i ++) &#123; if (! V[i]) P[++ Tot] = i, Mu[i] = - 1 ; for (int j = 0 ; j &lt;= Tot &amp;&amp; P[j] &lt; N ; j ++) &#123; V[i * P[j]] = 1 ; if (i % P[j]) Mu[i * P[j]] = - Mu[i] ; else &#123;Mu[i * P[j]] = 0 ; break ; &#125; &#125; &#125;&#125; 例题：YY的GCD 给定$N, M$，求所有的$X \leq N,~Y \leq M$中$gcd(X, Y)$是质数的点对有多少对。 类似于一个模板题，因为其思维难度不是很大。考虑公式化题目描述，即求：\sum_{X = 1}^N \sum_{Y = 1}^M [gcd(i,j) == P] 设$f(x)​$为满足$gcd(X, Y) = X​$的$(X, Y)​$的对数，$F(X)​$为满足$X|gcd(X, Y)​$二点$(X, Y)​$的对数。得到 F(N) = \sum_{x|N}f(x)​所以根据莫比乌斯反演定理，得​ f(N) = \sum_{x|N}\mu(\frac xN)F(x) =\sum_{x|N}\mu(\frac xN)\frac{N \times M}{X^2}​而题目要求其$gcd(X,Y)$是一个质数也就是说 Ans = \sum_P^{min(N, M} \sum_i^N\sum_j^M[gcd(i,j) = P] = \sum_P^{Minn(N,M)}f(P)设$T = PX$，则式子变为 \sum_{T = 1}^{Min(N,M)}\frac{N \times M}{T^2}(\sum_{G|T}\mu(\frac TG))于是为了提高速度，可以预处理$\sum_{G|T}\mu(\frac TG)$。于是此题就以较快得速度解决了。 但是如果是多组数据还是有可能会$TLE$，所以如果想要更快，还可以使用整除分块。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std ;typedef long long LL ;const int MAXN = 10000010 ;long long T, N, M, V[MAXN], P[MAXN], Mu[MAXN], Tot ;long long S[MAXN], Ans, G[MAXN] ;inline long long Read() &#123; long long X = 0, F = 1 ; char ch = getchar() ; while (ch &gt; '9' || ch &lt; '0') F = (ch == '-' ? - 1 : 1), ch = getchar() ; while (ch &gt;= '0' &amp;&amp; ch &lt;= '9') X=(X&lt;&lt;1)+(X&lt;&lt;3)+(ch^48), ch = getchar() ; return X * F ;&#125;inline void MU() &#123; memset(V, 0, sizeof(V)) ; Mu[1] = 1 ; Tot = 0 ; for (int i = 2 ; i &lt; MAXN ; i ++) &#123; if (! V[i]) P[Tot ++] = i, Mu[i] = - 1, G[i] = 1 ; for (int j = 0 ; j &lt; Tot &amp;&amp; i * P[j] &lt; MAXN ; j ++) &#123; V[i * P[j]] = 1 ; if (i % P[j]) Mu[i * P[j]] = - Mu[i], G[i * P[j]] = Mu[i] - G[i] ; else &#123; Mu[i * P[j]] = 0 ; G[i * P[j]] = Mu[i] ; break ; &#125; &#125; &#125; for (int i = 1 ; i &lt; MAXN ; i ++) S[i] = S[i - 1] + G[i] ;&#125;int main() &#123; MU() ; T = Read() ; while (T --) &#123; Ans = 0 ; N = Read(), M = Read() ; for (int i = 1, j ; i &lt;= min(N, M) ; i = j + 1) &#123; j = min(N / (N / i), M / (M / i)) ; Ans += (N / i) * (M / i) * (S[j] - S[i - 1]) ; &#125; printf("%lld\n", Ans) ; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插值法及拉格朗日插值多项式]]></title>
    <url>%2F2019%2F02%2F01%2F%E6%8F%92%E5%80%BC%E6%B3%95%E5%8F%8A%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E5%A4%9A%E9%A1%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[$Interpolation$：“插值”，适用于解决复杂、难于计算的函数表达式问题的有力手段，更有时根本没有具体的函数，只有对应采样点的几个函数值，而要求计算非采样点的函数值的问题，此时插值法就可以构造出该函数的近似表达式来解决问题。 一：什么是插值插值是属于数学数值分析领域的内容，常被称作内插或者插值。接下来给出定义： 给定N个数据离散点$(x_k,y_k)$，其中$k = 1,2,3…N$。对于$x$求$x$对应的$y$值叫做内插。 L_n(x) = \sum_{k = 0}^ny_kl_k(x)定义域在区间$[A,B]$上有意函数$F$，已知函数$G$在$[A,B]$范围内满足$G(x_i) = F(x_i) = 1,2…N$ 则称$G(x)$为$F(x)$关于节点${x_i}_{i = 0}^N$上的插值函数。 假设我们已经求得$x_i$集合中的最大值$MAX$和最小值$MIN$ 用插值函数$G(x)$计算被插值函数$F(x)$在点$x \in (MIN, MAX)$处的近似值的方法称为内插法。 用插值函数$G(x)$计算被插值函数$F(x)$在点$x \in [A, B]$但$x \notin [MIN, MAX]$处的近似值的方法称为外插法。 那么你现在已经基本了解了什么是插值，下面我们来看一些关于插值方法的东西。 二：插值方法简介1.片段插值这种插值方法几乎不能算是插值了，所实话如果没有维基百科编者根本就不知道有这种插值方法以及这样也能算是插值。 简单来说就是找到离$x$最近的采样点$x_i$，然后将$y$值分配为$y_i$。因此它的别称就是最近邻插值。但是就和wiki说的一样，这种插值方法是几乎碰不到的，因为出不了什么很高深的符合当前阶段学习的题目，但同时如果可以使用这种方法，无疑将使时间和复杂性都大大降低。 2.线性插值这种插值从某种意义上说是利用了斜率，但实际上就是很简单的取平均值而已。 假设我们已知了所有自然数采样点${x_i}$，而我们要求的插值点是$x_{i+0.5}$,那么发现当前插值点是处于$x_i和x_{i+1}$之间，那么我们取的分配值就是$\frac{y_i+y_{i + 1}}{2}$。以数学公式的方法表达就是： $y = y_a + (y_b - y_a) \frac{x - x_a}{x_b - x_a}$ $G(x) = y_a \frac{x - x_b}{x_a - x_b} + y_b \frac{x - x_a}{x_b - x_a}$ 发现$G(x)$实际上是两个一次多项式的组合。也就是说，我们过这两个点分别作一次多项式$l_a = \frac{x - x_b}{x_a - x_b},~l_2 = \frac{x - x_a}{x_b - x_a}$，那么$G(x) = y_al_a + y_bl_b$。 而实际上上述两种插值方法都存在误差，撇开片段插值不谈，线性插值的误差来源只要是因为插值点$x_k$是不可微分的，而计算得出的误差是$|F(x) - G(x)| \leq C(x_b - x_a)^2~where~C= \frac18max_{r \in[x_a, x_b]}|g^{‘’}(r)|$ 其与数据点的距离平方成正比。 我们发现前两者的不同在于第一个找到了一个采样点进行插值，而线性插值则找到了两个点，因为两点确定一个一次函数。相同的，我们也有三点确定的二次函数的抛物线插值法，这里不再进行分析。 3.多项式插值 已知函数$F(x)$在$[A, B]$上$N + 1$个点处的函数值$\{y_i\}_{i = 0}^N$，求次数不超过$N$的多项式$G(x) = c_0 +c_1x+…+c_Nx^N$使得$G(x) = F(x)$称为多项式插值。 定理：多项式插值函数存在且唯一：我们都知道过$N + 1$个点做一个$N$次函数最多只能做一个，而做一个$≥N$次的函数却可以有无数个。 三：拉格朗日插值法建立插值多项式的方法（简称为插值法）最基本的是需要求解线性方程组，而这是最为冗杂，最为复杂的算法，一般没有特殊情况是不会用这种方法构造插值多项式的。因此经过前人的努力，引入了一种更为简单，实现更为便捷的插值法：拉格朗日插值法。与之相通的有牛顿插值法，而我们又知道多项式插值函数的唯一性，因此恒有$L_n(x) = N_n(x)$。（L：拉格朗日，N：牛顿）。 在准备好了解拉格朗日插值法之前，我们先引入一个基函数的概念。 记$H_n(x)$为次数不超过$N$的多项式全集，也就是有$H_0(x),H_1(x)…H_n(x)$，设其构成$H_n(x)$的一组基，则插值多项式可表示为$G(x) = a_0H_0(x) + … + a_nH_n(x)$。 那么我们只要寻找到合适的基函数和插值多项式在这组基下的线性表示系数，就可以通过基函数构造插值多项式，也就是基函数插值法。 回到拉格朗日插值上来，我们首先寻找基函数。 设$l_k(x)$是$n$次多项式，在节点$x_0，x_1…x_n$上满足$l_k(x_i) = 1 ~(i = k)$或$l_k(x_i) = 0~(i ≠ k)$，则称$l_k(x)$为节点$\{x_i\}_{i = 0}^N$上的$n$次拉格朗日插值基函数。 构造法可以知道$l_k(x) = \prod_{i = 0,i ≠ k}^{N} \frac{x - x_i}{x_k - x_i}$ 知道基函数之后我们用基函数求$G(x) = a_0l_0(x) + … + a_nl_n(x)$，带入$G(x_i) = y_i$可得 $L_n(x) = \sum_{k = 0}^ny_kl_k(x)$ 上方的$L_n(x)$就是我们的拉格朗日插值多项式，具有结构清晰紧凑的特点，是用于理论分析的一般手法。根据插值误差估计定理可以估计出误差为：$\frac{y_{n + 1}(ζ)}{(n + 1) !} \omega_{n+1}(x)$，其小于$\frac{M_{n+1}}{(n+1)!}|\omega_{n+1}|(x)$。 重心拉格朗日插值法按照维基百科说的，这是对拉格朗日插值法的一种改进。当然，指的是速度上的，误差方面并没有什么差别。 按照均摊来说，如果用朴素拉格朗日插值法求插值函数，时间复杂度是$O(N^2)$，而中心拉格朗日插值法可以将时间复杂度压缩到$O(N)$。讲了整整一个量级，不可谓不改进。但从大多数方面来说，朴素拉格朗日也足足够用了。 实质上一致的前提下，中心拉格朗日插值法改写了拉格朗日基本多项式$l_j(x)$。 $l(x) = \prod_{i = 0}^K(X - X_K)$，使$l_j(x) = \frac{l(x)}{x - x_j} \times \frac{1}{\prod _{i = 0}^K(x_j - x_i)}$ 然后定义一个重心权$w_j = \prod_{i = 0}^K\frac{1}{x_j - x_i}$，则$L(x) = l(x)\sum_{j = 0}^K \frac{w_j \times y_j}{x - x_j}$。 然后这个玩意怎么改进拉格朗日了呢？ 当插值点的个数增加一个的时候，将每一个$w_j$都除以)$(x_j - x_{K + 1})$，得到$w_{k + 1}$，直接省掉了一个循环，因此复杂度变为了$O(N)$。 （维基百科原话，还是能看懂的。） 据说这个重心拉格朗日插值法不仅仅速度更优，并且省掉了多项式$l(x)$的计算，还有说什么不同于第一型的拉格朗日插值函数的向后稳定，这个改进后的第二型拉格朗日插值函数是向前稳定的，勒贝格常数非常小，因为什么切比雪夫节点插值的极佳稳定性之类的。 当然，这种切比雪夫节点、勒贝格常数之类的就不是我们此次要学习的范围了，读者只要重心拉格朗日插值法把朴素拉格朗日插值法速度上甩了一大截就可以了。追求完美的读者可以试着一学。 拉格朗日插值基函数的性质及其应用 当$F(x)$为一个多项式且次数$\leq n$时，有$F^{(n+1)}(x) \equiv 0$，所以$R_n(x) = F(x) - L_n(X) \equiv 0$，（R为误差）因此$n$次插值多项式对于次数$\leq n$的多项式是精确的。 若$F(x) = x^k$其中$k \leq n$，那么$R_n(x) = x^k - \sum_{j = 0}^nX^kl_j(x) = 0$。特别的，当$k = 0$的时候有$\sum_{j = 0}^nl_j(x) = 1$。 结合上面的性质及其公式，我们尝试解决一些实际问题。从最经典的应用开始，熟练地运用拉格朗日公式解决插值类问题。 连续自然数幂和（差分表） 已知$K$，求$\sum _{i = 1}^Ni^K$ 首先介绍一个叫做“差分表”的小知识点。这个名字我们很自然想到差分的思想，而我们平常用的差分（$a[i + 1] - a[i]$）只是叫做一阶差分，根据这个最基本的，我们定义出”差分表“的东西。 对于函数$F(x)$，把$F’(X) = F(X + 1) - F(X)$叫做一阶差分，称$F’(X)$叫做差分算子。引申出对于$K &gt; 1$，有$F’^K(X) = F’^{K - 1}(X + 1) - F’^{K - 1}(X)$为$K$阶差分。 算出所有的$F’^K(X)$，将$X = 1,2,3…H$，代入每一个$F’^K(X)$，得到一个二维的表。即是差分表。 可以观察到列数递减，我们把所有的数插空排列，便形成了差分表的基本形状。 接着是引入的两个定理，可以直接使用： 如果多项式的次数为$N$，则对于所有大于$N$的$K$，多项式的$K$阶差分都恒等于$0$。 假设多项式$F(X)$的差分表的左斜列中各个元素依次是$D_0,D_1…D_M$，那么对于这个多项式的和恒有： $Sum(X) = \sum_{X = 0}^NF(X) = D_0C_{N + 1}^1 + D_1C_{N + 2}^1 + H + D_MC_{N + 1}^{M + 1}$ 以这个差分表作为工具，我们尝试从简单开始逐步解决这个问题。 首先假设$F(X) = X$，那么 我们构造出差分表的样子大概是这样的： 1230 1 2 3 4 5 6 …… 1 1 1 1 1 1 …… 0 0 0 0 0 …… 所以$Ans = 1 + 2 + H + N = 0 \times C_{N + 1}^1 + 1 \times C_{N + 2}^2$ 所以$Ans = \frac{N(N + 1)}{2}$ 接着引申到$F(X) = X^2$，建立出差分表 12340^2 1^2 2^2 3^2 4^2 5^2 6^2 …… 1 3 5 7 9 11 …… 2 2 2 2 2 …… 0 0 0 0 …… 答案就是$1^2 + 2^2 + H + N^2 = 0C_{N + 1}^1 + 1C_{N + 2}^1 + H + 2C_{N + 1}^{M + 1}$ 所以答案为$\frac{N(N + 1)(2N + 1)}{6}$ 因此我们引出了$Ans(K)$就是一个关于$N$的$K + 1$次多项式。 知道如此结论，我们就可以选择$K + 1$个点然后利用拉格朗日插值公式进行计算了。夫再度$O(K)$。 例题：Study 给定了$K, A, N, D$，求$\sum_{i = 0}^N \sum_{j = 1}^{A + iD} \sum_{l = 1}^jl^K$ 实际上和上面那个题没有什么很大的区别，式子虽然很长，我们从里到外分开考虑即可 最里面的$\sum_{l=1}^jl^k$是一个关于$j$的$k+1$次的多项式。把其差分表的第一条对角线求出来。 然后$\sum_{j=1}^{A+iD}\sum_{l=1}^jl^k$是关于$i$的$k+2$次的多项式。$O(k^2)$求出$i=0,1,…k+2$的值。 所以答案就是一个关于$N$的$k+3$次的多项式。求其第一条对角线即可。 拉格朗日插值法的代码实现经过上述的学习之后，代码实现可能反而是小事了。给出模板题的连接：拉格朗日插值法 给出$N$个点$(X_i,Y_i)$，确定一个唯一的$N - 1$次多项式，代入$k$求值。 代入所有的点，按照上述的讲解，爆搞就可以了。 1234567891011121314151617181920212223inline long long QuickPow(LL X, LL Y) &#123; long long Ans = 1 ; while (Y) &#123; if (Y &amp; 1) Ans = Ans * X % Mod ; Y &gt;&gt;= 1 ; X = X * X % Mod ; &#125; return Ans ;&#125;int main() &#123; N = Read() ; K = Read() ; for (int i = 1 ; i &lt;= N ; i ++) X[i] = Read(), Y[i] = Read() ; for (int i = 1 ; i &lt;= N ; i ++) &#123; int Ken = 1 ; for (int j = 1 ; j &lt;= N ; j ++) &#123; if (i == j) continue ; Ken = Ken * (X[i] - X[j] + Mod) % Mod ; &#125; Ken = QuickPow(Ken, Mod - 2) ; for(int j = 1 ; j &lt;= N ; j ++) &#123; if (i == j) continue ; Ken = Ken * (K - X[j] + Mod) % Mod ; &#125; Ken = Ken * Y[i] % Mod ; Ans = Ans + Ken % Mod ; &#125; printf("%lld", Ans % Mod) ; return 0 ;&#125; 后记都是说拉格朗日插值法好用，之后才知道它的优点在哪： 代替线性，抛物线之类的插值方法繁琐的公式结构和计算方法，其公式结构整齐紧凑，好看得多。 可能有人感觉很好笑，但是这确实是很重要的一点。考场上推出来超级复杂繁琐的方程式会让你心态爆炸的，因此简单整齐的公式结构也是十分重要的，好写好看，这可能也是他广为人用的原因之一吧。 但当然，数学仍然是不完整的，对于采样点较多的情况时出现的龙格现象，也表明拉格朗日插值法具有数值不稳定的特点，因此大多数情况，拉格朗日插值法仍用于解决次数较低的插值多项式问题。 牛顿插值法不再将了，因为其本质是一样的，充其量走了不同的路子而已，想学的朋友可以去了解一下。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>拉格朗日插值法</tag>
        <tag>差分法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于动态规划问题的优化方案]]></title>
    <url>%2F2019%2F02%2F01%2F%E5%85%B3%E4%BA%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[浅谈关于动态规划问题的优化方案1.单调队列优化 单调队列是一种具有单调性的队列，其中的元素全部按照递增或者递减的顺序排列，就比如下面这个递减队列。 假如说我们要在队尾加入一个$5$，那么我们入队的步骤就是这样的： 发现队尾$1$，(q[tail])，$1]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>单调队列优化</tag>
        <tag>斜率优化</tag>
      </tags>
  </entry>
</search>
